<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>apache2配置</title>
    <link href="/2022/03/14/apache2/apache%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/03/14/apache2/apache%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<ol><li><p>修改根目录</p><p> <code>sudo vim /etc/apache2/sites-available/000-default.conf</code></p><p> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16472624549641647262453315.png" alt="修改图片"></p><p> 其中 /var/www/html2  就是我要修改的根目录了。</p></li><li><p>重启apche服务器</p><p> <code>sudo service apache2 restart</code></p></li><li><p>使用非根目录的话，需要修改apache2.conf</p><p> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16472626730631647262672838.png" alt="修改为对应的根目录"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>apache2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BA%A7%E5%88%AB%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%B5%8B/"/>
    <url>/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BA%A7%E5%88%AB%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="课设内容"><a href="#课设内容" class="headerlink" title="课设内容"></a>课设内容</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p> 在32位的虚拟机boches虚拟机上面编译lunix0.11的源代码并且运行，完成whoami和iam的系统调用。以及对lunix进程调度进行日志打印，利用python脚本对日志文件进行处理，并展示linux0.11从系统初始化到调取终端shell各进程的状态转换。</p><h3 id="进程日志监测"><a href="#进程日志监测" class="headerlink" title="进程日志监测"></a>进程日志监测</h3><h4 id="提前打开log文件"><a href="#提前打开log文件" class="headerlink" title="提前打开log文件"></a>提前打开log文件</h4><p>为了能尽早开始记录，应当在内核启动时就打开 log 文件。内核的入口是 init/main.c 中的 main()。细节在main()的一端代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//……</span><br>move_to_user_mode();<br><span class="hljs-keyword">if</span> (!fork()) &#123;        <span class="hljs-comment">/* we count on this going ok */</span><br>    init();<br>&#125;<br><span class="hljs-comment">//……</span><br></code></pre></td></tr></table></figure><p>此段代码在进程0中运行，切换到用户态，然后系统通过调用fork()创建进程1，进程1调用init（）仅从初始化，在 init() 当中，我们可以观察到如下主要代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ……</span><br><span class="hljs-comment">//加载文件系统</span><br>setup((<span class="hljs-keyword">void</span> *) &amp;drive_info);    <br><br><span class="hljs-comment">// 打开/dev/tty0，建立文件描述符0和/dev/tty0的关联</span><br>(<span class="hljs-keyword">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 让文件描述符1也和/dev/tty0关联</span><br>(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 让文件描述符2也和/dev/tty0关联</span><br>(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// ……</span><br><br></code></pre></td></tr></table></figure><p>  这段代码建立了文件描述符 0、1 和 2，它们分别就是 stdin、stdout 和 stderr。这三者的值是系统标准，不可改变。因此我们可以在这之后进行日志文件的建立，以便后续进程检测的日志写入。</p><p>  并且问了及早地访问<code>log</code>文件，我们需要让上述代码在进程0中完成，所以将此本次代码从<code>init()</code>移动到<code>main()</code>中，放在<code>move_to_user_mode()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//……</span><br>move_to_user_mode();<br><br><span class="hljs-comment">/***************添加开始***************/</span><br>setup((<span class="hljs-keyword">void</span> *) &amp;drive_info);<br><br><span class="hljs-comment">// 建立文件描述符0和/dev/tty0的关联</span><br>(<span class="hljs-keyword">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);    <br><br><span class="hljs-comment">//文件描述符1也和/dev/tty0关联</span><br>(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);        <br><br><span class="hljs-comment">// 文件描述符2也和/dev/tty0关联</span><br>(<span class="hljs-keyword">void</span>) dup(<span class="hljs-number">0</span>);        <br><br>(<span class="hljs-keyword">void</span>) open(<span class="hljs-string">&quot;/var/process.log&quot;</span>,O_CREAT|O_TRUNC|O_WRONLY,<span class="hljs-number">0666</span>);<br><br><span class="hljs-comment">/***************添加结束***************/</span><br><br><span class="hljs-keyword">if</span> (!fork()) &#123;        <span class="hljs-comment">/* we count on this going ok */</span><br>    init();<br>&#125;<br><span class="hljs-comment">//……</span><br></code></pre></td></tr></table></figure><p>  这样，文件描述符 0、1、2 和 3 就在进程 0 中建立了。根据 <code>fork()</code> 的原理，进程 1 会继承这些文件描述符，所以 <code>init()</code> 中就不必再 <code>open()</code> 它们。此后所有新建的进程都是进程 1 的子孙，也会继承它们。但实际上，<code>init()</code> 的后续代码和 <code>/bin/sh</code> 都会重新初始化它们。所以只有进程 0 和进程 1 的文件描述符肯定关联着 log 文件，这一点在接下来的写 log 中很重要。</p><h4 id="写log文件"><a href="#写log文件" class="headerlink" title="写log文件"></a>写<code>log</code>文件</h4><p>在内核状态下，write() 功能失效，因此需要自己动手写相应的文件输出功能。因此需要重新编写<code>fprintk()</code>，因为该函数和 <code>printk</code> 的功能近似，因此将此函数放入到 <code>kernel/printk.c</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;linux/sched.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;sys/stat.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> logbuf[<span class="hljs-number">1024</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fprintk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list args;<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span><br><br>    va_start(args, fmt);<br>    count=<span class="hljs-built_in">vsprintf</span>(logbuf, fmt, args);<br>    va_end(args);<br><span class="hljs-comment">/* 如果输出到stdout或stderr，直接调用sys_write即可 */</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        __asm__(<span class="hljs-string">&quot;push %%fs\n\t&quot;</span><br>            <span class="hljs-string">&quot;push %%ds\n\t&quot;</span><br>            <span class="hljs-string">&quot;pop %%fs\n\t&quot;</span><br>            <span class="hljs-string">&quot;pushl %0\n\t&quot;</span><br>        <span class="hljs-comment">/* 注意对于Windows环境来说，是_logbuf,下同 */</span><br>            <span class="hljs-string">&quot;pushl $logbuf\n\t&quot;</span> <br>            <span class="hljs-string">&quot;pushl %1\n\t&quot;</span><br>        <span class="hljs-comment">/* 注意对于Windows环境来说，是_sys_write,下同 */</span><br>            <span class="hljs-string">&quot;call sys_write\n\t&quot;</span> <br>            <span class="hljs-string">&quot;addl $8,%%esp\n\t&quot;</span><br>            <span class="hljs-string">&quot;popl %0\n\t&quot;</span><br>            <span class="hljs-string">&quot;pop %%fs&quot;</span><br>            ::<span class="hljs-string">&quot;r&quot;</span> (count),<span class="hljs-string">&quot;r&quot;</span> (fd):<span class="hljs-string">&quot;ax&quot;</span>,<span class="hljs-string">&quot;cx&quot;</span>,<span class="hljs-string">&quot;dx&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>    <br><span class="hljs-comment">/* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/</span><br>    &#123;<br>    <span class="hljs-comment">/* 从进程0的文件描述符表中得到文件句柄 */</span><br>        <span class="hljs-keyword">if</span> (!(file=task[<span class="hljs-number">0</span>]-&gt;filp[fd]))    <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        inode=file-&gt;f_inode;<br><br>        __asm__(<span class="hljs-string">&quot;push %%fs\n\t&quot;</span><br>            <span class="hljs-string">&quot;push %%ds\n\t&quot;</span><br>            <span class="hljs-string">&quot;pop %%fs\n\t&quot;</span><br>            <span class="hljs-string">&quot;pushl %0\n\t&quot;</span><br>            <span class="hljs-string">&quot;pushl $logbuf\n\t&quot;</span><br>            <span class="hljs-string">&quot;pushl %1\n\t&quot;</span><br>            <span class="hljs-string">&quot;pushl %2\n\t&quot;</span><br>            <span class="hljs-string">&quot;call file_write\n\t&quot;</span><br>            <span class="hljs-string">&quot;addl $12,%%esp\n\t&quot;</span><br>            <span class="hljs-string">&quot;popl %0\n\t&quot;</span><br>            <span class="hljs-string">&quot;pop %%fs&quot;</span><br>            ::<span class="hljs-string">&quot;r&quot;</span> (count),<span class="hljs-string">&quot;r&quot;</span> (file),<span class="hljs-string">&quot;r&quot;</span> (inode):<span class="hljs-string">&quot;ax&quot;</span>,<span class="hljs-string">&quot;cx&quot;</span>,<span class="hljs-string">&quot;dx&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>fprintk()</code>主要函数功能如下，传入文件描述符，进程当前<code>pid</code>和滴答数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 向log文件输出跟踪进程运行轨迹</span><br>fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;R&#x27;</span>, jiffies); <br></code></pre></td></tr></table></figure><p>jiffies 表示从开机时到现在发生的时钟中断次数，这个数也被称为 “滴答数”。由代码知，jiffies 实际上记录了从开机以来共经过了多少个 10ms(1/100秒)。</p><h4 id="寻找状态切换点"><a href="#寻找状态切换点" class="headerlink" title="寻找状态切换点"></a>寻找状态切换点</h4><p>状态切换点主要集中在kernel 下的<code>fork.c</code>,<code>shed.c</code>和<code>exit.c</code>当中。</p><p>在linux 0.11中进程状态其实只有就绪（运行）、等待、退出，处于就绪态的进程一旦得到CPU就进入到运行态。这也是系统调度的基础，就是看所有就绪态的进程哪个应该被运行（看时间片）。生成的进程状态有两种改变情形，一种是被抢占（时间片调度），一种是主动让出（等待）。其中抢占只发生在调度时，等待则有以下几种情形，sys_pause（主动暂停），sys_waitpid（等待子进程结束），sleep_on（睡眠）以及不可中断睡眠，而睡眠的进程被唤醒则有主动唤醒及信号唤醒。被唤醒的进程则参与调度，会再一次使用CPU。进程运行结束或被手工杀死后，进程状态会变为僵尸进程，会在调度过程中被释放。</p><h5 id="记录一个进程生命周期的开始"><a href="#记录一个进程生命周期的开始" class="headerlink" title="记录一个进程生命周期的开始"></a>记录一个进程生命周期的开始</h5><p>  上文中，我们提到了进程的开始是由<code>fork()</code> 函数执行，在linux 0.11当中，fork() 功能在内核中的实现为 <code>sys_fork()</code>,该函数在文件 <code>kernel/system_call.s</code>当中的实现为:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys_fork:<br>call find_empty_process<br>!    ……<br>! 传递一些参数<br>push %gs<br>pushl %esi<br>pushl %edi<br>pushl %ebp<br>pushl %eax<br>! 调用 copy_process 实现进程创建<br>call copy_process <br>addl <span class="hljs-variable">$20</span>,%esp<br></code></pre></td></tr></table></figure><p>因此真正实现进程创建的函数<code>是copy_process()</code>，它在<code>kernel/fork.c</code>进行实现，我们需要在<code>fork.c</code>函数中仅从相应的日志输出。</p><p>在copy_process() 中完成了对应的进程创建和将进程送入就绪队列当中，因为我们仅需进行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep_on</span><span class="hljs-params">(struct task_struct **p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tmp</span>;</span><br><span class="hljs-comment">//    ……</span><br>    tmp = *p;<br><span class="hljs-comment">// 仔细阅读，实际上是将 current 插入“等待队列”头部，tmp 是原来的头部</span><br>    *p = current;  <br><span class="hljs-comment">// 切换到睡眠态</span><br>    current-&gt;state = TASK_UNINTERRUPTIBLE; <br><span class="hljs-comment">//  @yyf change</span><br>    <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;W&#x27;</span>, jiffies); <br><span class="hljs-comment">// 让出 CPU</span><br>    <span class="hljs-built_in">schedule</span>();  <br><span class="hljs-comment">// 唤醒队列中的上一个（tmp）睡眠进程。0 换作 TASK_RUNNING 更好</span><br><span class="hljs-comment">// 在记录进程被唤醒时一定要考虑到这种情况，实验者一定要注意!!!</span><br>    <span class="hljs-keyword">if</span> (tmp)&#123;<br>        tmp-&gt;state=<span class="hljs-number">0</span>;<br>     <span class="hljs-comment">//  @yyf change</span><br>     <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, tmp-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); &#125;<br>&#125;<br><span class="hljs-comment">/* TASK_UNINTERRUPTIBLE和TASK_INTERRUPTIBLE的区别在于不可中断的睡眠</span><br><span class="hljs-comment"> * 只能由wake_up()显式唤醒，再由上面的 schedule()语句后的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   if (tmp) tmp-&gt;state=0;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 依次唤醒，所以不可中断的睡眠进程一定是按严格从“队列”（一个依靠</span><br><span class="hljs-comment"> * 放在进程内核栈中的指针变量tmp维护的队列）的首部进行唤醒。而对于可</span><br><span class="hljs-comment"> * 中断的进程，除了用wake_up唤醒以外，也可以用信号（给进程发送一个信</span><br><span class="hljs-comment"> * 号，实际上就是将进程PCB中维护的一个向量的某一位置位，进程需要在合</span><br><span class="hljs-comment"> * 适的时候处理这一位。感兴趣的实验者可以阅读有关代码）来唤醒，如在</span><br><span class="hljs-comment"> * schedule()中：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="hljs-comment"> *      if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="hljs-comment"> *         (*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="hljs-comment"> *         (*p)-&gt;state=TASK_RUNNING;//唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 就是当进程是可中断睡眠时，如果遇到一些信号就将其唤醒。这样的唤醒会</span><br><span class="hljs-comment"> * 出现一个问题，那就是可能会唤醒等待队列中间的某个进程，此时这个链就</span><br><span class="hljs-comment"> * 需要进行适当调整。interruptible_sleep_on和sleep_on函数的主要区别就</span><br><span class="hljs-comment"> * 在这里。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptible_sleep_on</span><span class="hljs-params">(struct task_struct **p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tmp</span>;</span><br>       …<br>    tmp=*p;<br>    *p=current;<br>repeat:<br>    current-&gt;state = TASK_INTERRUPTIBLE;<br>    <span class="hljs-comment">//0号进程是守护进程，cpu空闲的时候一直在waiting，进程切换为W</span><br>    <span class="hljs-comment">//0号进程是wait状态，所以不用检查0h</span><br>    <span class="hljs-keyword">if</span>(current-&gt;pid != <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;W&#x27;</span>, jiffies); <br>    <span class="hljs-built_in">schedule</span>();<br>    <span class="hljs-comment">// 如果队列头进程和刚唤醒的进程 current 不是一个，</span><br>    <span class="hljs-comment">// 说明从队列中间唤醒了一个进程，需要处理</span><br>    <span class="hljs-keyword">if</span> (*p &amp;&amp; *p != current) &#123; <br>    <span class="hljs-comment">// 将队列头唤醒，并通过 goto repeat 让自己再去睡眠</span><br>        (**p).state=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//  @yyf change</span><br>        <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, (*p)-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); <br>        <span class="hljs-keyword">goto</span> repeat;<br>    &#125;<br>    *p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//作用和 sleep_on 函数中的一样</span><br>    <span class="hljs-keyword">if</span> (tmp)&#123;<br>        tmp-&gt;state=<span class="hljs-number">0</span>;<br>     <span class="hljs-comment">//进程转为就绪态</span><br>     <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, tmp-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_pause</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    current-&gt;state = TASK_INTERRUPTIBLE;<br>    <span class="hljs-comment">//进程转为等待状态</span><br>    <span class="hljs-keyword">if</span>(current-&gt;pid != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintk</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;W&#x27;</span>, jiffies);<br>    <span class="hljs-built_in">schedule</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//exit.c中</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_waitpid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> * stat_addr, <span class="hljs-keyword">int</span> options)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> flag, code;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span><br>    <span class="hljs-built_in">verify_area</span>(stat_addr,<span class="hljs-number">4</span>);<br>repeat:<br>    flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<br>        <span class="hljs-keyword">if</span> (!*p || *p == current)<br>            <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> ((*p)-&gt;father != current-&gt;pid)<br>   <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-keyword">if</span> ((*p)-&gt;pid != pid)<br>    <span class="hljs-keyword">continue</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pid) &#123;<br>   <span class="hljs-keyword">if</span> ((*p)-&gt;pgrp != current-&gt;pgrp)<br>    <span class="hljs-keyword">continue</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">-1</span>) &#123;<br>   <span class="hljs-keyword">if</span> ((*p)-&gt;pgrp != -pid)<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ((*p)-&gt;state) &#123;<br>   <span class="hljs-keyword">case</span> TASK_STOPPED:<br>    <span class="hljs-keyword">if</span> (!(options &amp; WUNTRACED))<br>     <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">put_fs_long</span>(<span class="hljs-number">0x7f</span>,stat_addr);<br>    <span class="hljs-keyword">return</span> (*p)-&gt;pid;<br>   <span class="hljs-keyword">case</span> TASK_ZOMBIE:<br>    current-&gt;cutime += (*p)-&gt;utime;<br>    current-&gt;cstime += (*p)-&gt;stime;<br>    flag = (*p)-&gt;pid;<br>    code = (*p)-&gt;exit_code;<br>    <span class="hljs-built_in">release</span>(*p);<br>    <span class="hljs-built_in">put_fs_long</span>(code,stat_addr);<br>    <span class="hljs-keyword">return</span> flag;<br>   <span class="hljs-keyword">default</span>:<br>    flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-keyword">if</span> (options &amp; WNOHANG)<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  current-&gt;state=TASK_INTERRUPTIBLE;<br>        <span class="hljs-comment">//  @yyf change</span><br>        <span class="hljs-comment">/*0号进程是守护进程，cpu空闲的时候一直在waiting，输出是不会进行检查的</span><br><span class="hljs-comment">        if(current-&gt;pid != 0)</span><br><span class="hljs-comment">         fprintk(3, &quot;%ld\t%c\t%ld\n&quot;, current-&gt;pid, &#x27;W&#x27;, jiffies); </span><br><span class="hljs-comment">  schedule();</span><br><span class="hljs-comment">  if (!(current-&gt;signal &amp;= ~(1&lt;&lt;(SIGCHLD-1))))</span><br><span class="hljs-comment">   goto repeat;</span><br><span class="hljs-comment">  else</span><br><span class="hljs-comment">   return -EINTR;</span><br><span class="hljs-comment"> &#125;</span><br><span class="hljs-comment"> return -ECHILD;</span><br><span class="hljs-comment">&#125;    </span><br></code></pre></td></tr></table></figure><h5 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h5><p>为所有处于TASK_RUNNING状态的进程分配CPU运行时间的管理代码。在 Linux 0.11 中采用了基于优先级排队的调度策略。</p><ul><li><p>TASK_RUNNING代表的状态不仅仅是运行状态，还有就绪状态。</p></li><li><p>算法实现的细节：</p><ul><li>基于优先级的排队策略。通过比较每个TASK_RUNNING任务的 运行时间 递减滴答计数 counter 的值来确定当前哪个进程运行的时间最少。 若counter=0，重新计算所有进程(包括睡眠)，<code>counter = counter / 2 + priority</code>。</li><li>根据上述原则选择出一个进程，最后调用 switch_to()执行实际的进程切换操作。</li></ul></li><li><code>schedule()</code> 找到的 <code>next</code> 进程是接下来要运行的进程。如果 <code>next</code> 恰好是当前正处于运行态的进程，<code>switch_to(next)</code> 也会被调用。这种情况下相当于当前进程的状态没有该表。如果不一样，则设置当前进程状态为就绪，将<code>next</code>进程状态设置为运行。</li></ul><p>具体内核代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span><br><span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)<br>  <span class="hljs-keyword">if</span> (*p) &#123;<br>    <span class="hljs-keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;<br>        (*p)-&gt;signal |= (<span class="hljs-number">1</span>&lt;&lt;(SIGALRM<span class="hljs-number">-1</span>));<br>        (*p)-&gt;alarm = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;<br>        (*p)-&gt;state==TASK_INTERRUPTIBLE)&#123;<br>        (*p)-&gt;state=TASK_RUNNING;<br>        fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, (*p)-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); <br>    &#125; <br>  &#125;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    c = <span class="hljs-number">-1</span>; next = <span class="hljs-number">0</span>; i = NR_TASKS; p = &amp;task[NR_TASKS];<br><br>    <span class="hljs-comment">// 找到 counter 值最大的就绪态进程</span><br>    <span class="hljs-keyword">while</span> (--i) &#123;<br>        <span class="hljs-keyword">if</span> (!*--p)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)<br>            c = (*p)-&gt;counter, next = i;<br>    &#125;       <br><br>    <span class="hljs-comment">//如果有 counter 值大于 0 的就绪态进程，则退出</span><br>    <span class="hljs-keyword">if</span> (c) <span class="hljs-keyword">break</span>;  <br><br>    <span class="hljs-comment">//如果没有：</span><br>    <span class="hljs-comment">//所有进程的 counter 值除以 2 衰减后再和 priority 值相加，</span><br>    <span class="hljs-comment">//产生新的时间片</span><br>    <span class="hljs-keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)<br>        <span class="hljs-keyword">if</span> (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="hljs-number">1</span>) + (*p)-&gt;priority;  <br>    &#125;<br>    <span class="hljs-comment">//切换到相同的进程不输出</span><br>    <span class="hljs-keyword">if</span>(current != task[next])&#123;<br>        <span class="hljs-keyword">if</span>(current-&gt;state == TASK_RUNNING)&#123;<br>            fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); <br>        &#125;<br>        fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, task[next]-&gt;pid, <span class="hljs-string">&#x27;R&#x27;</span>, jiffies); <br>    &#125;<br>    <span class="hljs-comment">//切换到 next 进程</span><br>    switch_to(next);  <br></code></pre></td></tr></table></figure><h4 id="睡眠状态到就绪状态"><a href="#睡眠状态到就绪状态" class="headerlink" title="睡眠状态到就绪状态"></a>睡眠状态到就绪状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wake_up</span><span class="hljs-params">(struct task_struct **p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (p &amp;&amp; *p) &#123;<br>        <span class="hljs-keyword">if</span>((**p).state != TASK_RUNNING)&#123;  <br>            (**p).state=TASK_RUNNING;<br>            <span class="hljs-comment">// 切换状态为就绪状态,J代表就绪状态</span><br>            fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, (*p)-&gt;pid, <span class="hljs-string">&#x27;J&#x27;</span>, jiffies); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h4><p>当一个进程结束了运行或在半途中终止了运行，那么内核就需要释放该进程所占用的系统资源。这包括进程运行时打开的文件、申请的内存等。</p><p>当一个用户程序调用exit()系统调用时，就会执行内核函数do_exit()。该函数会首先释放进程代码段和数据段占用的内存页面，关闭进程打开着的所有文件，对进程使用的当前工作目录、根目录和运行程序的节点进行同步操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//改动exit.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_exit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> code)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    free_page_tables(get_base(current-&gt;ldt[<span class="hljs-number">1</span>]),get_limit(<span class="hljs-number">0x0f</span>));<br>    free_page_tables(get_base(current-&gt;ldt[<span class="hljs-number">2</span>]),get_limit(<span class="hljs-number">0x17</span>));<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_TASKS ; i++)<br>        <span class="hljs-keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;<br>            task[i]-&gt;father = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)<br>                <span class="hljs-comment">/* assumption task[1] is always init */</span><br>                (<span class="hljs-keyword">void</span>) send_sig(SIGCHLD, task[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>        &#125;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;NR_OPEN ; i++)<br>        <span class="hljs-keyword">if</span> (current-&gt;filp[i])<br>            sys_close(i);<br>    iput(current-&gt;pwd);<br>    current-&gt;pwd=<span class="hljs-literal">NULL</span>;<br>    iput(current-&gt;root);<br>    current-&gt;root=<span class="hljs-literal">NULL</span>;<br>    iput(current-&gt;executable);<br>    current-&gt;executable=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="hljs-number">0</span>)<br>        tty_table[current-&gt;tty].pgrp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (last_task_used_math == current)<br>        last_task_used_math = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (current-&gt;leader)<br>        kill_session();<br>    current-&gt;state = TASK_ZOMBIE;<br>    <span class="hljs-comment">//进程退出，E代表退出状态</span><br>    fprintk(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;%ld\t%c\t%ld\n&quot;</span>, current-&gt;pid, <span class="hljs-string">&#x27;E&#x27;</span>, jiffies); <br>    current-&gt;exit_code = code;<br>    tell_father(current-&gt;father);<br>    schedule();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<span class="hljs-comment">/* just to suppress warnings */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error_code)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> do_exit((error_code&amp;<span class="hljs-number">0xff</span>)&lt;&lt;<span class="hljs-number">8</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h5><p>Linux 0.11 支持四种进程状态的转移：就绪到运行、运行到就绪、运行到睡眠和睡眠到就绪，此外还有新建和退出两种情况。其中就绪与运行间的状态转移是通过 schedule()（它亦是调度算法所在）完成的；运行到睡眠依靠的是 sleep_on() 和 interruptible_sleep_on()，还有进程主动睡觉的系统调用 sys_pause() 和 sys_waitpid()；睡眠到就绪的转移依靠的是 wake_up()。</p><p>此处应有截图</p><h4 id="调度算法的修改和时间的统计"><a href="#调度算法的修改和时间的统计" class="headerlink" title="调度算法的修改和时间的统计"></a>调度算法的修改和时间的统计</h4><p>调度算法主要完成的步骤在于修改算法的时间片大小，并且验证。</p><p>依次将时间偏设为1，5，10，15，20，25，50，100，150后，经统计分析log文件可以发现：<br>1）在一定的范围内，平均等待时间，平均完成时间的变化随着时间片的增大而减小。这是因为在时间片小的情况下，cpu将时间耗费在调度切换上，所以平均等待时间增加。<br>2）超过一定的范围之后，这些参数将不再有明显的变化，这是因为在这种情况下，RR轮转调度就变成了FCFS先来先服务了。随着时间片的修改，吞吐量始终没有明显的变化，这是因为在单位时间内，系统所能完成的进程数量是不会变的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置局域网的sock5代理</title>
    <link href="/2022/02/05/linux%E7%9B%B8%E5%85%B3/%E9%85%8D%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84sock5%E4%BB%A3%E7%90%86/"/>
    <url>/2022/02/05/linux%E7%9B%B8%E5%85%B3/%E9%85%8D%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84sock5%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>之前一直不太明白sock5和http代理这些有什么区别，然后就一骨碌全部配置了，出错了再找，没错就不改了。</p><p>然后今天上网找了一下，发现sock5其实是在会话层，然后http是在应用层，所以我们干脆一步到位，直接修改了会话层的代理，这样子我们就可以不用再去修改http的代理。</p><h2 id="如何在命令行修改gnome的配置"><a href="#如何在命令行修改gnome的配置" class="headerlink" title="如何在命令行修改gnome的配置"></a>如何在命令行修改gnome的配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks port 10808 <br></code></pre></td></tr></table></figure><p>上面这部分代码就是修改了如下图所示的socks5的代理端口</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16440112025381644011201674.png" alt="代理修改图片"></p><p>同理，如果我们要修改对应的ip地址，我们可以仿造出如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks host 192.168.220.191<br></code></pre></td></tr></table></figure><h2 id="如果每次自动设置好这个sock5主机的代理地址"><a href="#如果每次自动设置好这个sock5主机的代理地址" class="headerlink" title="如果每次自动设置好这个sock5主机的代理地址"></a>如果每次自动设置好这个sock5主机的代理地址</h2><p>因为我是通过手机打开热点，然后手机的v2ray允许进行局域网内部的代理，别问我为什么不用电脑的直接进行代理，因为我电脑的代理节点，需要证书，但是那个节点没有证书，所以没办法使用，然后就想了这个奇怪的办法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/resolv.conf|grep nameserver -m 1|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>该指令可以获取到我们手机热点的ip地址，也就是手机的ip地址。</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16440116045391644011603904.png" alt="ip地址"></p><h2 id="通过-bashrc设置，如果是zsh的话，就在-zshrc进行设置"><a href="#通过-bashrc设置，如果是zsh的话，就在-zshrc进行设置" class="headerlink" title="通过.bashrc设置，如果是zsh的话，就在.zshrc进行设置"></a>通过.bashrc设置，如果是zsh的话，就在.zshrc进行设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> windows_host=`cat /etc/resolv.conf|grep nameserver -m 1|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br><span class="hljs-built_in">export</span> ALL_PROXY=http://<span class="hljs-variable">$windows_host</span>:10809<br><span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-variable">$ALL_PROXY</span><br><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-variable">$ALL_PROXY</span><br><span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-variable">$ALL_PROXY</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-variable">$ALL_PROXY</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;`git config --global --get proxy.https`&quot;</span> != <span class="hljs-string">&quot;http://<span class="hljs-variable">$windows_host</span>:10809&quot;</span> ]; <span class="hljs-keyword">then</span><br>            git config --global proxy.https http://<span class="hljs-variable">$windows_host</span>:10809<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>这边的代码添加到.bashrc,这样子每次启动终端的时候就会给对终端进行一次手机热点的扫描，然后定位到对应的窗口。</p><h2 id="自动填写系统设置，保证浏览器的上网"><a href="#自动填写系统设置，保证浏览器的上网" class="headerlink" title="自动填写系统设置，保证浏览器的上网"></a>自动填写系统设置，保证浏览器的上网</h2><p>在.bashrc的结尾添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks host <span class="hljs-variable">$windows_host</span><br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks port 10808<br></code></pre></td></tr></table></figure><p>这样子，你每次打开终端，就会帮你完成sock5的设置，完美。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的后缀遍历</title>
    <link href="/2022/01/24/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BC%80%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <url>/2022/01/24/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BC%80%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-节点之和的最大路径"><a href="#1-节点之和的最大路径" class="headerlink" title="1. 节点之和的最大路径"></a>1. 节点之和的最大路径</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430102338781643010233861.png" alt="节点之和的最大路径"></p><p>题解：题目的意思可以转变成为左子树和右边子树的最大路径和。如果路径和为0,我们是不要该路径和的，因此我们在遍历返回结果的时候进行判断，如果是负数，直接进行舍弃。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret =Integer.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//注重理解这里的意思</span><br>        <span class="hljs-keyword">int</span> left =Math.max(<span class="hljs-number">0</span>,dfs(root.left));<br>        <span class="hljs-keyword">int</span> right =Math.max(<span class="hljs-number">0</span>,dfs(root.right));<br>        ret =Math.max(ret,left+right+root.val);<br>        <span class="hljs-keyword">return</span> root.val+Math.max(left,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-二叉树的直径"><a href="#2-二叉树的直径" class="headerlink" title="2. 二叉树的直径"></a>2. 二叉树的直径</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430109370531643010937047.png" alt="二叉树的直径"></p><p>题解：题目转化为求二叉树的左右子树之和的最大值</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret =Integer.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = dfs(root.left);<br>        <span class="hljs-keyword">int</span> right =dfs(root.right);<br>        ret =Math.max(ret,left+right+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(left,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-最长同值路径"><a href="#3-最长同值路径" class="headerlink" title="3. 最长同值路径"></a>3. 最长同值路径</h2><p>题目： <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430109719741643010971968.png" alt="最长同值路径"></p><p>题解：同样的后缀遍历，加入一些条件判断</p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret =Integer.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l=dfs(root.left);<br>        <span class="hljs-keyword">int</span> r =dfs(root.right);<br>        <span class="hljs-keyword">int</span> left =root.left!=<span class="hljs-keyword">null</span>?root.val==root.left.val?l:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =root.right!=<span class="hljs-keyword">null</span>?root.val==root.right.val?r:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// System.out.println(left+&quot;   &quot;+right);</span><br>        ret=Math.max(ret,<span class="hljs-number">1</span>+left+right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(left,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>题解:注重切割的过程，右边先走，然后左边再走，注意想下为什么</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">//分割</span><br>            <span class="hljs-keyword">int</span> pivot= partition(arr,left,right);<br>            quickSort(arr,left,pivot-<span class="hljs-number">1</span>);<br>            quickSort(arr,pivot+<span class="hljs-number">1</span>,right);<br>        &#125;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> head = arr[left];<br>        <span class="hljs-keyword">int</span> l=left;<br>        <span class="hljs-keyword">int</span> r= right;<br>        <br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=head) r--;<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=head) l++;<br>            <br>            <span class="hljs-keyword">int</span> tmp = arr[r];<br>            arr[r]=arr[l];<br>            arr[l]=tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> tmp = arr[r];<br>        arr[r]=arr[left];<br>        arr[left]=tmp;<br>        <br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卷积</title>
    <link href="/2022/01/22/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%8D%B7%E7%A7%AF/"/>
    <url>/2022/01/22/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%8D%B7%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>过了好久好久，至今也还不太明白卷积的意思。</p><script type="math/tex; mode=display">f(t)*g(t)=\int_{ -\infty}^{+\infty}{f(m)g(t-m)\mathrm{d}m}</script><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428527312121642852731178.png" alt="每一个的高度是这样子"></p><p>然后对┏进行积分就i可以得到。</p><p>卷积讨论的是，一个input function，例如我有一堆蜡烛，沿着时间线，我会在某个时间点一根蜡烛，f(t)代表我在t时刻点燃的蜡烛的高度，f(t)越大，则代表我点燃的蜡烛越长，然后对应的output function展示的是蜡烛的燃烧过程中质量的变化情况，可以得到大致如下的图：</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428530574001642853057338.png" alt="蜡烛燃烧过程的变化"></p><p>然后卷积的含义是，我想知道在某个时间t，我点燃过的蜡烛剩下的总质量。</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428531777971642853177743.png" alt="某个时间已经点燃的蜡烛剩余的总质量"></p><p>现在我要求的就是所有这些横截面矩形的面积。</p><p>每个横截面的矩形的还剩下的蜡烛高度为：<br>假设是在t时间的前m个时间点燃的，那么它一开始的高度就是f(t-m)，也就是说在t-m的时间它的高度是f(t-m)，然后对应的在t时间的高度是f(t-m) mult g(m)，g(m)代表了从t-m到t一共经历了m的时间，所以衰减的程度为g(m)，即g(m)代表的是m时间衰减的比率，g(m) mult f(t-m)就可以得到前m时间点燃的蜡烛在t时间剩余的长度是多少。</p>]]></content>
    
    
    <categories>
      
      <category>好玩的数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归与回溯</title>
    <link href="/2022/01/22/leetcode/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/01/22/leetcode/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428382117721642838211753.png" alt="电话号码的字母组合"></p><p>题解:正常回溯</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(digits.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">char</span>[] str = digits.toCharArray();<br>        Map&lt;Integer,<span class="hljs-keyword">char</span>[]&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-number">2</span>,(<span class="hljs-string">&quot;abc&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">3</span>,(<span class="hljs-string">&quot;def&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">4</span>,(<span class="hljs-string">&quot;ghi&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">5</span>,(<span class="hljs-string">&quot;jkl&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">6</span>,(<span class="hljs-string">&quot;mno&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">7</span>,(<span class="hljs-string">&quot;pqrs&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">8</span>,(<span class="hljs-string">&quot;tuv&quot;</span>).toCharArray());<br>        map.put(<span class="hljs-number">9</span>,(<span class="hljs-string">&quot;wxyz&quot;</span>).toCharArray());<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(ans,<span class="hljs-number">0</span>,str,sb,map);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;String&gt; ans,<span class="hljs-keyword">int</span> number,<span class="hljs-keyword">char</span>[] str,StringBuilder sb,Map&lt;Integer,<span class="hljs-keyword">char</span>[]&gt; map)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(number==str.length)<br>        &#123;<br>            String tmp = sb.toString();<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] arr = map.get(str[number]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">int</span> len = arr.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            dfs(ans,number+<span class="hljs-number">1</span>,str,sb.append(arr[i]),map);<br>            sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/01/10/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/01/10/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>每日一问：如何写出高质量的代码</p><p>滑动窗口伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化慢指针 = <span class="hljs-number">0</span><br>初始化 ans<br><br><span class="hljs-keyword">for</span> 快指针 in 可迭代集合<br>    更新窗口内信息<br>    <span class="hljs-keyword">while</span> 窗口内不符合题意<br>        扩展或者收缩窗口<br>        慢指针移动<br>    更新答案<br>返回 ans<br></code></pre></td></tr></table></figure><h2 id="1-乘积小于-K-的子数组"><a href="#1-乘积小于-K-的子数组" class="headerlink" title="1.  乘积小于 K 的子数组"></a>1.  乘积小于 K 的子数组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418158187251641815818717.png" alt="乘积小于K的子数组"></p><p>题解：套用模板：更新窗口信息，更新当前的值<code>pro</code>,移动窗口<code>left&lt;=right</code>,<code>left</code>得一直往前多走一步</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用一个数组进行保存</span><br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> pro=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;nums.length)<br>        &#123;<br>            <span class="hljs-comment">//进行窗口更新</span><br>            pro*=nums[right];<br>            <span class="hljs-comment">//进行左窗口的更新</span><br>            <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;pro&gt;=k) <br>            &#123;<br>                pro/=nums[left];<br>                left++;<br>            &#125;<br>            ans+=right&gt;=left?right-left+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-和大于等于target的最短子数组"><a href="#2-和大于等于target的最短子数组" class="headerlink" title="2. 和大于等于target的最短子数组"></a>2. 和大于等于target的最短子数组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418230982031641823098191.png" alt="和大于等于target的最短子数组"></p><p>题解：</p><ol><li>滑动窗口O(n)的时间复杂度</li></ol><p>滑动窗口继续套模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化慢指针 = <span class="hljs-number">0</span><br>初始化 ans<br><br><span class="hljs-keyword">for</span> 快指针 in 可迭代集合<br>    更新窗口内信息<br>    <span class="hljs-keyword">while</span> 窗口内不符合题意<br>        扩展或者收缩窗口<br>        慢指针移动<br>    更新答案<br></code></pre></td></tr></table></figure><p>滑动窗口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans =Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;right&lt;nums.length;right++)<br>        &#123;<br>            <span class="hljs-comment">//更新窗口的值</span><br>            sum+=nums[right];<br>            <span class="hljs-comment">//收缩窗口</span><br>            <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;sum&gt;=target)<br>            &#123;<br>                ans =Math.min(ans,right-left+<span class="hljs-number">1</span>);<br>                sum-=nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer第二版</title>
    <link href="/2022/01/08/leetcode/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
    <url>/2022/01/08/leetcode/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-字符串两数相加"><a href="#1-字符串两数相加" class="headerlink" title="1. 字符串两数相加"></a>1. 字符串两数相加</h2><p>题目：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16416510380951641651038087.png" alt="两数相加"></p><p>题解：正常的模拟操作，先对齐，然后从最后一位开始模拟</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBinary</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] str1 = a.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str2 = b.toCharArray();<br>        <span class="hljs-keyword">int</span> len = Math.max(str1.length,str2.length);<br>        <span class="hljs-keyword">boolean</span>[] aBits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        <span class="hljs-keyword">boolean</span>[] bBits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =str1.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            aBits[len-count-<span class="hljs-number">1</span>]=((str1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)==<span class="hljs-number">1</span>);<br>            count++;<br>        &#125;<br>        count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =str2.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            bBits[len-<span class="hljs-number">1</span>-count]=((str2[i]-<span class="hljs-string">&#x27;0&#x27;</span>)==<span class="hljs-number">1</span>);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span>[] ans1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">boolean</span>[] ans2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len+<span class="hljs-number">1</span>];<br>        Stack&lt;Boolean&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =len-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-keyword">false</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(aBits[i]&amp;&amp;bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//11的情况,推进去0，进位为1</span><br>                    stack.push(<span class="hljs-keyword">false</span>);<br>                    flag=<span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!aBits[i]&amp;&amp;bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//01</span><br>                    stack.push(<span class="hljs-keyword">true</span>);<br>                    flag=<span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(aBits[i]&amp;&amp;!bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//10</span><br>                    stack.push(<span class="hljs-keyword">true</span>);<br>                    flag=<span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//00</span><br>                    stack.push(<span class="hljs-keyword">false</span>);<br>                    flag=<span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-keyword">true</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(aBits[i]&amp;&amp;bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//11   1的情况,推进去1，进位为1</span><br>                    stack.push(<span class="hljs-keyword">true</span>);<br>                    flag=<span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!aBits[i]&amp;&amp;bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//01 1</span><br>                    stack.push(<span class="hljs-keyword">false</span>);<br>                    flag=<span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(aBits[i]&amp;&amp;!bBits[i])<br>                &#123;<br>                    <span class="hljs-comment">//10 1</span><br>                    stack.push(<span class="hljs-keyword">false</span>);<br>                    flag=<span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//00 1</span><br>                    stack.push(<span class="hljs-keyword">true</span>);<br>                    flag=<span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-keyword">true</span>) stack.push(<span class="hljs-keyword">true</span>);<br>        StringBuilder sb= <span class="hljs-keyword">new</span> StringBuilder();<br><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(stack.pop())<br>            &#123;<br>                sb.append(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sb.append(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-前-n-个数字二进制中-1-的个数"><a href="#2-前-n-个数字二进制中-1-的个数" class="headerlink" title="2. 前 n 个数字二进制中 1 的个数"></a>2. 前 n 个数字二进制中 1 的个数</h2><p>题目：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16416511971201641651197111.png" alt="前n个数字二进制1的个数"></p><p>题解：emm我直接遍历每一个数字，哈哈哈，so easy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">32</span>;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>                &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            ans[k]=count;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-只出现一次的数字"><a href="#3-只出现一次的数字" class="headerlink" title="3. 只出现一次的数字"></a>3. 只出现一次的数字</h2><p>题解：把每一位出现的次数进行统计，如果出现次数不是3的倍数，结果就应该赋值为1</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16417132890961641713289087.png" alt="只出现一次的数字"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//将所有的数进行与运算</span><br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">32</span>;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(((nums[i]&gt;&gt;j)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>                &#123;<br>                    count[<span class="hljs-number">31</span>-j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-comment">//所有的位数，如果不是3的倍数的话，则代表其中一个出现了单独一位的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;count.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(count[i]%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>)<br>            &#123;<br>                ans[i]=<span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//还原出原本的数字</span><br>        <span class="hljs-keyword">int</span> ret=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;ans.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-keyword">true</span>)<br>            &#123;<br>                ret=ret*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ret=ret*<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-单词长度的最大乘积"><a href="#4-单词长度的最大乘积" class="headerlink" title="4. 单词长度的最大乘积"></a>4. 单词长度的最大乘积</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16417136264591641713626448.png" alt="单词长度最大的乘积"></p><p>题解：使用一个两层的for循环，这是没办法避免的，然后主要的优化问题在如果加快两个字符串的匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(String[] words)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//乘积最大</span><br>        <span class="hljs-comment">//面积最大</span><br>        <span class="hljs-comment">//最大的相同的两个数</span><br>        <span class="hljs-comment">//不包含相同字符</span><br>        <span class="hljs-comment">//判断两个字符串是都包含相同的字符</span><br>        <span class="hljs-comment">//包含小写字母，用每一位代表每个字母是否出现，32位</span><br>        <span class="hljs-comment">//然后进行与运算</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;words.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =i+<span class="hljs-number">1</span>;j&lt;words.length;j++)<br>            &#123;<br>                <span class="hljs-comment">//然后进行判断两个字符串</span><br>                <span class="hljs-keyword">char</span>[] str1 = words[i].toCharArray();<br>                <span class="hljs-keyword">char</span>[] str2 = words[j].toCharArray();<br>                <span class="hljs-keyword">boolean</span> flag =<span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">boolean</span>[] flags = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;str1.length;k++)<br>                &#123;<br>                    flags[str1[k]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;str2.length;l++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flags[str2[l]-<span class="hljs-string">&#x27;a&#x27;</span>])<br>                    &#123;<br>                        flag=<span class="hljs-keyword">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag==<span class="hljs-keyword">false</span>)<br>                &#123;<br>                    ans=Math.max(str1.length*str2.length,ans);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-两数之和-特别简单"><a href="#5-两数之和-特别简单" class="headerlink" title="5. 两数之和 特别简单"></a>5. 两数之和 特别简单</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16417137553781641713755370.png" alt="两数之和"></p><p>题解：双指针遍历，完事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">//双指针进行解决</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = numbers.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(numbers[left]+numbers[right]==target)<br>            &#123;<br>                ans[<span class="hljs-number">0</span>]=left;<br>                ans[<span class="hljs-number">1</span>]=right;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[left]+numbers[right]&gt;target)<br>            &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[left]+numbers[right]&lt;target)<br>            &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">1</span>]=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6. 三数之和"></a>6. 三数之和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418176077451641817607735.png" alt="三数之和"></p><p>题解：先排序，好使用双指针。然后对数组的每一个数，从下一个元素开始，进行区间的双指针寻找，去重的话，采用的方法是排序，然后判断前一个和后一个元素是否相同，相同的需要跳过进行处理。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-comment">// System.out.println(ans);</span><br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            left = i+<span class="hljs-number">1</span>;<br>            right= nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right&lt;nums.length-<span class="hljs-number">1</span>&amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>])<br>                &#123;<br>                    right--;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(left&gt;i+<span class="hljs-number">1</span>&amp;&amp;nums[left]==nums[left-<span class="hljs-number">1</span>])<br>                &#123;<br>                    left++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// System.out.println(&quot;left: &quot;+left+&quot;==right:&quot;+right);</span><br>                ret = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                <span class="hljs-keyword">if</span>(nums[left]+nums[right]==-nums[i])<br>                &#123;<br>                    ret.add(nums[i]);<br>                    ret.add(nums[left]);<br>                    ret.add(nums[right]);<br>                    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(ret);<br>                    ans.add(tmp);<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left]+nums[right]&lt;-nums[i])<br>                &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left]+nums[right]&gt;-nums[i])<br>                &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-和大于等于target的最短子数组"><a href="#7-和大于等于target的最短子数组" class="headerlink" title="7. 和大于等于target的最短子数组"></a>7. 和大于等于target的最短子数组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418230982031641823098191.png" alt="和大于等于target的最短子数组"></p><p>题解：</p><ol><li>滑动窗口O(n)的时间复杂度</li><li>二分查找，O(nlog(n))的复杂度</li></ol><p>滑动窗口继续套模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化慢指针 = <span class="hljs-number">0</span><br>初始化 ans<br><br><span class="hljs-keyword">for</span> 快指针 in 可迭代集合<br>    更新窗口内信息<br>    <span class="hljs-keyword">while</span> 窗口内不符合题意<br>        扩展或者收缩窗口<br>        慢指针移动<br>    更新答案<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length+<span class="hljs-number">1</span>];<br>        preSum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            preSum[i+<span class="hljs-number">1</span>]=preSum[i]+nums[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> left =i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> right = preSum.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> mid;<br>            <span class="hljs-keyword">while</span>(left&lt;=right)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right==left)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(preSum[right]-preSum[i]&gt;=target)<br>                    &#123;<br>                        ans =Math.min(ans,left-i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(preSum[left]-preSum[i]&gt;=target)<br>                    &#123;<br>                        ans =Math.min(ans,left-i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(preSum[right]-preSum[i]&gt;=target)<br>                    &#123;<br>                        ans =Math.min(ans,right-i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                mid = (right+<span class="hljs-number">1</span>+left)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(preSum[mid]-preSum[i]==target)<br>                &#123;<br>                    ans=Math.min(ans,mid-i);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preSum[mid]-preSum[i]&gt;target)<br>                &#123;<br>                    right=mid;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(preSum[mid]-preSum[i]&lt;target)<br>                &#123;<br>                    left=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans==Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动窗口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans =Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;right&lt;nums.length;right++)<br>        &#123;<br>            <span class="hljs-comment">//更新窗口的值</span><br>            sum+=nums[right];<br>            <span class="hljs-comment">//收缩窗口</span><br>            <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;sum&gt;=target)<br>            &#123;<br>                ans =Math.min(ans,right-left+<span class="hljs-number">1</span>);<br>                sum-=nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==Integer.MAX_VALUE?<span class="hljs-number">0</span>:ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-左右两边子数组的和相等"><a href="#8-左右两边子数组的和相等" class="headerlink" title="8. 左右两边子数组的和相等"></a>8. 左右两边子数组的和相等</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418703703721641870370364.png" alt="左右两边子数组的和相等"></p><p>题解：这种求两边的和相等的话，基本是先求出总的和，然后找出一半的元素相等，这样子会特别方便进行处理。另一道题目是，挑出两个子序列，然后这两个子序列的和是相等的，也是先求出整个数组的和，然后取一半进行比较</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//求出总的和</span><br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum-nums[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//前缀和不是递增的，没办法</span><br>        <span class="hljs-keyword">int</span> ret = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">float</span> ans =<span class="hljs-number">0.0f</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            ans+=nums[i];<br>            <span class="hljs-keyword">if</span>(ans==(sum-nums[i+<span class="hljs-number">1</span>])/<span class="hljs-number">2.0f</span>)<br>            &#123;<br>                ret=i+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-0和1个数相同的子数组"><a href="#9-0和1个数相同的子数组" class="headerlink" title="9. 0和1个数相同的子数组"></a>9. 0和1个数相同的子数组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418836845761641883684569.png" alt="0和1个数相同的子数组"></p><p>题解：这边使用hash表来进行时间复杂度的优化，如何优化是这题的难点,不难想到使用前缀和，然后进行两重的for循环进行判断处理。对于前缀和，有<code>2*(preSum[j]-preSum[i])==(j-i)</code>，然后hash表优化就是先将i相关的变量进行保存，因此上面的式子可以转变成为<code>2*preSum[j]-j==2*preSum[i]-i</code>,因此我们需要在hash表保存的便是<code>2*preSum[i]-i</code>,然后我们要保存这个值出现的地方是在什么位置所以hash表的KV为:<code>&lt;value,location&gt;</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> preSum= <span class="hljs-number">0</span>;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            preSum=preSum+nums[i];<br>            <span class="hljs-keyword">int</span> tmp=-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>((tmp=map.getOrDefault(<span class="hljs-number">2</span>*preSum-i-<span class="hljs-number">1</span>,Integer.MAX_VALUE))!=Integer.MAX_VALUE)<br>            &#123;<br>                ans=Math.max(i+<span class="hljs-number">1</span>-tmp,ans);<br>            &#125;<br>            map.put(<span class="hljs-number">2</span>*preSum-i-<span class="hljs-number">1</span>,Math.min(tmp,i+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-二维子矩阵的和"><a href="#10-二维子矩阵的和" class="headerlink" title="10. 二维子矩阵的和"></a>10. 二维子矩阵的和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418841312691641884131260.png" alt="二维子矩阵的和"></p><p>题解：思路不难，难的是怎么去理解preSum代表的意义，我们处理的话，记得看图对应相应的下标。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] preTwoSum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        preTwoSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length+<span class="hljs-number">1</span>][matrix[<span class="hljs-number">0</span>].length+<span class="hljs-number">1</span>];  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;matrix.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)<br>            &#123;<br>                preTwoSum[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=preTwoSum[i+<span class="hljs-number">1</span>][j]+preTwoSum[i][j+<span class="hljs-number">1</span>]-preTwoSum[i][j]+matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> preTwoSum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-preTwoSum[row1][col2+<span class="hljs-number">1</span>]-preTwoSum[row2+<span class="hljs-number">1</span>][col1]+preTwoSum[row1][col1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-和为k的子数组"><a href="#11-和为k的子数组" class="headerlink" title="11. 和为k的子数组"></a>11. 和为k的子数组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16418843672561641884367251.png" alt="和为k的子数组"></p><p>题解：如果没有负数，可以直接用滑动窗口，这边正常的思路是前缀和，然后使用两层for循环,<code>sum[j]-sum[i]==k</code>,和第10题相似的思路，我们可以直接将式子转变为<code>sum[j]-k==sum[i]</code>，因为这边要的是次数，所以对于hash表的第二个值应该为<code>value</code>,代表这个值出现了几次。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//滑动窗口</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> preSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//hash表，走过的值进行保留</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            preSum+=nums[i];<br>            ans+=map.getOrDefault(preSum-k,<span class="hljs-number">0</span>);<br>            map.put(preSum,map.getOrDefault(preSum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-字符串中的变位词"><a href="#12-字符串中的变位词" class="headerlink" title="12. 字符串中的变位词"></a>12. 字符串中的变位词</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420789053441642078905337.png" alt="字符串中的变位词"></p><p>题解：固定的滑动窗口，不需要收缩窗口，每次比较两个数组是否相等即可。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.length()&gt;s2.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] str1 = s2.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str2 = s1.toCharArray();<br>        <span class="hljs-keyword">int</span>[] count1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span>[] count2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;str2.length;i++)<br>        &#123;<br>            count1[str1[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            count2[str2[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(count1,count2)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = str2.length;<br>        <span class="hljs-keyword">for</span>(;right&lt;str1.length;right++)<br>        &#123;<br>            count1[str1[right]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            count1[str1[left]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            left++;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(count1,count2)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-字符串中的所有变位词"><a href="#13-字符串中的所有变位词" class="headerlink" title="13. 字符串中的所有变位词"></a>13. 字符串中的所有变位词</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420789651181642078965108.png" alt="字符串中所有的变位词"></p><p>题解：和上一题一样，只是我们这次需要保存对应的索引。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span>(s.length()&lt;p.length()) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] ptr = p.toCharArray();<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span>[] scount = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;ptr.length;i++)<br>        &#123;<br>            count[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            scount[ptr[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(count,scount)) ans.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//the stable arrange</span><br>        <span class="hljs-keyword">int</span> right= ptr.length;<br>        <span class="hljs-keyword">for</span>(;right&lt;str.length;right++)<br>        &#123;<br>            <span class="hljs-comment">//update the messages of the windows</span><br>            count[str[right]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            count[str[left]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            left++;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(count,scount)) ans.add(left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-不含重复字符的最长子字符串"><a href="#13-不含重复字符的最长子字符串" class="headerlink" title="13. 不含重复字符的最长子字符串"></a>13. 不含重复字符的最长子字符串</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420789969121642078996909.png" alt="不含重复字符的最长子字符串"></p><p>题解：固定滑动窗口套路，每次更新窗口，收缩左窗口，更新答案。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(;right&lt;str.length;right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!set.contains(str[right])) set.add(str[right]);          <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//update the message of the windows</span><br>                <span class="hljs-keyword">while</span>(set.contains(str[right]))<br>                &#123;<br>                    set.remove(str[left]);<br>                    left++;<br>                &#125;<br>                set.add(str[right]);<br>            &#125;<br><br>            ans =Math.max(ans,right+<span class="hljs-number">1</span>-left);<br>            <span class="hljs-comment">//shrank the windows</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-含有所有字符的最短字符串"><a href="#14-含有所有字符的最短字符串" class="headerlink" title="14. 含有所有字符的最短字符串"></a>14. 含有所有字符的最短字符串</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420790373181642079037314.png" alt="含有所有字符的最短字符串"></p><p>题解：滑动窗口，更新窗口没变，注重如何收缩左窗口</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; hs,ht;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:t) ht[c]++;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        string ans;<br>        <span class="hljs-keyword">for</span>(;right&lt;s.<span class="hljs-built_in">size</span>();right++)<br>        &#123;<br>            hs[s[right]]++;<br>            <span class="hljs-keyword">if</span>(hs[s[right]]&lt;=ht[s[right]]) count++;<br><br>            <span class="hljs-keyword">while</span>(hs[s[left]]&gt;ht[s[left]])<br>            &#123;<br>                hs[s[left]]--;<br>                left++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(count==t.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()||right+<span class="hljs-number">1</span>-left&lt;ans.<span class="hljs-built_in">size</span>()) ans=s.<span class="hljs-built_in">substr</span>(left,right+<span class="hljs-number">1</span>-left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-有效的回文"><a href="#15-有效的回文" class="headerlink" title="15. 有效的回文"></a>15. 有效的回文</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420790860601642079086056.png" alt="有效的回文"></p><p>题解：双指针正常判断</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">char</span>[] str= s.toCharArray();<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =  str.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">//右边先走</span><br>            <span class="hljs-keyword">while</span>(right&gt;=<span class="hljs-number">0</span>&amp;&amp;!Character.isLetterOrDigit(str[right]))<br>            &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//左边也走</span><br>            <span class="hljs-keyword">while</span>(left&lt;=(str.length-<span class="hljs-number">1</span>)&amp;&amp;(!Character.isLetterOrDigit(str[left])))<br>            &#123;<br>                <span class="hljs-comment">// System.out.println(left);</span><br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&gt;=str.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span>(str[left]==str[right])<br>            &#123;<br>                <span class="hljs-comment">// System.out.println(left);</span><br>                left++;<br>                right--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Character.isDigit(str[left])||Character.isDigit(str[right]))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[left]+<span class="hljs-number">32</span>==str[right]||str[left]-<span class="hljs-number">32</span>==str[right])<br>            &#123;<br>                left++;<br>                right--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-最多删除一个字符得到回文"><a href="#16-最多删除一个字符得到回文" class="headerlink" title="16. 最多删除一个字符得到回文"></a>16. 最多删除一个字符得到回文</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420791125171642079112514.png" alt="最多删除一个字符得到回文"></p><p>题解：函数传参保护现场</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =str.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[left]!=str[right])<br>            &#123;<br>                <span class="hljs-keyword">return</span> cmp(str,left+<span class="hljs-number">1</span>,right)||cmp(str,left,right-<span class="hljs-number">1</span>);<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[left]!=str[right]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-回文字符串的个数"><a href="#17-回文字符串的个数" class="headerlink" title="17.回文字符串的个数"></a>17.回文字符串的个数</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16420791385051642079138502.png" alt="回文字符串的个数"></p><p>题解：动态规划，找准起点和终点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">int</span> m = str.length;<br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][m];<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            dp[i][i]=<span class="hljs-keyword">true</span>;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len =<span class="hljs-number">2</span>;len&lt;=m;len++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>;start+len-<span class="hljs-number">1</span>&lt;m;start++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> end = start+len-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(len==<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(str[start]==str[end])<br>                    &#123;<br>                        dp[start][end]=<span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(str[start]==str[end])<br>                    &#123;<br>                        dp[start][end]=dp[start+<span class="hljs-number">1</span>][end-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(dp[start][end]) ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-删除链表的倒数第n个节点"><a href="#18-删除链表的倒数第n个节点" class="headerlink" title="18. 删除链表的倒数第n个节点"></a>18. 删除链表的倒数第n个节点</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16421487557961642148755786.png" alt="删除链表的倒数第n个节点"></p><p>题解：模拟压栈的操作，但是很费内存，双指针也可以，递归内存会比较省。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        ListNode p = dummy;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            stack.push(p);<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n&gt;stack.size()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(n==stack.size()) <span class="hljs-keyword">return</span> head.next;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        ListNode next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())<br>        &#123;<br>            tmp=stack.pop();<br>            count++;<br>            <span class="hljs-keyword">if</span>(count==n)<br>            &#123;<br>                stack.pop().next=next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            next=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans =recur(head,n);<br>        <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recur</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> num = recur(head.next,n);<br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>        &#123;<br>            head.next=head.next.next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> num-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-链表中环的入口节点"><a href="#19-链表中环的入口节点" class="headerlink" title="19. 链表中环的入口节点"></a>19. 链表中环的入口节点</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16421488640511642148864041.png" alt="链表环的入口节点"></p><p>题解：最简单的办法，一个hashset，另一种办法，快慢指针，数学推导。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode p = head;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(p)) <span class="hljs-keyword">return</span> p;   <br>            set.add(p);<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-两个链表的第一个重合节点"><a href="#20-两个链表的第一个重合节点" class="headerlink" title="20. 两个链表的第一个重合节点"></a>20. 两个链表的第一个重合节点</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16421498825271642149882518.png" alt="两个链表的第一个重合节点"></p><p>题解：最朴素，使用一个set进行标记<br>题解2：拿出来一段补上</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode p = headA;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            set.add(p);<br>            p=p.next;<br>        &#125;<br>        ListNode q = headB;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(q))<br>            &#123;<br>                <span class="hljs-keyword">return</span> q;<br>            &#125;<br>            q=q.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode p = headA;<br>        ListNode q = headB;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>||q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>&amp;&amp;q==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>) p=headB;<br>            <span class="hljs-keyword">if</span>(q==<span class="hljs-keyword">null</span>) q=headA;<br>            <span class="hljs-keyword">if</span>(q==p) <span class="hljs-keyword">return</span> q;<br>            q=q.next;<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-反转链表"><a href="#21-反转链表" class="headerlink" title="21. 反转链表"></a>21. 反转链表</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16422299224221642229922414.png" alt="反转链表"></p><p>题解：最喜欢递归。双指针也行，头插法更秒</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(head.next==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode pre = head;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        ListNode next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(pre!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            next = pre.next;<br>            pre.next=tmp;<br>            tmp= pre;<br>            pre=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-链表中的两数相加"><a href="#22-链表中的两数相加" class="headerlink" title="22. 链表中的两数相加"></a>22. 链表中的两数相加</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16422300342691642230034259.png" alt="链表中的两数相加"></p><p>题解：双栈保存结果即可</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> l1;<br>        Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        ListNode p = l1;<br>        ListNode q = l2;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            stack1.push(p.val);<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            stack2.push(q.val);<br>            q = q.next;<br>        &#125;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//对stack的两个数进行相加</span><br>        <span class="hljs-keyword">boolean</span> carry = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> len = Math.min(stack1.size(),stack2.size());<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        ListNode tmp;<br>        <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(carry) sum=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> sum=<span class="hljs-number">0</span>;<br>            sum += stack1.pop()+stack2.pop();<br>            carry=sum&gt;=<span class="hljs-number">10</span>?<span class="hljs-keyword">true</span>:<span class="hljs-keyword">false</span>;<br>            sum= sum%<span class="hljs-number">10</span>;<br>            tmp= dummy.next;<br>            dummy.next=<span class="hljs-keyword">new</span> ListNode(sum);<br>            dummy.next.next = tmp;<br>            len--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack2.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(carry) sum=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> sum=<span class="hljs-number">0</span>;<br>            sum  += stack2.pop();<br>            carry= sum&gt;=<span class="hljs-number">10</span>?<span class="hljs-keyword">true</span>:<span class="hljs-keyword">false</span>;<br>            sum=sum%<span class="hljs-number">10</span>;<br>            tmp= dummy.next;<br>            dummy.next=<span class="hljs-keyword">new</span> ListNode(sum);<br>            dummy.next.next = tmp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(carry) sum=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> sum=<span class="hljs-number">0</span>;<br>            sum  += stack1.pop();<br>            carry= sum&gt;=<span class="hljs-number">10</span>?<span class="hljs-keyword">true</span>:<span class="hljs-keyword">false</span>;<br>            sum=sum%<span class="hljs-number">10</span>;<br>            tmp= dummy.next;<br>            dummy.next=<span class="hljs-keyword">new</span> ListNode(sum);<br>            dummy.next.next = tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry)<br>        &#123;<br>            tmp= dummy.next;<br>            dummy.next=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>            dummy.next.next = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-重排链表"><a href="#23-重排链表" class="headerlink" title="23. 重排链表"></a>23. 重排链表</h2><p>题目： <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16422301238731642230123866.png" alt="重排链表"></p><p>题解1： 一个栈保存后面的，然后再走一遍<br>题解2： 链表反转，合并</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(head.next==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(head.next.next==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//放到栈里面</span><br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        ListNode p = head;<br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            count++;<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(count);</span><br>        p=head;<br>        <span class="hljs-keyword">int</span> len =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(len&lt;=count/<span class="hljs-number">2</span>)<br>        &#123;<br>            p=p.next;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>) p=p.next;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            stack.push(p);<br>            p=p.next;<br>        &#125; <br>        <span class="hljs-comment">//放到栈里面了</span><br>        p = head;<br>        <span class="hljs-comment">//  a-&gt;b-&gt;c//插入的元素个数为  总数除2</span><br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        ListNode next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// System.out.println(stack);</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())<br>        &#123;<br>            tmp=stack.pop();<br>            next = p.next;<br>            p.next = tmp;<br>            tmp.next = next;<br>            p=next;<br>        &#125;<br>        p.next=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-回文链表"><a href="#24-回文链表" class="headerlink" title="24. 回文链表"></a>24. 回文链表</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16423342164491642334216439.png" alt="回文链表"></p><p>题解：以后凡是这种不是按照链表顺序来的，所谓的链表顺序，只能是，一个前一个后，一起前进，因为这才符合单链表的性质，所以回文的话，是要往中间靠，反转后半段链表，然后快慢指针就可以实现一前一后。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        ListNode p = head;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            count++;<br>            ans.add(p.val);<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-comment">//添加到数组里面</span><br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = ans.size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ans.get(left)!=ans.get(right))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-展平多级双向链表"><a href="#25-展平多级双向链表" class="headerlink" title="25. 展平多级双向链表"></a>25. 展平多级双向链表</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16423344952761642334495265.png" alt="展开多级双向链表"></p><p>题解1：这是大二时候做的，，一对比现在的题解，感觉那时候的自己怎么这么厉害，可以想到这种。emm，好好加油，当时自己的思路是使用全局变量，这样子可以达到比较好的结果。相比传递参数，这样子逻辑会比较清晰和简单。</p><p>题解2：这个题目可以看成树的前序遍历，然后保存临时变量。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Node dummy = <span class="hljs-keyword">new</span> Node();<br>    Node p = dummy;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">flatten</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        travel(head);<br>        dummy.next.prev=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">travel</span><span class="hljs-params">(Node head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        p.next = head;<br>        head.prev = p;<br>        p = head;<br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>        Node tmp = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(head.child!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            flag=<span class="hljs-keyword">true</span>;<br>            tmp=head.next;<br>            travel(head.child);<br>            head.child=<span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            travel(tmp);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            travel(head.next);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-排序的循环链表"><a href="#26-排序的循环链表" class="headerlink" title="26. 排序的循环链表"></a>26. 排序的循环链表</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16423346675521642334667542.png" alt="排序的循环链表"></p><p>题解：注重中间那个判断，能插入的位置，只有前小后大，或者前大后小</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> insertVal)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>)<br>       &#123;<br>            head=<span class="hljs-keyword">new</span> Node(insertVal);<br>            head.next=head;<br>            <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(head.next==head)<br>       &#123;<br>           head.next = <span class="hljs-keyword">new</span> Node(insertVal);<br>           head.next.next=head;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       Node prev=head;<br>       Node next= head.next;<br>       Node tmp;<br>       <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>       <span class="hljs-keyword">while</span>(next!=head)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(prev.val&lt;=insertVal&amp;&amp;insertVal&lt;=next.val<br>             ||(prev.val&gt;next.val&amp;&amp;(insertVal&lt;=next.val||insertVal&gt;=prev.val)))<br>           &#123;<br>               tmp= prev.next;<br>               prev.next=<span class="hljs-keyword">new</span> Node(insertVal);<br>               prev.next.next=tmp;<br>               flag=<span class="hljs-keyword">true</span>;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>           prev=prev.next;<br>           next=next.next;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(flag)<br>        <span class="hljs-keyword">return</span> head;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>            tmp= prev.next;<br>            prev.next=<span class="hljs-keyword">new</span> Node(insertVal);<br>            prev.next.next=tmp;<br>            <span class="hljs-keyword">return</span> head;<br>       &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-插入，删除和随机访问都是O-1-的容器"><a href="#27-插入，删除和随机访问都是O-1-的容器" class="headerlink" title="27. 插入，删除和随机访问都是O(1)的容器"></a>27. 插入，删除和随机访问都是O(1)的容器</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424046177271642404617718.png" alt="插入，删除和随机访问都是O(1)的容器"></p><p>题解：动态数组保存数据，插入从最后面插入，时间复杂度为O（1），删除，因为我们现在不用管数组的位置，我们在hashmap将对应的索引改了就可以，将数组的最后一个元素，移动到当前的元素，然后把最后一个元素的索引进行删除。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedSet</span> </span>&#123;<br>    Map&lt;Integer,Integer&gt; map;<br>    List&lt;Integer&gt; arr;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomizedSet</span><span class="hljs-params">()</span> </span>&#123;<br>        map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        arr=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.get(val)==<span class="hljs-keyword">null</span>)<br>        &#123;<br>            map.put(val,arr.size());<br>            arr.add(val);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>((idx=map.getOrDefault(val,-<span class="hljs-number">1</span>))!=-<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> fianlNumber = arr.get(arr.size()-<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//数组填充最后一个元素</span><br>            arr.set(idx,fianlNumber);<br>            map.replace(fianlNumber,idx);<br>            arr.remove(arr.size()-<span class="hljs-number">1</span>);<br>            map.remove(val);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the set. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        Random random=<span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span> idx =random.nextInt(arr.size());<br>        <span class="hljs-keyword">return</span> arr.get(idx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-最近最少使用缓存"><a href="#28-最近最少使用缓存" class="headerlink" title="28. 最近最少使用缓存"></a>28. 最近最少使用缓存</h2><p>题目： <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424048585141642404858504.png" alt="最近最少使用缓存"></p><p>题解： 这道题我写了好久，hashmap加上双链表，可以实现O（1）的时间复杂度，可以想成模拟一个栈，然后每次往栈里面放入，如果该元素在栈里面存在，那么将该元素移动到栈顶，如果不存在，直接放在栈顶，元素满的时候，首先清楚栈底的，对于链表，记得转移的时候清楚对应的执行，不然会出现环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span></span><br><span class="hljs-class"></span>&#123;<br>    ListNode prev;<br>    ListNode next;<br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>.key=key;<br>        <span class="hljs-keyword">this</span>.val=val;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cap=<span class="hljs-number">0</span>;<br>    ListNode head;<br>    ListNode end;<br>    Map&lt;Integer,ListNode&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        head = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>        end = head;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        ListNode tmp =map.get(key);<br>        <span class="hljs-comment">// System.out.println(map);</span><br><br>        <span class="hljs-keyword">if</span>(tmp!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp.next==<span class="hljs-keyword">null</span>)<br>            &#123;<br>                <span class="hljs-comment">//代表是在最后一个</span><br>                <span class="hljs-keyword">return</span> tmp.val;<br>            &#125;<br>            <span class="hljs-comment">//更新缓存中的节点，换到最后面</span><br>            tmp.prev.next=tmp.next;<br>            tmp.next.prev=tmp.prev;<br><br>            <span class="hljs-comment">//插入到结尾</span><br>            addToTail(tmp);<br><br>            <span class="hljs-keyword">return</span> tmp.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//缓存中找不到</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        ListNode tmp = map.get(key);<br>        <span class="hljs-comment">// System.out.println(head);</span><br>        <span class="hljs-keyword">if</span>(tmp==<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-comment">//如果满了</span><br>            <span class="hljs-keyword">if</span>(cap==<span class="hljs-number">0</span>)<br>            &#123;<br>                tmp = <span class="hljs-keyword">new</span> ListNode(key,value);<br>                removeFromHead();<br>                addToTail(tmp);<br>                <span class="hljs-comment">//修改map的值</span><br>                map.put(key,tmp);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tmp = <span class="hljs-keyword">new</span> ListNode(key,value);<br>                <span class="hljs-comment">//直接放进去</span><br>                cap--;<br>                addToTail(tmp);<br>                <span class="hljs-comment">//修改map的值</span><br>                map.put(key,tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(end==tmp)<br>            &#123;<br>                tmp.val=value;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-comment">//更新缓存中的节点，换到最后面</span><br>            tmp.prev.next=tmp.next;<br>            tmp.next.prev=tmp.prev;<br>            <span class="hljs-comment">//插入到结尾</span><br>            addToTail(tmp);<br>            tmp.val=value;<br>            map.replace(key,tmp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//删除头部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFromHead</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        map.remove(head.next.key);<br>        head.next=head.next.next;<br>        <span class="hljs-keyword">if</span>(head.next!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            head.next.prev=head;<br>        &#125;<br>    &#125;<br><br>        <span class="hljs-comment">//插入尾部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToTail</span><span class="hljs-params">(ListNode node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        end.next=node;<br>        node.prev=end;<br>        node.next=<span class="hljs-keyword">null</span>;<br>        end=node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-有效的变位词"><a href="#29-有效的变位词" class="headerlink" title="29. 有效的变位词"></a>29. 有效的变位词</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424050995401642405099534.png" alt="有效的变位词"></p><p>题解：一个count数组，走一遍就可以</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length()!=t.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(s.equals(t)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] str1 = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str2 = t.toCharArray();<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;str2.length;i++)<br>        &#123;<br>            count[str2[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            count[str1[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(count[i]!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30-变位词组"><a href="#30-变位词组" class="headerlink" title="30.变位词组"></a>30.变位词组</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424906405781642490640570.png" alt="变位词组"></p><p>题解：[[字符串异位]]对字符串进行排序，然后放入到map，如果排序之后的字符串是相同的代表是异位的字符串，则将原本的字符串放入到map的集合当中</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str:strs)<br>        &#123;<br>            <span class="hljs-keyword">char</span>[] s = str.toCharArray();<br>            Arrays.sort(s);<br>            String tmpStr = String.valueOf(s);<br>            <span class="hljs-keyword">if</span>(map.containsKey(tmpStr))<br>            &#123;<br>                map.get(tmpStr).add(str);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.add(str);<br>                map.put(tmpStr,list);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(List&lt;String&gt; s:map.values())<br>        &#123;<br>            ans.add(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-外形语言是否排序"><a href="#31-外形语言是否排序" class="headerlink" title="31. 外形语言是否排序"></a>31. 外形语言是否排序</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424724823761642472482367.png" alt="题目"></p><p>题解：搞明白java涉及的自定义排序的方法，该题目的转化性问题：正常排序是按照26个字母的顺序进行排序，如果自定义这26个字母的顺序，就需要自定义对应的hash表，规定好每个字母对应的大小为多少。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] orders = order.toCharArray();<br>        String[] tmp = words.clone();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;orders.length;i++)<br>        &#123;<br>            map.put(orders[i],i);<br>        &#125;<br>        Arrays.sort(words, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<br>                <span class="hljs-keyword">char</span>[] str1= o1.toCharArray();<br>                <span class="hljs-keyword">char</span>[] str2 = o2.toCharArray();<br>                <span class="hljs-keyword">int</span> len = Math.min(str1.length,str2.length);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(map.get(str1[i])&lt;map.get(str2[i])) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.get(str1[i])&gt;map.get(str2[i])) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// System.out.println(o1+&quot;  &quot;+o2);</span><br>                <span class="hljs-keyword">if</span>(str1.length&gt;str2.length) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> Arrays.equals(words,tmp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最小时间差"><a href="#32-最小时间差" class="headerlink" title="32. 最小时间差"></a>32. 最小时间差</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16424888047971642488804788.png" alt="最小时间差"></p><p>题解：排序，然后加上比较相邻的数</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(timePoints.size()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(timePoints.size()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[timePoints.size()];<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(String s:timePoints)<br>        &#123;<br>            String[] data=s.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            <span class="hljs-keyword">int</span> time = Integer.valueOf(data[<span class="hljs-number">0</span>])*<span class="hljs-number">60</span>+Integer.valueOf(data[<span class="hljs-number">1</span>]);<br>            arr[count++]=time;<br>        &#125;<br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">int</span> min =Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;arr.length-<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            min = Math.min(min,arr[i+<span class="hljs-number">1</span>]-arr[i]);<br>        &#125;<br>        min = Math.min(min,arr[<span class="hljs-number">0</span>]+<span class="hljs-number">1440</span>-arr[arr.length-<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-后缀表达式求值"><a href="#33-后缀表达式求值" class="headerlink" title="33. 后缀表达式求值"></a>33. 后缀表达式求值</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16425787141571642578714151.png" alt="后缀表达式求值"></p><p>题解：这道题太简单了，不需要题解</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String token :tokens)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;*&quot;</span>)||token.equals(<span class="hljs-string">&quot;/&quot;</span>)||token.equals(<span class="hljs-string">&quot;+&quot;</span>)||token.equals(<span class="hljs-string">&quot;-&quot;</span>))<br>            &#123;<br>                <span class="hljs-keyword">int</span> number1 = stack.pop();<br>                <span class="hljs-keyword">int</span> number2 = stack.pop();<br>                <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;*&quot;</span>))<br>                &#123;<br>                    stack.push(number1*number2);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;/&quot;</span>))<br>                &#123;<br>                    stack.push(number2/number1);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;+&quot;</span>))<br>                &#123;<br>                    stack.push(number1+number2);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;-&quot;</span>))<br>                &#123;<br>                    stack.push(number2-number1);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">int</span> value=Integer.valueOf(token);<br>                stack.push(value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-小行星碰撞"><a href="#34-小行星碰撞" class="headerlink" title="34. 小行星碰撞"></a>34. 小行星碰撞</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16425787981541642578798137.png" alt="小行星碰撞"></p><p>题解：压栈，出栈正常操作</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] asteroidCollision(<span class="hljs-keyword">int</span>[] asteroids) &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = asteroids.length;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> asteroids;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty())<br>            &#123;<br>                stack.push(asteroids[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(asteroids[i]&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(stack.peek()&lt;<span class="hljs-number">0</span>) stack.push(asteroids[i]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.peek()&gt;-asteroids[i])<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.peek()==-asteroids[i])<br>                &#123;<br>                    stack.pop();<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.peek()&lt;-asteroids[i])<br>                &#123;<br>                    <span class="hljs-keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroids[i]&amp;&amp;stack.peek()&gt;<span class="hljs-number">0</span>)<br>                    &#123;<br>                        stack.pop();<br>                    &#125;<br>                    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span>(!stack.isEmpty()&amp;&amp;stack.peek()==-asteroids[i])<br>                    &#123;<br>                        flag = <span class="hljs-keyword">true</span>;<br>                        stack.pop();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroids[i]&amp;&amp;stack.peek()&lt;<span class="hljs-number">0</span>&amp;&amp;!flag)<br>                    &#123;<br>                        stack.push(asteroids[i]);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(stack.isEmpty()&amp;&amp;!flag) stack.push(asteroids[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(asteroids[i]&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                stack.push(asteroids[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[stack.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =ans.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            ans[i]=stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-每日温度"><a href="#35-每日温度" class="headerlink" title="35. 每日温度"></a>35. 每日温度</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16425788724971642578872490.png" alt="每日温度"></p><p>题解：单调栈问题，找出后面比它的大元素在哪里，如果要压入栈的元素比栈顶的元素小或者等于，直接压入栈，如果大于栈顶的元素，弹出，然后算出索引相差。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>        <span class="hljs-comment">//每日温度，找到右边第一个比自己大的</span><br>        <span class="hljs-keyword">int</span> len = temperatures.length;<br>        <span class="hljs-keyword">int</span> [] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty()&amp;&amp;temperatures[stack.peek()]&lt;temperatures[i])<br>            &#123;<br>                <span class="hljs-keyword">int</span> Idex = stack.pop();<br>                ans[Idex]=i-Idex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="36-直方图中最大的矩形"><a href="#36-直方图中最大的矩形" class="headerlink" title="36. 直方图中最大的矩形"></a>36. 直方图中最大的矩形</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16426588267291642658826721.png" alt="直方图中最大的矩形"></p><p>题解：翻译题目，找到前面比自己小的，找到后面比自己小的，这两个索引相减，就是矩形的宽度，自己的值就是矩形的高度，所以可以用到单调栈的解法，单调栈，找到后面比自己小的位置没有问题，找到前面比自己小的也没有问题，注意一开始压入一个-1，可以更好地避免对于边界的讨论。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> len = heights.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(stack.peek()!=-<span class="hljs-number">1</span>&amp;&amp;heights[stack.peek()]&gt;=heights[i])<br>            &#123;<br>                <span class="hljs-keyword">int</span> height = heights[stack.pop()];<br>                <span class="hljs-keyword">int</span> width = i-stack.peek()-<span class="hljs-number">1</span>;<br>                maxArea = Math.max(maxArea,height*width);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(stack.peek()!=-<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> height = heights[stack.pop()];<br>            <span class="hljs-keyword">int</span> width = len -stack.peek()-<span class="hljs-number">1</span>;<br>            maxArea = Math.max(maxArea,height*width);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="37-矩形中最大的矩形"><a href="#37-矩形中最大的矩形" class="headerlink" title="37. 矩形中最大的矩形"></a>37. 矩形中最大的矩形</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16426590724271642659072416.png" alt="矩形中最大的矩形"></p><p>题解：二维问题转化为一维问题，该问题可以转换成，对每一行求直方图的最大矩形面积就可以。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(String[] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix[<span class="hljs-number">0</span>].length()];<br>        <span class="hljs-keyword">for</span>(String line:matrix)<br>        &#123;<br>            <span class="hljs-keyword">char</span>[] s= line.toCharArray();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>) dp[i]=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) dp[i]=dp[i]+<span class="hljs-number">1</span>;<br>            &#125;<br>            max= Math.max(max,maxArea(dp));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;dp.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(stack.peek()!=-<span class="hljs-number">1</span>&amp;&amp;dp[stack.peek()]&gt;=dp[i])<br>            &#123;<br>                <span class="hljs-keyword">int</span> height = dp[stack.pop()];<br>                <span class="hljs-keyword">int</span> width = i-<span class="hljs-number">1</span>-stack.peek();<br>                <span class="hljs-comment">// System.out.println(height+&quot;   &quot;+width);</span><br>                maxArea = Math.max(maxArea,height*width);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(stack.peek()!=-<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> height = dp[stack.pop()];<br>            <span class="hljs-keyword">int</span> width = dp.length-<span class="hljs-number">1</span>-stack.peek();<br>            maxArea = Math.max(maxArea,height*width);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="38-滑动窗口的平均值"><a href="#38-滑动窗口的平均值" class="headerlink" title="38. 滑动窗口的平均值"></a>38. 滑动窗口的平均值</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16427467497501642746749741.png" alt="滑动窗口的平均值"></p><p>题解：正常的固定位置的滑动窗口问题</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovingAverage</span> </span>&#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> size =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovingAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.size = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(count!=size)<br>        &#123;<br>            sum+=val;<br>            count++;<br>            queue.add(val);<br>            <span class="hljs-keyword">return</span> sum*<span class="hljs-number">1.0</span>/count;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count==size)<br>        &#123;<br>            sum-=queue.poll();<br>            queue.add(val);<br>            sum+=val;<br>            <span class="hljs-keyword">return</span> sum*<span class="hljs-number">1.0</span>/count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-最近请求次数"><a href="#39-最近请求次数" class="headerlink" title="39.最近请求次数"></a>39.最近请求次数</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16427468574381642746857417.png" alt="最近请求次数"></p><p>题解：正常滑动窗口</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span> </span>&#123;<br>    Queue&lt;Integer&gt; queue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RecentCounter</span><span class="hljs-params">()</span> </span>&#123;<br>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> preIdex = t-<span class="hljs-number">3000</span>;<br>        queue.add(t);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()&amp;&amp;queue.peek()&lt;preIdex)<br>        &#123;<br>            queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-往完全二叉树添加节点"><a href="#40-往完全二叉树添加节点" class="headerlink" title="40. 往完全二叉树添加节点"></a>40. 往完全二叉树添加节点</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16427469328441642746932835.png" alt="往完全二叉树添加节点"></p><p>题解：这道题前面的初始化可以借助里面的函数，我的假想就是一开始只有一个root的节点，然后一个个地插入元素。感觉这样子挺好的哈哈哈哈。</p><p>题解2：搜索，然后往队列放入相应的元素</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBTInserter</span> </span>&#123;<br>    TreeNode root;<br>    Queue&lt;TreeNode&gt; queue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CBTInserter</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.root=root;<br>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>        &#123;<br>            TreeNode head = queue.peek();<br>                <span class="hljs-keyword">if</span>(head.left==<span class="hljs-keyword">null</span>)<br>                &#123;<br>                    head.left = <span class="hljs-keyword">new</span> TreeNode(v);<br>                    <span class="hljs-keyword">return</span> head.val; <br>                &#125;<br>                <span class="hljs-keyword">if</span>(head.right==<span class="hljs-keyword">null</span>)<br>                &#123;<br>                    head.right = <span class="hljs-keyword">new</span> TreeNode(v);<br>                        <span class="hljs-keyword">return</span> head.val;<br>                &#125;<br>                queue.poll();<br>                queue.add(head.left);<br>                queue.add(head.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="41-二叉树每层的最大值"><a href="#41-二叉树每层的最大值" class="headerlink" title="41. 二叉树每层的最大值"></a>41. 二叉树每层的最大值</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428322430951642832243090.png" alt="二叉树每层的最大值"></p><p>题解:利用len保存队列中元素的个数，就可以很方便地访问每一层，然后就很简单了</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = queue.size();<br>            <span class="hljs-keyword">int</span> max = queue.peek().val;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>            &#123;<br>                TreeNode head = queue.poll();<br>                max=Math.max(max,head.val);<br>                <span class="hljs-keyword">if</span>(head.left!=<span class="hljs-keyword">null</span>)<br>                    queue.add(head.left);<br>                <span class="hljs-keyword">if</span>(head.right!=<span class="hljs-keyword">null</span>)<br>                    queue.add(head.right);<br>            &#125;<br>            ans.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-二叉树最底层最左边的值"><a href="#42-二叉树最底层最左边的值" class="headerlink" title="42. 二叉树最底层最左边的值"></a>42. 二叉树最底层最左边的值</h2><p>题目: <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428323503401642832350333.png" alt="二叉树最底层最左边的值"></p><p>题解:同样是队列保存长度，按层进行遍历</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">int</span> ans = root.val;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) ans = queue.peek().val;<br>                TreeNode head = queue.poll();<br>                <span class="hljs-keyword">if</span>(head.left!=<span class="hljs-keyword">null</span>)<br>                    queue.add(head.left);<br>                <span class="hljs-keyword">if</span>(head.right!=<span class="hljs-keyword">null</span>)<br>                    queue.add(head.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="43-二叉树的右侧视图"><a href="#43-二叉树的右侧视图" class="headerlink" title="43. 二叉树的右侧视图"></a>43. 二叉树的右侧视图</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428324225101642832422503.png" alt="二叉树的右侧视图"></p><p>题解:同样按照层次进行遍历</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==len-<span class="hljs-number">1</span>) ans.add(queue.peek().val);<br>                TreeNode head = queue.poll();<br>                <span class="hljs-keyword">if</span>(head.left!=<span class="hljs-keyword">null</span>) <br>                    queue.add(head.left);<br>                <span class="hljs-keyword">if</span>(head.right!=<span class="hljs-keyword">null</span>)<br>                    queue.add(head.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="44-二叉树剪枝"><a href="#44-二叉树剪枝" class="headerlink" title="44. 二叉树剪枝"></a>44. 二叉树剪枝</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16429093649561642909364947.png" alt="二叉树的后缀剪枝"></p><p>题解:采用后序遍历，如果当前的节点的左孩子不是空的，并且左孩子的左孩子和又孩子是空的，并且是0,那么就可以把左孩子移除，右孩子也是同样的道理，针对头节点需要进行特殊的处理，添加虚拟节点。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        TreeNode dummy = <span class="hljs-keyword">new</span> TreeNode();<br>        dummy.left=root;<br>        dfs(dummy);<br>        <span class="hljs-keyword">return</span> dummy.left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        TreeNode left  = dfs(root.left);<br>        TreeNode right = dfs(root.right);<br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-keyword">null</span>&amp;&amp;left.left==<span class="hljs-keyword">null</span>&amp;&amp;left.right==<span class="hljs-keyword">null</span>&amp;&amp;left.val==<span class="hljs-number">0</span>) root.left=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(right!=<span class="hljs-keyword">null</span>&amp;&amp;right.left==<span class="hljs-keyword">null</span>&amp;&amp;right.right==<span class="hljs-keyword">null</span>&amp;&amp;right.val==<span class="hljs-number">0</span>) root.right=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-序列化树和反序列化树"><a href="#45-序列化树和反序列化树" class="headerlink" title="45. 序列化树和反序列化树"></a>45. 序列化树和反序列化树</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16429094273771642909427353.png" alt="序列化树和反序列化树"></p><p>题解:一开始想的使用bfs，但是发现bfs遍历起来，中间的细节太多，并且遍历出来的树，不是完全二叉树，原本想用下标进行解决，但是发现二叉树不可以直接转化成完成二叉树。最后采用前序的递归遍历，然后保存在string当中，使用split进行分解，然后利用一个全局的idx保存当前的位置，就可以完成对应的遍历。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ser</span><span class="hljs-params">(TreeNode root,StringBuilder sb)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)<br>        &#123;<br>            sb.append(<span class="hljs-string">&quot;#,&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        sb.append(root.val+<span class="hljs-string">&quot;,&quot;</span>);<br>        ser(root.left,sb);<br>        ser(root.right,sb);<br>    &#125;<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        ser(root,sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// System.out.println(data);</span><br>        String[] strs = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        TreeNode root;<br>        root=deser(strs);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deser</span><span class="hljs-params">(String[] strs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(strs[idx].equals(<span class="hljs-string">&quot;#&quot;</span>))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(strs[idx]));<br>        ++idx;<br>        root.left = deser(strs);<br>        ++idx;<br>        root.right = deser(strs);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        Map.Entry&lt;Integer,Integer&gt; entry = treeMap.floorEntry(start);<br>        <span class="hljs-keyword">if</span>(entry!=<span class="hljs-keyword">null</span>&amp;&amp;entry.getValue()&gt;start) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        entry = treeMap.ceilingEntry(start);<br>        <span class="hljs-keyword">if</span>(entry!=<span class="hljs-keyword">null</span>&amp;&amp;entry.getKey()&lt;end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        treeMap.put(start,end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-从根节点到叶节点的路径数字之和"><a href="#46-从根节点到叶节点的路径数字之和" class="headerlink" title="46. 从根节点到叶节点的路径数字之和"></a>46. 从根节点到叶节点的路径数字之和</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16436446986831643644697846.png" alt="从根节点到叶节点的路径数字之和"></p><p>题解:遍历到叶子节点完成一次相加</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>)<br>        &#123;   <br>            sum+=(res*<span class="hljs-number">10</span>+root.val);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        dfs(root.left,res*<span class="hljs-number">10</span>+root.val);<br>        dfs(root.right,res*<span class="hljs-number">10</span>+root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="44-向下的路径节点之和"><a href="#44-向下的路径节点之和" class="headerlink" title="44. 向下的路径节点之和"></a>44. 向下的路径节点之和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430101957181643010195706.png" alt="向下的路径节点之和"></p><p>题解1：最简单的，前缀遍历树，然后对每一个子树做路径和的判断。<br>题解2：<strong>前缀和</strong> 我们这里需要需要保存每一个前缀和，然后我们遇到一个新的路径和，我们就拿路径和减去目标值，然后判断这个值是否在我们的前缀和目录中。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        dfs(root,targetSum,map,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> targetSum,Map&lt;Integer,Integer&gt; map,<span class="hljs-keyword">int</span> path)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        path+=root.val;<br>        count+=map.getOrDefault(path-targetSum,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(map.containsKey(path))<br>        &#123;<br>            map.replace(path,map.get(path)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            map.put(path,<span class="hljs-number">1</span>);<br>        &#125;<br>        dfs(root.left,targetSum,map,path);<br>        dfs(root.right,targetSum,map,path);<br>        map.replace(path,map.get(path)-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Integer sum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        sum=<span class="hljs-number">0</span>;<br>        cur(root,targetSum);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cur</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> targetSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>       dfs(root,targetSum,<span class="hljs-number">0</span>);<br>       cur(root.left,targetSum);<br>       cur(root.right,targetSum);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> targetSum,<span class="hljs-keyword">int</span> theSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        theSum+=root.val;<br>        <span class="hljs-keyword">if</span>(theSum==targetSum)<br>        &#123;<br>            sum++;<br>        &#125;<br>        dfs(root.left,targetSum,theSum);<br>        dfs(root.right,targetSum,theSum);<br>        theSum-=root.val;<br>       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-节点之和的最大路径"><a href="#45-节点之和的最大路径" class="headerlink" title="45. 节点之和的最大路径"></a>45. 节点之和的最大路径</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430102338781643010233861.png" alt="节点之和的最大路径"></p><p>题解：题目的意思可以转变成为左子树和右边子树的最大路径和。如果路径和为0,我们是不要该路径和的，因此我们在遍历返回结果的时候进行判断，如果是负数，直接进行舍弃。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret =Integer.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//注重理解这里的意思</span><br>        <span class="hljs-keyword">int</span> left =Math.max(<span class="hljs-number">0</span>,dfs(root.left));<br>        <span class="hljs-keyword">int</span> right =Math.max(<span class="hljs-number">0</span>,dfs(root.right));<br>        ret =Math.max(ret,left+right+root.val);<br>        <span class="hljs-keyword">return</span> root.val+Math.max(left,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-展平二叉搜索树"><a href="#46-展平二叉搜索树" class="headerlink" title="46. 展平二叉搜索树"></a>46. 展平二叉搜索树</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430105635791643010563572.png" alt="展平二叉搜索树"></p><p>题解：使用一个head和prev的全局变量，head保存头节点，当左子树为空的时候，就可以给该变量赋值，，然后还得注意prev是在什么时候赋值的</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    TreeNode head;<br>    TreeNode prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span>(prev==<span class="hljs-keyword">null</span>) head=root;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            root.left=<span class="hljs-keyword">null</span>;<br>            prev.right = root;<br>        &#125;<br>        prev=root;<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="47-二叉搜索树的中序后继"><a href="#47-二叉搜索树的中序后继" class="headerlink" title="47. 二叉搜索树的中序后继"></a>47. 二叉搜索树的中序后继</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430936579541643093657935.png" alt="二叉搜索树的中序后续"></p><p>题解：类似于树的扁平化，树扁平化成为链表</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    TreeNode ans;<br>    TreeNode prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode root, TreeNode p)</span> </span>&#123;<br>        inorderDfs(root,p);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorderDfs</span><span class="hljs-params">(TreeNode root,TreeNode p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        inorderDfs(root.left,p);<br>        <span class="hljs-keyword">if</span>(prev==p) ans=root; <br>        prev=root;<br>        inorderDfs(root.right,p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-所有大于等于节点的值之和"><a href="#48-所有大于等于节点的值之和" class="headerlink" title="48. 所有大于等于节点的值之和"></a>48. 所有大于等于节点的值之和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430940691671643094069152.png" alt="所有大于等于节点的值之和"></p><p>题解：中序遍历，从右边开始，然后利用一个sum对右侧进行求和</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        dfs(root.right);<br>        sum+=root.val;<br>        root.val=sum;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-二叉搜索树迭代器"><a href="#49-二叉搜索树迭代器" class="headerlink" title="49. 二叉搜索树迭代器"></a>49. 二叉搜索树迭代器</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16430942900731643094290047.png" alt="二叉搜索树迭代器"></p><p>题解：采用一个栈，模拟中序遍历，这题对于了解中序遍历的处理挺有好处的</p><p>中序遍历：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1643095758206AD01643C19AE3D3BE4501DB4428AF122.jpg" alt="中序遍历过程"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;<br>    Deque&lt;TreeNode&gt; stack;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        stack= <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        inorderDfs(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorderDfs</span><span class="hljs-params">(TreeNode root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            stack.push(root);<br>            root=root.left;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        TreeNode tmp= stack.pop();<br>        <span class="hljs-keyword">if</span>(tmp.right!=<span class="hljs-keyword">null</span>)<br>            inorderDfs(tmp.right);<br>        <span class="hljs-keyword">return</span> tmp.val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.size()!=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-二叉搜索树的两个节点之和"><a href="#50-二叉搜索树的两个节点之和" class="headerlink" title="50. 二叉搜索树的两个节点之和"></a>50. 二叉搜索树的两个节点之和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16431837671801643183767164.png" alt="二叉搜索树的两个节点之和"></p><p>题解：中序遍历成为数组进行保存，然后双指针遍历</p><p>题解2：使用双栈遍历，emm我真看不下去了 </p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        inoderRecur(root,arr);<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = arr.size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr.get(left)+arr.get(right)&gt;k)<br>            &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr.get(left)+arr.get(right)&lt;k)<br>            &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inoderRecur</span><span class="hljs-params">(TreeNode root,ArrayList&lt;Integer&gt; arr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        inoderRecur(root.left,arr);<br>        arr.add(root.val);<br>        inoderRecur(root.right,arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-值和下表之差都在给定的范围内"><a href="#51-值和下表之差都在给定的范围内" class="headerlink" title="51. 值和下表之差都在给定的范围内"></a>51. 值和下表之差都在给定的范围内</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16431839181851643183918171.png" alt="值和下标值之差都在给定的范围内"></p><p>题解：使用一个$TreeSet$，然后我直接通过ceiling找到第一个大于等于nums[j]-t的值，然后判断该值是否小于等于nums[j]+t如果是代表找到，然后进行返回，对于这边的k处理是，采用滑动窗口，保证我们treeSet里面的值都是符合的</p><p>题解2：桶排序</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        TreeSet&lt;Long&gt; treeSet = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            Long ceil = treeSet.ceiling((<span class="hljs-keyword">long</span>)nums[i]-(<span class="hljs-keyword">long</span>)t);<br>            <span class="hljs-keyword">if</span>(ceil!=<span class="hljs-keyword">null</span>&amp;&amp;ceil&lt;=(<span class="hljs-keyword">long</span>)nums[i]+(<span class="hljs-keyword">long</span>)t)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            treeSet.add((<span class="hljs-keyword">long</span>)nums[i]);<br>            <span class="hljs-keyword">if</span>(i&gt;=k)<br>            &#123;<br>                treeSet.remove((<span class="hljs-keyword">long</span>)nums[i-k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="52-日程表安排1"><a href="#52-日程表安排1" class="headerlink" title="52. 日程表安排1"></a>52. 日程表安排1</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16431841396461643184139624.png" alt="日程表安排1"></p><p>题解：注重了解Map.Entry这个东西,进行画图，观察两个区间的重合，我们可以先拿到第一个小于等于start的，如果其末尾大于start的话，返回false，接下来我们获取大于等于start的，同时其开端要大于我们区间的末尾</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendar</span> </span>&#123;<br>    TreeMap &lt;Integer,Integer&gt; treeMap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCalendar</span><span class="hljs-params">()</span> </span>&#123;<br>        treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        Map.Entry&lt;Integer,Integer&gt; entry = treeMap.floorEntry(start);<br>        <span class="hljs-keyword">if</span>(entry!=<span class="hljs-keyword">null</span>&amp;&amp;entry.getValue()&gt;start) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        entry = treeMap.ceilingEntry(start);<br>        <span class="hljs-keyword">if</span>(entry!=<span class="hljs-keyword">null</span>&amp;&amp;entry.getKey()&lt;end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        treeMap.put(start,end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-日程表安排2"><a href="#53-日程表安排2" class="headerlink" title="53. 日程表安排2"></a>53. 日程表安排2</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16431847115591643184711542.png" alt="日程表安排2"></p><p>题解：通过插旗法，进行处理，$[][]$这种括号可以，$[[]]$这种括号，对于start+1处理，对于end进行-1处理，第二种括号会得到2这种值，代表一次重叠，记住需要恢复现场</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendarTwo</span> </span>&#123;<br>    TreeMap&lt;Integer,Integer&gt; calendar;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCalendarTwo</span><span class="hljs-params">()</span> </span>&#123;<br>        calendar = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        calendar.put(start,calendar.getOrDefault(start,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        calendar.put(end,calendar.getOrDefault(end,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//记录活跃的天数</span><br>        <span class="hljs-keyword">int</span> active =<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d:calendar.values())<br>        &#123;<br>            active+=d;<br><br>            <span class="hljs-comment">//中途活跃日程&gt;=3时，返回false</span><br>            <span class="hljs-keyword">if</span>(active&gt;=<span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-comment">//恢复现场</span><br>                calendar.put(start,calendar.get(start)-<span class="hljs-number">1</span>);<br>                calendar.put(end,calendar.get(end)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-日程表安排3"><a href="#54-日程表安排3" class="headerlink" title="54. 日程表安排3"></a>54. 日程表安排3</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16431848829101643184882884.png" alt="日程表安排3"></p><p>题解：我们只需要每次遍历map，然后找到中间最大的值就可以了</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendarThree</span> </span>&#123;<br>    TreeMap&lt;Integer,Integer&gt; calendar;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCalendarThree</span><span class="hljs-params">()</span> </span>&#123;<br>        calendar = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        calendar.put(start,calendar.getOrDefault(start,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        calendar.put(end,calendar.getOrDefault(end,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">int</span> active= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d:calendar.values())<br>        &#123;<br>            active+=d;<br>            <br>            ans = Math.max(ans,active);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-数据流中第K大数值"><a href="#55-数据流中第K大数值" class="headerlink" title="55. 数据流中第K大数值"></a>55. 数据流中第K大数值</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16432590095371643259008693.png" alt="数据流中第K大数值"></p><p>题解：这边是找第K大的，所以，我们建立的小根堆，将不在范围内的小的排除出去</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> </span>&#123;<br>    Queue&lt;Integer&gt; queue;<br>    <span class="hljs-keyword">int</span> K;<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        K=k;<br>        count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> number:nums)<br>        &#123;<br>            queue.add(number);<br>            count++;<br>            <span class="hljs-keyword">if</span>(count&gt;k)<br>            &#123;<br>                queue.poll();<br>                count--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(count==K)<br>        &#123;<br>            queue.add(val);<br>            queue.remove();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count==K-<span class="hljs-number">1</span>)<br>        &#123;<br>            queue.add(val);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-出现频率最高的K个数字"><a href="#56-出现频率最高的K个数字" class="headerlink" title="56. 出现频率最高的K个数字"></a>56. 出现频率最高的K个数字</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16432591825391643259182462.png" alt="出现频率最高的K个数字"></p><p>题解：使用map.entry保存数字和数字出现的次数</p><p>进阶：使用快速排序，找前k个最大的数字</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(k==nums.length) <span class="hljs-keyword">return</span> nums;<br>        Queue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue= <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;&#123;<br>            <span class="hljs-keyword">if</span>(o1.getValue()==o2.getValue()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(o1.getValue()&lt;o2.getValue()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;);<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)<br>        &#123;<br>            <span class="hljs-keyword">int</span> count = map.getOrDefault(num,<span class="hljs-number">0</span>);<br>            map.put(num,count+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Map.Entry entry:map.entrySet())<br>        &#123;<br>            queue.add(entry);<br>            count++;<br>            <span class="hljs-keyword">if</span>(count&gt;k)<br>            &#123;<br>                queue.poll();<br>                count--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            ans[i]=queue.poll().getKey();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="57-和最小的K个数对"><a href="#57-和最小的K个数对" class="headerlink" title="57. 和最小的K个数对"></a>57. 和最小的K个数对</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16432592335371643259232981.png" alt="和最小的K个数对"></p><p>题解：题目要求和最小，因此我们要用大根堆，把超过范围的大数对推出去。</p><p>题目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k) &#123;<br>        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;&#123;<br>            <span class="hljs-comment">//大根堆</span><br>            <span class="hljs-keyword">int</span> first = o1[<span class="hljs-number">0</span>]+o1[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> second = o2[<span class="hljs-number">0</span>]+o2[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(first==second) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(first&gt;second) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//-1代表不交换</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//1代表交换</span><br>        &#125;);<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len1 = nums1.length;<br>        <span class="hljs-keyword">int</span> len2 =nums2.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len1;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;len2;j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>                tmp[<span class="hljs-number">0</span>]=nums1[i];<br>                tmp[<span class="hljs-number">1</span>]=nums2[j];<br>                <span class="hljs-comment">// System.out.println(tmp[0]+&quot;  &quot;+tmp[1]);</span><br>                queue.add(tmp);<br>                count++;<br>                <span class="hljs-keyword">if</span>(count&gt;k)<br>                &#123;<br>                    queue.poll();<br>                    count--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; ret;<br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =size-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span>[] tmp = queue.poll();<br>            ret.add(tmp[<span class="hljs-number">0</span>]);<br>            ret.add(tmp[<span class="hljs-number">1</span>]);<br>            ans.add(<span class="hljs-number">0</span>,ret);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="58-实现前缀树"><a href="#58-实现前缀树" class="headerlink" title="58. 实现前缀树"></a>58. 实现前缀树</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434422578851643442257046.png" alt="实现前缀树"></p><p>题解：已经联系过很多次的，了解一种新的思想</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    TreeNode root;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;<br>        TreeNode[] children;<br>        <span class="hljs-keyword">boolean</span> isEnd;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">()</span></span>&#123;<br>            children = <span class="hljs-keyword">new</span> TreeNode[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TreeNode cur = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>        &#123;<br>            <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>)<br>                cur.children[idx]=<span class="hljs-keyword">new</span> TreeNode();<br>            <br>            cur = cur.children[idx];<br>        &#125;<br>        cur.isEnd=<span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TreeNode cur = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>        &#123;<br>            <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            cur=cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        TreeNode cur = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:prefix.toCharArray())<br>        &#123;<br>            <span class="hljs-keyword">int</span> idx = ch -<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            cur = cur.children[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-替换单词"><a href="#59-替换单词" class="headerlink" title="59. 替换单词"></a>59. 替换单词</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434423168851643442316789.png" alt="替换单词"></p><p>题解：先将<code>dictionary</code>组合成一颗前缀树，然后找sentence的前缀，如果找到的话，返回对应的前缀，如果找不到，返回本身。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        String[] strs=sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        Trie trie=<span class="hljs-keyword">new</span> Trie();<br>        <span class="hljs-keyword">for</span>(String str:dictionary)<br>        &#123;<br>            trie.insert(str);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(String str:strs)<br>        &#123;<br>            sb.append(trie.startWith(str)+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>        TreeNode root;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;<br>            <span class="hljs-keyword">boolean</span> isEnd;<br>            TreeNode[] children;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">()</span></span>&#123;<br>                children = <span class="hljs-keyword">new</span> TreeNode[<span class="hljs-number">26</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>            root = <span class="hljs-keyword">new</span> TreeNode();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            TreeNode cur =root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) cur.children[idx]=<span class="hljs-keyword">new</span> TreeNode();<br>                cur = cur.children[idx];<br>            &#125;<br>            cur.isEnd=<span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            TreeNode cur = root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                cur=cur.children[idx];<br>            &#125;<br>            <span class="hljs-keyword">return</span> cur.isEnd;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">startWith</span><span class="hljs-params">(String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            TreeNode cur = root;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> word;<br>                sb.append(ch);<br>                cur = cur.children[idx];<br>                <span class="hljs-keyword">if</span>(cur.isEnd==<span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> sb.toString();<br>            &#125;<br>            <span class="hljs-keyword">return</span> sb.toString();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="60-神奇的字典"><a href="#60-神奇的字典" class="headerlink" title="60 神奇的字典"></a>60 神奇的字典</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434426108851643442610544.png" alt="神奇的字典"></p><p>题解：这是最初始的版本，其实可以加一个替换次数的限制，如果超过替换次数，可以直接进行返回</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicDictionary</span> </span>&#123;<br>    Trie trie;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MagicDictionary</span><span class="hljs-params">()</span> </span>&#123;<br>        trie = <span class="hljs-keyword">new</span> Trie();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDict</span><span class="hljs-params">(String[] dictionary)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(String str:dictionary)<br>        &#123;<br>            trie.insert(str);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String searchWord)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> trie.search(searchWord);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>        TreeNode root;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">        </span>&#123;<br>            <span class="hljs-keyword">boolean</span> isEnd;<br>            TreeNode[] children;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            </span>&#123;<br>                children = <span class="hljs-keyword">new</span> TreeNode[<span class="hljs-number">26</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            root = <span class="hljs-keyword">new</span> TreeNode();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            TreeNode cur = root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch :word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) cur.children[idx] = <span class="hljs-keyword">new</span> TreeNode();<br>                cur = cur.children[idx];<br>            &#125;<br>            cur.isEnd = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>            TreeNode cur = root;<br>            <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-comment">// System.out.println((char)(&#x27;a&#x27;+idx));</span><br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(cur.children[i]!=<span class="hljs-keyword">null</span>)<br>                        &#123;<br>                            <span class="hljs-keyword">if</span>(searchChild(cur.children[i],word.substring(j+<span class="hljs-number">1</span>))==<span class="hljs-keyword">true</span>)<br>                            &#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//不为空也可以试一下替换</span><br>                    <span class="hljs-comment">// System.out.println((char)(&#x27;a&#x27;+idx));</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(i==idx) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span>(cur.children[i]!=<span class="hljs-keyword">null</span>)<br>                        &#123;<br>                            System.out.println((<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span>+i));<br>                            <span class="hljs-keyword">if</span>(searchChild(cur.children[i],word.substring(j+<span class="hljs-number">1</span>))==<span class="hljs-keyword">true</span>)<br>                            &#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                cur= cur.children[idx]; <br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchChild</span><span class="hljs-params">(TreeNode root, String word)</span></span><br><span class="hljs-function">        </span>&#123;<br>            TreeNode cur= root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-comment">// System.out.println(ch);</span><br>                <span class="hljs-keyword">int</span> idx = ch- <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                cur=cur.children[idx];<br>            &#125;<br>            <span class="hljs-keyword">return</span> cur.isEnd;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="61-最短的单词编码"><a href="#61-最短的单词编码" class="headerlink" title="61. 最短的单词编码"></a>61. 最短的单词编码</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434426488851643442648591.png" alt="最短单词编码"></p><p>题解：我的想法是把这些都加进去前缀树，然后统计下每条路径的长度，已经有几条路径。</p><p>更好的想法：我们其实可以排序一下，字符串长的放在前面，然后我们进行前缀匹配，匹配到了，就可以不用加上</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumLengthEncoding</span><span class="hljs-params">(String[] words)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, n = words.length;<br>        Trie root = <span class="hljs-keyword">new</span> Trie();<br>        Arrays.sort(words,(o1,o2)-&gt;o2.length()-o1.length());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>            String s = words[i];<br>            <span class="hljs-keyword">if</span>(!root.endsWith(s)) &#123;<br>                root.insert(s);<br>                res += s.length()+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>        Trie[] children;<br><br>        <span class="hljs-comment">/** Initialize your data structure here. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        &#125;<br>        <br>        <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>            Trie root = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=word.length()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">char</span> c = word.charAt(i);<br>                <span class="hljs-keyword">if</span>(root.children[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-keyword">null</span>) &#123;<br>                    root.children[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie();<br>                &#125;<br>                root = root.children[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">endsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>            Trie root = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=prefix.length()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">char</span> c = prefix.charAt(i);<br>                <span class="hljs-keyword">if</span>(root.children[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                root = root.children[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="62-单词之和"><a href="#62-单词之和" class="headerlink" title="62. 单词之和"></a>62. 单词之和</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434428008851643442800034.png" alt="单词之和"></p><p>题解：求和的时候，我们可以直接先把公共前缀找完，然后一个个往下遍历，遍历到叶子节点，就加上对应的值。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapSum</span> </span>&#123;<br>    Trie trie;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapSum</span><span class="hljs-params">()</span> </span>&#123;<br>        trie = <span class="hljs-keyword">new</span> Trie();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        trie.insert(key,val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> trie.find(prefix);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>        Trie[] children;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">boolean</span> isEnd;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>            children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word,<span class="hljs-keyword">int</span> number)</span></span><br><span class="hljs-function">        </span>&#123;<br>            Trie cur = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:word.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) cur.children[idx]=<span class="hljs-keyword">new</span> Trie();<br>                cur = cur.children[idx];<br>            &#125;<br>            cur.isEnd=<span class="hljs-keyword">true</span>;<br>            cur.val=number;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(String prefix)</span></span><br><span class="hljs-function">        </span>&#123;<br>            sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//先把前缀走完</span><br>            Trie cur = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:prefix.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.children[idx]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                cur=cur.children[idx];<br>            &#125;<br>            <span class="hljs-comment">//获取所有叶子节点的和</span><br>            dfsSum(cur);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">dfsSum</span><span class="hljs-params">(Trie p)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>            <span class="hljs-keyword">if</span>(p.isEnd==<span class="hljs-keyword">true</span>)<br>            &#123;<br>                sum+=p.val;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p.children[i]==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// System.out.println((char)(i+&#x27;a&#x27;));</span><br>                dfsSum(p.children[i]); <br>                <span class="hljs-comment">// System.out.println(ans);</span><br>                <span class="hljs-comment">// ans+=tmp;</span><br>            &#125;<br>            <span class="hljs-comment">// System.out.println(ans);</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="63-最大的异或"><a href="#63-最大的异或" class="headerlink" title="63 最大的异或"></a>63 最大的异或</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16434429578851643442956929.png" alt="最大的异或"></p><p>题解：我们可以把每个int类型的数字当成，32bit来查看，所以我们先把我们的int转换成32的bit字符串，然后我们从大大小比较，记住我们这边不可以从小到大比较，因为，选择了小的可能，后面可能出现更大的结果，因此我们都摊平到32,然后如果发现我们的前缀是1,那么我们就首先要找0,如果0不在，我们才要继续找，对于0也是一样的道理。</p><p>题解注意：代码超级超级乱的，唉，好好加油。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Trie trie = <span class="hljs-keyword">new</span> Trie();<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        trie.insert(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> ret =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)<br>        &#123;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k =<span class="hljs-number">31</span>;k&gt;=<span class="hljs-number">0</span>;k--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(((nums[i]&gt;&gt;k)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>) sb.append(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> sb.append(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-comment">// System.out.println(sb.toString());</span><br>            String s =sb.toString();<br>            trie.find(nums[i],s,<span class="hljs-number">0</span>,trie);<br>            ret = Math.max(sum,ret);<br>            trie.insert(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>        Trie[] child;<br>        <span class="hljs-keyword">boolean</span> isEnd;<br>        <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>            child = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function">        </span>&#123;<br>            Trie cur =<span class="hljs-keyword">this</span>;<br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(((num&gt;&gt;i)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>) sb.append(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> sb.append(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-comment">// System.out.println(sb.toString());</span><br>            String s =sb.toString();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch:s.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">int</span> idx = ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(cur.child[idx]==<span class="hljs-keyword">null</span>) cur.child[idx] = <span class="hljs-keyword">new</span> Trie();<br>                cur=cur.child[idx];<br>            &#125;<br>            cur.isEnd=<span class="hljs-keyword">true</span>;<br>            cur.value=num;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,String s,<span class="hljs-keyword">int</span> idx,Trie trie)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(trie==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>            <span class="hljs-keyword">if</span>(trie.isEnd==<span class="hljs-keyword">true</span>)<br>            &#123;<br>                sum = Math.max(sum,num^trie.value);<br>                <span class="hljs-comment">// System.out.println(sum);</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(idx&lt;s.length()&amp;&amp;s.charAt(idx)==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx+<span class="hljs-number">1</span>,trie.child[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">0</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx+<span class="hljs-number">1</span>,trie.child[<span class="hljs-number">0</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(idx&lt;s.length()&amp;&amp;s.charAt(idx)==<span class="hljs-string">&#x27;1&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">0</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx+<span class="hljs-number">1</span>,trie.child[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx+<span class="hljs-number">1</span>,trie.child[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(idx==s.length())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx,trie.child[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(trie.child[<span class="hljs-number">0</span>]!=<span class="hljs-keyword">null</span>) find(num,s,idx,trie.child[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="64-查找插入位置"><a href="#64-查找插入位置" class="headerlink" title="64. 查找插入位置"></a>64. 查找插入位置</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16435302368031643530235965.png" alt="查找插入位置"></p><p>题解：二分，缩小到一定范围直接暴力</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-comment">// System.out.println(left+&quot; &quot;+right);</span><br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>||right==left)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[right]==target) <span class="hljs-keyword">return</span> right;<br>                <span class="hljs-keyword">if</span>(nums[left]==target) <span class="hljs-keyword">return</span> left;<br>                <span class="hljs-keyword">if</span>(target&lt;nums[left]) <span class="hljs-keyword">return</span> left;<br>                <span class="hljs-keyword">if</span>(nums[right]&gt;target) <span class="hljs-keyword">return</span> right;<br>                <span class="hljs-keyword">if</span>(nums[right]&lt;target) <span class="hljs-keyword">return</span> right+<span class="hljs-number">1</span>; <br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>            &#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>            &#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="65-山峰数组的顶部"><a href="#65-山峰数组的顶部" class="headerlink" title="65. 山峰数组的顶部"></a>65. 山峰数组的顶部</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16435303578031643530356968.png" alt="山峰数组的顶部"></p><p>题解：根据左右判断是在左侧山峰还是在右侧山峰</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = arr.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(right-left&lt;=<span class="hljs-number">2</span>)<br>            &#123;<br>               <span class="hljs-keyword">if</span>(arr[left]&gt;arr[left+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> left;<br>               <span class="hljs-keyword">if</span>(arr[left+<span class="hljs-number">1</span>]&gt;arr[right]) <span class="hljs-keyword">return</span> left+<span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">return</span> right; <br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//判断是右侧的山峰</span><br>            <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                right=mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="66-排序数组中只出现一次的数字"><a href="#66-排序数组中只出现一次的数字" class="headerlink" title="66. 排序数组中只出现一次的数字"></a>66. 排序数组中只出现一次的数字</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16435304878041643530487065.png" alt="排序数组中只出现一次的数字"></p><p>题解：根据所在位置的奇偶性，以及左右的相等关系收缩方向</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(left-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(nums[left]==nums[left-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[right];<br>                    <span class="hljs-keyword">return</span> nums[left];<br>                &#125;<br>                <span class="hljs-keyword">return</span> nums[left];<br>                <br>            &#125;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]!=nums[left+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[left];<br>                <span class="hljs-keyword">return</span> nums[right];<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==nums[mid-<span class="hljs-number">1</span>]&amp;&amp;nums[mid]!=nums[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-comment">//如果是奇数</span><br>                <span class="hljs-comment">//收缩</span><br>                <span class="hljs-keyword">if</span>(mid%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">//代表前面正常</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    right=mid-<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//如果是偶数</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]!=nums[mid-<span class="hljs-number">1</span>]&amp;&amp;nums[mid]==nums[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-comment">//如果是奇数</span><br>                <span class="hljs-comment">//如果是偶数</span><br>                <span class="hljs-keyword">if</span>(mid%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">//代表正常</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    right=mid-<span class="hljs-number">1</span>;<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]!=nums[mid-<span class="hljs-number">1</span>]&amp;&amp;nums[mid]!=nums[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">return</span> nums[mid];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="67-按权重生成随机数"><a href="#67-按权重生成随机数" class="headerlink" title="67. 按权重生成随机数"></a>67. 按权重生成随机数</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16436448196821643644819220.png" alt="按权重生成随机数"></p><p>题解:统计前缀和生成随机数区域，，二分查找随机生成的target落在何处</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] sum;<br>    <span class="hljs-keyword">int</span> total;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w)</span> </span>&#123;<br>        sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[w.length];<br>        total=<span class="hljs-number">0</span>;<br>        sum[<span class="hljs-number">0</span>]=w[<span class="hljs-number">0</span>];<br>        total+=w[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;w.length;i++)<br>        &#123;<br>            sum[i]=sum[i-<span class="hljs-number">1</span>]+w[i];<br>            total+=w[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> target = (<span class="hljs-keyword">int</span>)(Math.random()*total);<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = sum.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(left==right)<br>            &#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(target&gt;=sum[left]&amp;&amp;target&lt;sum[right]) <span class="hljs-keyword">return</span> right;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid=right+(left-right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// System.out.println(left+&quot; &quot;+mid+&quot; &quot;+right+&quot; target:&quot;+total);</span><br>            <span class="hljs-keyword">if</span>(target&gt;=sum[mid]&amp;&amp;target&lt;sum[mid+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&gt;sum[mid])<br>            &#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;sum[mid])<br>            &#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="68-求平方根"><a href="#68-求平方根" class="headerlink" title="68.求平方根"></a>68.求平方根</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16436449506851643644950483.png" alt="求平方根"></p><p>题解:二分查找下界</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =x;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(left==right) <span class="hljs-keyword">return</span> left;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right&lt;=x/right) <span class="hljs-keyword">return</span> right;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (right-left)/<span class="hljs-number">2</span>+left;<br>            <span class="hljs-keyword">if</span>(mid&gt;x/mid)<br>            &#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid&lt;x/mid)<br>            &#123;<br>                left=mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid==x/mid)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="69-狒狒吃香蕉"><a href="#69-狒狒吃香蕉" class="headerlink" title="69. 狒狒吃香蕉"></a>69. 狒狒吃香蕉</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16436450046841643645004386.png" alt="狒狒吃香蕉"></p><p>题解:二分查找答案，然后判断答案是否符合题目要求，大于h或者是小于h，然后缩小查找范围。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//找到最大的香蕉</span><br>        <span class="hljs-keyword">int</span> right =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;piles.length;i++)<br>        &#123;<br>            right=Math.max(piles[i],right);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(right==left) <span class="hljs-keyword">return</span> left;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(find(h,piles,left)&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> right;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (right-left)/<span class="hljs-number">2</span>+left;<br>            <span class="hljs-keyword">int</span> ans = find(h,piles,mid);<br>            <span class="hljs-comment">// System.out.println(left+&quot;  &quot;+mid+&quot;   &quot;+right+&quot; &quot;+ans);</span><br>            <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                right=mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(find(h,piles,mid-<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> mid-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h,<span class="hljs-keyword">int</span>[] piles,<span class="hljs-keyword">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">double</span> total=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> pile:piles)<br>        &#123;<br>            total+=Math.ceil(pile*<span class="hljs-number">1.0</span>/value*<span class="hljs-number">1.0</span>);<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(&quot;total:&quot;+total);</span><br>        <span class="hljs-keyword">if</span>(total&gt;h) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(total==h) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="70-合并区间"><a href="#70-合并区间" class="headerlink" title="70. 合并区间"></a>70. 合并区间</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16437369149961643736914427.png" alt="合并区间"></p><p>题解:先排序，然后迭代合并</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span>(intervals.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> intervals;<br>        <span class="hljs-keyword">int</span> m=intervals.length;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> R = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span>(i+<span class="hljs-number">1</span>&lt;m&amp;&amp;R&gt;=intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>            &#123;<br>                R=Math.max(R,intervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">int</span>[] tmp =&#123;L,R&#125;;<br>            ans.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="71-数组相对排序"><a href="#71-数组相对排序" class="headerlink" title="71. 数组相对排序"></a>71. 数组相对排序</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16437370059961643737005126.png" alt="数组相对排序"></p><p>题解:使用一个map存放数据</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] relativeSortArray(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;arr2.length;i++)<br>        &#123;<br>            map.put(arr2[i],i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr1.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr1.length;j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> n1=map.getOrDefault(arr1[i],Integer.MAX_VALUE);<br>                <span class="hljs-keyword">int</span> n2=map.getOrDefault(arr1[j],Integer.MAX_VALUE);<br>                <span class="hljs-keyword">if</span>(n1==Integer.MAX_VALUE&amp;&amp;n2==Integer.MAX_VALUE)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(arr1[i]&lt;=arr1[j]) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">int</span> tmp = arr1[i];<br>                    arr1[i]=arr1[j];<br>                    arr1[j]=tmp;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(n1&lt;=n2) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">int</span> tmp = arr1[i];<br>                arr1[i]=arr1[j];<br>                arr1[j]=tmp;<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> arr1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="72-数组中第k大的数字"><a href="#72-数组中第k大的数字" class="headerlink" title="72. 数组中第k大的数字"></a>72. 数组中第k大的数字</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438907234441643890722575.png" alt="数组中第k大的数字"></p><p>题解:排序完直接返回，快速排序的过程中，可以边查找第k大，时间复杂度小于<code>nlog(n)</code></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> find(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,nums.length+<span class="hljs-number">1</span>-k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> tail=partitation(nums,l,r);<br>            <span class="hljs-comment">// System.out.println(l+&quot;    r:&quot;+r+&quot;       &quot;+(tail-l)+&quot; &quot;+k);</span><br>            <span class="hljs-keyword">if</span>(tail-l+<span class="hljs-number">1</span>==k) <span class="hljs-keyword">return</span> nums[tail];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tail-l+<span class="hljs-number">1</span>&lt;k) <span class="hljs-keyword">return</span> find(nums,tail+<span class="hljs-number">1</span>,r,k-(tail-l+<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> find(nums,l,tail-<span class="hljs-number">1</span>,k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partitation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> l ,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> i =l;<br>        <span class="hljs-keyword">int</span> j =r;<br>        <span class="hljs-keyword">int</span> pivoit = nums[l];<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[j]&gt;=pivoit)<br>            &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;nums[i]&lt;=pivoit)<br>            &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            nums[i]=nums[j];<br>            nums[j]=tmp;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = nums[i];<br>        nums[i]=nums[l];<br>        nums[l]=tmp;<br>        <span class="hljs-comment">// for(int k =0;k&lt;nums.length;k++) System.out.print(nums[k]+&quot; &quot;);</span><br>        <span class="hljs-comment">// System.out.println();</span><br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="73-链表排序"><a href="#73-链表排序" class="headerlink" title="73. 链表排序"></a>73. 链表排序</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438908964571643890895508.png" alt="链表排序"></p><p>题解:归并排序，查找链表的中间断开，合并两个链表</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>||head.next==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode mid = split(head);<br>        ListNode p = sortList(head);<br>        ListNode q = sortList(mid);<br>        <span class="hljs-keyword">return</span> merge(p,q);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">split</span><span class="hljs-params">(ListNode head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode slow = head,fast = head.next;<br><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)<br>        &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br><br>        ListNode mid = slow.next;<br>        slow.next = <span class="hljs-keyword">null</span>;           <span class="hljs-comment">//断尾</span><br><br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode p,ListNode q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode head = dummy;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>&amp;&amp;q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p.val&lt;=q.val)<br>            &#123;<br>                head.next =p;<br>                head = head.next;<br>                p = p.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                head.next = q;<br>                head= head.next;<br>                q= q.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            head.next =p;<br>            head =head.next;<br>            p=p.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            head.next = q;<br>            head=head.next;<br>            q = q.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="74-合并排序链表"><a href="#74-合并排序链表" class="headerlink" title="74. 合并排序链表"></a>74. 合并排序链表</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438911154441643891115367.png" alt="合并排序链表"></p><p>题解:分治方法合并链表，当只剩两个链表进行合并，然后返回。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,lists.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// System.out.println(left+&quot;  &quot;+right);</span><br>        <span class="hljs-keyword">if</span>(lists.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(left&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(left==right) <span class="hljs-keyword">return</span> lists[left];<br>        <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">//只剩两个，进行普通链表的合并</span><br>            ListNode L = lists[left];<br>            ListNode R = lists[right];<br>            <span class="hljs-keyword">return</span> mergeTwoList(L,R);<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid= (left+right)/<span class="hljs-number">2</span>;<br>        ListNode L=merge(lists,left,mid);<br>        ListNode R=merge(lists,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> mergeTwoList(L,R);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoList</span><span class="hljs-params">(ListNode p,ListNode q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode h = dummy;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>&amp;&amp;q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p.val&lt;=q.val)<br>            &#123;<br>                h.next=p;<br>                h=h.next;<br>                p=p.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                h.next = q;<br>                h=h.next;<br>                q=q.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            h.next= p;<br>            h = h.next;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-keyword">null</span>)<br>        &#123;<br>            h.next = q;<br>            h=h.next;<br>            q = q.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="75-所有子集"><a href="#75-所有子集" class="headerlink" title="75. 所有子集"></a>75. 所有子集</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438912664461643891266116.png" alt="所有子集"></p><p>题解:选择和不选择，回溯法进行解决，选择或者不选择</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(ans,res,nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; ans ,List&lt;Integer&gt; res,<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==nums.length)<br>        &#123;<br>            <span class="hljs-comment">//</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//选择</span><br>        res.add(nums[idx]);<br>        dfs(ans,res,nums,idx+<span class="hljs-number">1</span>);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//不选择</span><br>        dfs(ans,res,nums,idx+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="76-含有k个元素的组合"><a href="#76-含有k个元素的组合" class="headerlink" title="76. 含有k个元素的组合"></a>76. 含有k个元素的组合</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438913734481643891372594.png" alt="含有k个元素的组合"></p><p>题解:同上</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(<span class="hljs-number">0</span>,n,<span class="hljs-number">1</span>,k,ans,res);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">int</span> number,<span class="hljs-keyword">int</span> idx,<span class="hljs-keyword">int</span> k,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(count==k)<br>        &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(idx==number+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//选择</span><br>        res.add(idx);<br>        dfs(count+<span class="hljs-number">1</span>,number,idx+<span class="hljs-number">1</span>,k,ans,res);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        dfs(count,number,idx+<span class="hljs-number">1</span>,k,ans,res);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="77-允许重复选择元素的组合"><a href="#77-允许重复选择元素的组合" class="headerlink" title="77. 允许重复选择元素的组合"></a>77. 允许重复选择元素的组合</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16438922694471643892269308.png" alt="允许重复选择元素的组合"></p><p>题解：同上</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(ans,res,target,candidates,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; res,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(count==target)<br>        &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&gt;target||idx==candidates.length) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//选择</span><br>        res.add(candidates[idx]);<br>        dfs(ans,res,target,candidates,count+candidates[idx],idx);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        dfs(ans,res,target,candidates,count,idx+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="78-含有重复元素集合的组合"><a href="#78-含有重复元素集合的组合" class="headerlink" title="78. 含有重复元素集合的组合"></a>78. 含有重复元素集合的组合</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16439627889081643962788052.png" alt="含有重复元素集合的组合"></p><p>题解:先对整个数组进行排序，然后利用一个标识位传递参数，如果没有添加本位的元素，则isAdd为false，如果添加了，isAdd为true。那么我们如何避免添加重复的元素呢，其实只需要前面的元素没添加过，并且当前的位置的元素和前一个位置的元素相等，那么我们便可以得到结论。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(candidates);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[candidates.length];<br>        <span class="hljs-comment">// for(int i =0;i&lt;candidates.length;i++) System.out.println(candidates[i]);</span><br>        dfs(ans,res,candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; res,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">int</span> idx,<span class="hljs-keyword">boolean</span> isAdd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// System.out.println(res+&quot;  idx:&quot;+idx+&quot;  sum:&quot;+sum);</span><br>        <span class="hljs-keyword">if</span>(sum==target)<br>        &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target||idx==candidates.length) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(!isAdd&amp;&amp;idx&gt;=<span class="hljs-number">1</span>&amp;&amp;candidates[idx]==candidates[idx-<span class="hljs-number">1</span>])<br>        &#123;<br>            dfs(ans,res,candidates,target,sum,idx+<span class="hljs-number">1</span>,<span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        res.add(candidates[idx]);<br>        dfs(ans,res,candidates,target,sum+candidates[idx],idx+<span class="hljs-number">1</span>,<span class="hljs-keyword">true</span>);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        dfs(ans,res,candidates,target,sum,idx+<span class="hljs-number">1</span>,<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="79-没有重复元素集合的全排列"><a href="#79-没有重复元素集合的全排列" class="headerlink" title="79. 没有重复元素集合的全排列"></a>79. 没有重复元素集合的全排列</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16439629819091643962981510.png" alt="没有重复元素集合的全排列"></p><p>题解:全排列的问题选择递归加上for循环进行迭代</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    List&lt;Integer&gt; res;<br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        ans= <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        visited= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length]; <br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.size()==nums.length) ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]) <span class="hljs-keyword">continue</span>;<br>            res.add(nums[i]);<br>            visited[i]=<span class="hljs-keyword">true</span>;<br>            dfs(nums);<br>            visited[i]=<span class="hljs-keyword">false</span>;<br>            res.remove(res.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="80-含有重复元素集合的全排列"><a href="#80-含有重复元素集合的全排列" class="headerlink" title="80. 含有重复元素集合的全排列"></a>80. 含有重复元素集合的全排列</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16439631559051643963155183.png" alt="含有重复元素集合的全排列"></p><p>题解:前一个元素没有使用过，然后并且当前元素和前一个元素是一样的，那么就不进行添加。</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    List&lt;Integer&gt; res;<br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.size()==nums.length) ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]||(i&gt;=<span class="hljs-number">1</span>&amp;&amp;!visited[i-<span class="hljs-number">1</span>]&amp;&amp;nums[i]==nums[i-<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>; <br>            res.add(nums[i]);<br>            visited[i]=<span class="hljs-keyword">true</span>;<br>            dfs(nums);<br>            res.remove(res.size()-<span class="hljs-number">1</span>);<br>            visited[i]=<span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="81-生成匹配的括号"><a href="#81-生成匹配的括号" class="headerlink" title="81. 生成匹配的括号"></a>81. 生成匹配的括号</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16440874480801644087447835.png" alt="生成匹配的括号"></p><p>题解：对于每个层次，我们可以选择<code>(</code>和<code>)</code>，然后每次进行选择，选择完成之后，我们需要对现场进行恢复。递归结束的条件为，当我们的右括号的数量大于左括号的数量时，我们可以判断当前的添加的括号是非法的，所以我们得进行返回，当左括号的数量和右括号的数量都等于n，代表我们的选择结束，将当前结果进行保存。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; ans;<br>    StringBuilder sb; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        ans = <span class="hljs-keyword">new</span>  ArrayList&lt;&gt;();<br>        dfs(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">int</span> leftParen,<span class="hljs-keyword">int</span> rightParen)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//如果count&lt;0匹配出错</span><br>        <span class="hljs-keyword">if</span>(count&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//如果左括号h或者右括号选择到n个，返回</span><br>        <span class="hljs-keyword">if</span>(leftParen&gt;n||rightParen&gt;n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(leftParen==n&amp;&amp;rightParen==n)<br>        &#123;<br>            String s = sb.toString();<br>            ans.add(s);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//选择左括号</span><br>        sb.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(n,count+<span class="hljs-number">1</span>,leftParen+<span class="hljs-number">1</span>,rightParen);<br>        sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//选择右括号</span><br>        sb.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        dfs(n,count-<span class="hljs-number">1</span>,leftParen,rightParen+<span class="hljs-number">1</span>);<br>        sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-分割回文子字符串"><a href="#82-分割回文子字符串" class="headerlink" title="82. 分割回文子字符串"></a>82. 分割回文子字符串</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16440877270801644087726785.png" alt="分割回文子字符串"></p><p>题解：本题，类似进行分割，对于每个元素，我们可以选择加入前面，或者自己成为一个，如果当前的字符串不是回文字符串，那么我们需要将当前字符加入，而不可以自己额外起一个分割。</p><p>注意：List<List<Integer>&gt; 这种直接进行new ArrayList&lt;&gt;()的复制，会直接把引用复制过来，因此我们需要对每一个进行复制。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;StringBuilder&gt;&gt; ans;<br>    List&lt;StringBuilder&gt; sbs;<br>    <span class="hljs-keyword">public</span> String[][] partition(String s) &#123;<br>        sbs= <span class="hljs-keyword">new</span>   ArrayList&lt;&gt;();<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(s.toCharArray(),<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// System.out.println(ans);</span><br>        String[][] ret= <span class="hljs-keyword">new</span> String[ans.size()][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;ans.size();i++)<br>        &#123;<br>            String[] tmp = <span class="hljs-keyword">new</span> String[ans.get(i).size()];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;ans.get(i).size();j++)<br>            &#123;<br>                tmp[j]=ans.get(i).get(j).toString();<br>            &#125;<br>            ret[i]=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str,<span class="hljs-keyword">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// System.out.println(sbs+&quot; idx:&quot;+idx);</span><br>        <span class="hljs-keyword">if</span>(idx==str.length&amp;&amp;checkPalindromeIsTrue(sbs.get(sbs.size()-<span class="hljs-number">1</span>).toString()))<br>        &#123;<br>            <span class="hljs-comment">// System.out.println(sbs+&quot; 我添加进来  idx:&quot;+idx+sbs);</span><br>            List&lt;StringBuilder&gt; tmps = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(StringBuilder sb:sbs)<br>            &#123;<br>                tmps.add(<span class="hljs-keyword">new</span> StringBuilder(sb));<br>            &#125;<br>            ans.add(tmps);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(idx==str.length) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(sbs.size()==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//不和前面的合在一起</span><br>            sbs.add(<span class="hljs-keyword">new</span> StringBuilder().append(str[idx]));<br>            dfs(str,idx+<span class="hljs-number">1</span>);<br>            sbs.remove(sbs.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            StringBuilder sb = sbs.get(sbs.size()-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(sbs.size()&gt;=<span class="hljs-number">1</span>&amp;&amp;!checkPalindromeIsTrue(sbs.get(sbs.size()-<span class="hljs-number">1</span>).toString()))<br>            &#123;<br>                <span class="hljs-comment">//不是回文，继续添加</span><br>                <span class="hljs-comment">//和前面和在一起</span><br>                sb.append(str[idx]);<br>                dfs(str,idx+<span class="hljs-number">1</span>);<br>                sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                    <span class="hljs-comment">//和前面和在一起</span><br>                sb.append(str[idx]);<br>                dfs(str,idx+<span class="hljs-number">1</span>);<br>                sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//不合前面和在一起</span><br>                sbs.add(<span class="hljs-keyword">new</span> StringBuilder().append(str[idx]));<br>                dfs(str,idx+<span class="hljs-number">1</span>);<br>                sbs.remove(sbs.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPalindromeIsTrue</span><span class="hljs-params">(String s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = s.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(left)!=s.charAt(right))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="87-复原IP"><a href="#87-复原IP" class="headerlink" title="87. 复原IP"></a>87. 复原IP</h2><p>题目：<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16440878290791644087828318.png" alt="复原ip"></p><p>题解：每一个数字可以选择和前一个ip组合，也可以选择自己变成一个个体，但是如果前面的是单独的0个体，那么我们就得自己起一个独立的个体，紧接着是判断递归的结束条件，每个ip只能是0-255.</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; ans;<br>    List&lt;Integer&gt; ip;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ip = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(s.toCharArray(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str,<span class="hljs-keyword">int</span> idx,<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">boolean</span> preHasOneZero)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// System.out.println(ip);</span><br>        <span class="hljs-keyword">if</span>(ip.size()&gt;<span class="hljs-number">0</span>&amp;&amp;ip.get(ip.size()-<span class="hljs-number">1</span>)&gt;<span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">4</span>)<br>        &#123;<br>            <span class="hljs-comment">//格子已经超过4个</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">4</span>&amp;&amp;idx==str.length)<br>        &#123;<br>            <span class="hljs-comment">//ip转化成字符串</span><br>            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(Integer num:ip)<br>            &#123;<br>                sb.append(num+<span class="hljs-string">&quot;.&quot;</span>);<br>            &#125;<br>            sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(idx&gt;=str.length) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//如果当前数字是0,并且ip数组还没有放入元素</span><br>        <span class="hljs-keyword">if</span>(str[idx]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;count==<span class="hljs-number">0</span>)<br>        &#123;<br>            ip.add(<span class="hljs-number">0</span>);<br>            dfs(str,idx+<span class="hljs-number">1</span>,count+<span class="hljs-number">1</span>,<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[idx]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(preHasOneZero)<br>            &#123;<br>                <span class="hljs-comment">//有前导0</span><br>                <span class="hljs-comment">//需要单独成占一个位置</span><br>                ip.add(<span class="hljs-number">0</span>);<br>                dfs(str,idx+<span class="hljs-number">1</span>,count+<span class="hljs-number">1</span>,<span class="hljs-keyword">true</span>);<br>                ip.remove(ip.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//如果前面没有单独的0</span><br>                <span class="hljs-comment">//那么我有两种选择，加入到前面的数字，虽然可能会大于</span><br>                <span class="hljs-comment">//我也可以选择自己占住一个格子</span><br>                ip.add(<span class="hljs-number">0</span>);<br>                dfs(str,idx+<span class="hljs-number">1</span>,count+<span class="hljs-number">1</span>,<span class="hljs-keyword">true</span>);<br>                ip.remove(ip.size()-<span class="hljs-number">1</span>);<br><br>                <span class="hljs-comment">//选择加入前面的格子</span><br>                ip.set(ip.size()-<span class="hljs-number">1</span>,ip.get(ip.size()-<span class="hljs-number">1</span>)*<span class="hljs-number">10</span>);<br>                dfs(str,idx+<span class="hljs-number">1</span>,count,<span class="hljs-keyword">false</span>);<br>                ip.set(ip.size()-<span class="hljs-number">1</span>,ip.get(ip.size()-<span class="hljs-number">1</span>)/<span class="hljs-number">10</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br><br>            <span class="hljs-keyword">if</span>(preHasOneZero)<br>            &#123;<br>                <span class="hljs-comment">//单独自己一个格子</span><br>                ip.add(str[idx]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                dfs(str,idx+<span class="hljs-number">1</span>,count+<span class="hljs-number">1</span>,<span class="hljs-keyword">false</span>);<br>                ip.remove(ip.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(ip.size()!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">//和前面的和在一起</span><br>                    <span class="hljs-comment">//选择加入前面的格子</span><br>                    ip.set(ip.size()-<span class="hljs-number">1</span>,ip.get(ip.size()-<span class="hljs-number">1</span>)*<span class="hljs-number">10</span>+(str[idx]-<span class="hljs-string">&#x27;0&#x27;</span>));<br>                    dfs(str,idx+<span class="hljs-number">1</span>,count,<span class="hljs-keyword">false</span>);<br>                    ip.set(ip.size()-<span class="hljs-number">1</span>,ip.get(ip.size()-<span class="hljs-number">1</span>)/<span class="hljs-number">10</span>);<br>                &#125;<br>                <span class="hljs-comment">//单独自己一个格子</span><br>                ip.add(str[idx]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                dfs(str,idx+<span class="hljs-number">1</span>,count+<span class="hljs-number">1</span>,<span class="hljs-keyword">false</span>);<br>                ip.remove(ip.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-爬楼梯的最少成本"><a href="#88-爬楼梯的最少成本" class="headerlink" title="88. 爬楼梯的最少成本"></a>88. 爬楼梯的最少成本</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16441559034961644155902642.png" alt="爬楼梯的最少成本"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>注意定义我们的dp函数是干什么的，<code>dp[1]</code>代表到1层楼顶的代价为多少，<code>dp[0]</code>代表到0层楼顶的代价为多少。我们到达当前楼顶的最低代价，为到达低一层楼的最低代价加上该层楼向上走一层的代价与到达低二层楼的最低代价加上该层楼向上走两层的代价之间的较小值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[cost.length+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;=cost.length;i++)<br>        &#123;<br>            dp[i]=Math.min(dp[i-<span class="hljs-number">1</span>]+cost[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+cost[i-<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="89-房屋盗窃"><a href="#89-房屋盗窃" class="headerlink" title="89. 房屋盗窃"></a>89. 房屋盗窃</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16441562765151644156276487.png" alt="房屋盗窃"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>偷这家，然后前一家不能偷，考虑偷前前家的最大利润加上当前家的最大价值。不偷这家，利润就是偷到前一家的最大利润。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//只有一个房子的最大收益是直接偷了</span><br>        dp[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-comment">//可以选择偷这家的，那么前一家就不可以偷，算前两家的最大利益</span><br>            <span class="hljs-comment">//不偷这家，利润是前面的最大</span><br>            dp[i+<span class="hljs-number">1</span>]=Math.max(dp[i-<span class="hljs-number">1</span>]+nums[i],dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="90-环形房屋盗窃"><a href="#90-环形房屋盗窃" class="headerlink" title="90. 环形房屋盗窃"></a>90. 环形房屋盗窃</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16441564234951644156422758.png" alt="环形房屋盗窃"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>偷第一个不偷最后一个和不偷第一个偷最后一个</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//第一家偷</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">2</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            dp[i+<span class="hljs-number">1</span>]=Math.max(dp[i-<span class="hljs-number">1</span>]+nums[i],dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = dp[nums.length-<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//不偷第一家，可以偷最后一家</span><br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">2</span>]=nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;nums.length;i++)<br>        &#123;<br>            dp[i+<span class="hljs-number">1</span>]=Math.max(dp[i-<span class="hljs-number">1</span>]+nums[i],dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(tmp,dp[nums.length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="91-粉刷房子"><a href="#91-粉刷房子" class="headerlink" title="91. 粉刷房子"></a>91. 粉刷房子</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16442512720871644251272064.png" alt="粉刷房子"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>现在所处于的房子要刷红色，那么我只能是前面房子的绿色和蓝色转移过来。<br>其他同理</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] costs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[costs.length+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//粉刷第0间房子的最低价格为0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;costs.length;i++)<br>        &#123;<br>            dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=Math.min(dp[i][<span class="hljs-number">1</span>]+costs[i][<span class="hljs-number">1</span>],dp[i][<span class="hljs-number">2</span>]+costs[i][<span class="hljs-number">2</span>]);<br>            dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=Math.min(dp[i][<span class="hljs-number">0</span>]+costs[i][<span class="hljs-number">0</span>],dp[i][<span class="hljs-number">2</span>]+costs[i][<span class="hljs-number">2</span>]);<br>            dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=Math.min(dp[i][<span class="hljs-number">0</span>]+costs[i][<span class="hljs-number">0</span>],dp[i][<span class="hljs-number">1</span>]+costs[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(Math.min(dp[dp.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[dp.length-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]),dp[dp.length-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="92-翻转字符"><a href="#92-翻转字符" class="headerlink" title="92. 翻转字符"></a>92. 翻转字符</h2><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16442513070461644251306439.png" alt="翻转字符"></p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>dp[i][0]函数代表i位置设置为0保持递增的最小翻转次数，如果当前字符是0，那么i位置为0保持增长的最小翻转次数为dp[i-1][0],i位置为1保持增长的最小翻转次数为Math.min(dp[i-1][0],dp[i-1][1])中最小值翻转一次。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//当前位置0保持递增的最小翻转次数</span><br>        <span class="hljs-comment">//翻转成1</span><br>        <span class="hljs-keyword">char</span>[] str= s.toCharArray();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;str.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=dp[i][<span class="hljs-number">0</span>];<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=Math.min(dp[i][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,dp[i][<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=dp[i][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=Math.min(dp[i][<span class="hljs-number">1</span>],dp[i][<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// for(int i =0;i&lt;dp.length;i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     System.out.println(dp[i][0]+&quot;   &quot;+dp[i][1]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> Math.min(dp[dp.length-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[dp.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93-最长的斐波那契子序列"><a href="#93-最长的斐波那契子序列" class="headerlink" title="93. 最长的斐波那契子序列"></a>93. 最长的斐波那契子序列</h2><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16442515990461644251598372.png" alt="最常的斐波那契子序列"></p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>对于子序列，对比最长上升子序列，最长上升子序列是一维的dp，为什么这边是2维的dp，dp[i][j]代表以arr[i]和arr[j]结尾的长度最大的斐波那契子序列。<br>双指针进行查找。dp[i][j]=dp[j][k]+1</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>       <span class="hljs-comment">//以当前元素结尾的最大的斐波那契数列大小</span><br>       <span class="hljs-keyword">int</span> n = arr.length;<br>       <span class="hljs-keyword">int</span> res =<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;n;i++)<br>       &#123;<br>           <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">int</span> right = i-<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span>(left&lt;right)<br>           &#123;<br>                <span class="hljs-keyword">int</span> sum = arr[left]+arr[right];<br>                <span class="hljs-keyword">if</span>(sum&lt;arr[i])<br>                    left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;arr[i])<br>                    right--;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[right][i]=dp[left][right]+<span class="hljs-number">1</span>;<br>                    res= Math.max(res,dp[right][i]);<br>                    left++;<br>                    right--;<br>                &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res&gt;<span class="hljs-number">0</span>?res+<span class="hljs-number">2</span>:<span class="hljs-number">0</span>; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-最少回文分割"><a href="#94-最少回文分割" class="headerlink" title="94. 最少回文分割"></a>94. 最少回文分割</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16443380198931644338019041.png" alt="最少回文分割"></p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>先利用二维的矩阵可以快速判断是否是回文数组，如果<code>[0,i]</code>是回文数组，那么，我们先让<code>dp[i]</code>代表到位置<code>i</code>我们最少需要分割1次，为了增加统一性，如果不是回文的话，我们遍历<code>0,1,2,3,...,i</code>，如果<code>isPal[j,i]</code>是回文字符串，那么我们需要的分割次数就是<code>dp[j-1]+1</code>，遍历这些，取出最小的值就可以。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n =s.length();<br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">int</span> m = s.length();<br>        <span class="hljs-keyword">boolean</span>[][] isPal = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; ++j)&#123;<br>            <span class="hljs-comment">//要纪录所有包含自己单个字母的情况，所以两头都是闭区间</span><br>            <span class="hljs-comment">//首尾相等是必要条件，再加一个要么二者间夹的字母小于2  或者 二者间的字段确定是回文，构成充分条件。</span><br>                <span class="hljs-keyword">if</span>(str[i] == str[j] &amp;&amp; (i-j&lt;=<span class="hljs-number">2</span> || isPal[j+<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]))<br>                <span class="hljs-comment">//这里查找isPal是能确定i-1时已经存储了结果</span><br>                    isPal[j][i] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;dp.length;i++)<br>        &#123;<br>            dp[i]=dp.length;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;str.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(isPal[<span class="hljs-number">0</span>][i]) dp[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(isPal[j][i]) dp[i]=Math.min(dp[i],dp[j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="95-最长公共子序列"><a href="#95-最长公共子序列" class="headerlink" title="95 . 最长公共子序列"></a>95 . 最长公共子序列</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16443383148931644338314422.png" alt="最长公共子序列"></p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j]</code>代表以<code>text1[i]</code>和<code>text2[j]</code>结尾的公共子序列。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = text1.length();<br>        <span class="hljs-keyword">int</span> n =text2.length();<br>        <span class="hljs-keyword">char</span>[] str1 = text1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str2 = text2.toCharArray();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// for(int i=0;i&lt;=m;i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     dp[i][0]=i;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// for(int i=0;i&lt;=n;i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     dp[0][i]=i;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(str1[i]==str2[j])<br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=Math.max(dp[i+<span class="hljs-number">1</span>][j],dp[i][j+<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96-字符串交织"><a href="#96-字符串交织" class="headerlink" title="96. 字符串交织"></a>96. 字符串交织</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16443384958921644338495296.png" alt="字符串交织"></p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>[[不懂系列]]</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len1 =s1.length();<br>        <span class="hljs-keyword">int</span> len2 = s2.length();<br>        <span class="hljs-keyword">int</span> len3 = s3.length();<br>        <span class="hljs-keyword">char</span>[] str1 = s1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str2 = s2.toCharArray();<br>        <span class="hljs-keyword">char</span>[] str3 = s3.toCharArray();<br>        <span class="hljs-keyword">if</span>(len1+len2!=len3) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len1+<span class="hljs-number">1</span>][len2+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len1;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str1[i]==str3[i])<br>                dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len2;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str2[j]==str3[j])<br>                dp[<span class="hljs-number">0</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;len2;j++)<br>            &#123;<br>                <span class="hljs-keyword">char</span> a = str1[i];<br>                <span class="hljs-keyword">char</span> b = str2[j];<br>                <span class="hljs-keyword">char</span> c = str3[i+j+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(a==c&amp;&amp;b!=c)<br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j+<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(b==c&amp;&amp;a!=c)<br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i+<span class="hljs-number">1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(b==c&amp;&amp;a==c)<br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i+<span class="hljs-number">1</span>][j]||dp[i][j+<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="97-子序列的数目"><a href="#97-子序列的数目" class="headerlink" title="97. 子序列的数目"></a>97. 子序列的数目</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16444371149431644437114559.png" alt="子序列的数目"></p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16444371989421644437198682.png" alt="题解"></p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.length();<br>        <span class="hljs-keyword">int</span> n = t.length();<br>        <span class="hljs-keyword">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//t是空的字符串，空的字符串是任何字符串的字串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)<br>        &#123;<br>            dp[i][n]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">char</span> sChar = s.charAt(i);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>            &#123;   <br>                <span class="hljs-keyword">char</span> tChar =t.charAt(j);<br>                <span class="hljs-keyword">if</span>(sChar==tChar)<br>                &#123;<br>                    <span class="hljs-comment">//s[i:]和t[j:]匹配，或者不匹配</span><br>                    dp[i][j]=dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+dp[i+<span class="hljs-number">1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i][j]=dp[i+<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mDFS</span>(<span class="hljs-params">i, j</span>):</span><br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt; i:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(j &lt; <span class="hljs-number">0</span>)<br>            cnt = mDFS(i - <span class="hljs-number">1</span>, j)<br>            <span class="hljs-keyword">if</span> s[i] == t[j]:<br>                cnt += mDFS(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h2 id="98-路径数目"><a href="#98-路径数目" class="headerlink" title="98. 路径数目"></a>98. 路径数目</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16444374409431644437440518.png" alt="题目"></p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)<br>            dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;m;j++)<br>            dp[j][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)<br>            &#123;<br>                dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99-最小路径和"><a href="#99-最小路径和" class="headerlink" title="99. 最小路径和"></a>99. 最小路径和</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16444375509421644437550470.png" alt="最小路径和"></p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = grid.length;<br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>            dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]+grid[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>;j&lt;m;j++)<br>            dp[j][<span class="hljs-number">0</span>]=dp[j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+grid[j][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>;j&lt;n;j++)<br>            &#123;<br>                dp[i][j]=Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>])+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="100-三角中最小路径"><a href="#100-三角中最小路径" class="headerlink" title="100. 三角中最小路径"></a>100. 三角中最小路径</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16445134355021644513434655.png" alt="三角形最小路径"></p><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>从上往下，一直走</p><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m =triangle.size();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][m];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;m;i++)<br>            dp[i][<span class="hljs-number">0</span>]=dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+triangle.get(i).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> n = triangle.get(i).size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==n-<span class="hljs-number">1</span>)<br>                    dp[i][j]=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+triangle.get(i).get(j);<br>                <span class="hljs-keyword">else</span> <br>                    dp[i][j]=Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j])+triangle.get(i).get(j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans=Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;triangle.get(m-<span class="hljs-number">1</span>).size();i++)<br>        &#123;<br>            ans = Math.min(dp[m-<span class="hljs-number">1</span>][i],ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-分割等和子集"><a href="#101-分割等和子集" class="headerlink" title="101. 分割等和子集"></a>101. 分割等和子集</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16445136205031644513620269.png" alt="分割等和子集"></p><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>把原本的问题转化成两个，然后求和选几个元素和为sum的一半，变成01背包问题。</p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//求和</span><br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxnumber=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            sum+=nums[i];<br>            maxnumber=Math.max(maxnumber,nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>||nums.length==<span class="hljs-number">1</span>||maxnumber&gt;sum/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">boolean</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length][target+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> num = nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>;j&lt;=target;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=num)<br>                &#123;<br>                    <span class="hljs-comment">//可以选择，也可以不选择</span><br>                    dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]||dp[i-<span class="hljs-number">1</span>][j-num];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br><br>                    <span class="hljs-comment">//不选择</span><br>                    dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="102-加减的目标值"><a href="#102-加减的目标值" class="headerlink" title="102. 加减的目标值"></a>102. 加减的目标值</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16445138085021644513808021.png" alt="加减的目标值"></p><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>正数集合P,负数集合N   </p><p>有 <code>P-N=target</code> 并且<code>N=Sum-P</code>，因此<code>2P=sum+target</code>得到P就等于<code>(sum+target)/2</code>,表示选取元素，然后获得目标值。</p><h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)<br>        &#123;<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;target||(sum+target)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> m = nums.length;<br>        <span class="hljs-keyword">int</span> w =(sum+target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(w&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][w+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;=nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> num = nums[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=w;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=num)<br>                &#123;<br>                    dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i-<span class="hljs-number">1</span>][j-num];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i][j]+=dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][w];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-最少的找硬币的方案"><a href="#103-最少的找硬币的方案" class="headerlink" title="103. 最少的找硬币的方案"></a>103. 最少的找硬币的方案</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16445926680551644592667205.png" alt="最少的找硬币的个数"></p><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>完全背包，钱的数目在外面，然后遍历我们的<code>coins</code>数组</p><h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;=target;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;len;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&gt;=nums[j])<br>                &#123;<br>                    dp[i]+=dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-排列的数目"><a href="#104-排列的数目" class="headerlink" title="104. 排列的数目"></a>104. 排列的数目</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16445929720571644592971193.png" alt="排列的数目"></p><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>组成target等于0的情况有一种可能，因此<code>dp[0]=1</code>,</p><h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;=target;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;len;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&gt;=nums[j])<br>                &#123;<br>                    dp[i]+=dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-岛屿的最大面积"><a href="#105-岛屿的最大面积" class="headerlink" title="105. 岛屿的最大面积"></a>105. 岛屿的最大面积</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16446450587121644645057864.png" alt="岛屿的最大面积"></p><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>遇到1开始搜索，然后利用全局变量统计走了多少步</p><h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxArea=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> curArea =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> [][] visited;<br>    <span class="hljs-keyword">int</span>[][] dir=&#123;&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m =grid.length;<br>        <span class="hljs-keyword">int</span> n =grid[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[i][j])<br>                &#123;<br>                    curArea =<span class="hljs-number">0</span>;<br>                    dfs(grid,i,j);<br>                    maxArea =Math.max(curArea,maxArea);<br>                    <span class="hljs-comment">// System.out.println(maxArea);</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [][] grid,<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row&gt;=<span class="hljs-number">0</span>&amp;&amp;row&lt;grid.length<br>            &amp;&amp;column&gt;=<span class="hljs-number">0</span>&amp;&amp;column&lt;grid[<span class="hljs-number">0</span>].length<br>            &amp;&amp;!visited[row][column]<br>            &amp;&amp;grid[row][column]==<span class="hljs-number">1</span>)<br>            &#123;<br>                curArea++;<br>                visited[row][column]=<span class="hljs-keyword">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] d:dir)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x = column+d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> y= row+d[<span class="hljs-number">1</span>];<br>            dfs(grid,y,x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="106-二分图"><a href="#106-二分图" class="headerlink" title="106. 二分图"></a>106. 二分图</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16446451737121644645173463.png" alt="二分图"></p><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>图的着色问题，两个颜色，如果是没参观过的，那么赋值为和原本颜色不相同的，如果是已经参观过的，那么着色应该跟父节点的颜色相同，不然代表出错</p><h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">boolean</span> ok;<br>    <span class="hljs-keyword">boolean</span>[] color;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = graph.length;<br>        ok=<span class="hljs-keyword">true</span>;<br>        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i]) dfs(graph,i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ok;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph,<span class="hljs-keyword">int</span> w)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!ok) <span class="hljs-keyword">return</span> ;<br>        visited[w]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> node:graph[w])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[node])<br>            &#123;<br>                color[node]=!color[w];<br>                dfs(graph,node);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(color[node]==color[w]) ok=<span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="107-矩阵中的距离"><a href="#107-矩阵中的距离" class="headerlink" title="107. 矩阵中的距离"></a>107. 矩阵中的距离</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16446453387121644645338298.png" alt="矩阵中的距离"></p><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>将所有的0和在一起，然后类似于开始侵蚀旁边的，广度优先搜索。</p><h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] updateMatrix(<span class="hljs-keyword">int</span>[][] mat) &#123;<br>        <span class="hljs-keyword">int</span> m = mat.length;<br>        <span class="hljs-keyword">int</span> n =mat[<span class="hljs-number">0</span>].length;<br>        ans=  <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; q= <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    ans[i][j]=<span class="hljs-number">0</span>;<br>                    visited[i][j]=<span class="hljs-keyword">true</span>;<br>                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    ans[i][j]=Integer.MAX_VALUE;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] d = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span>[] head = q.poll();<br>            <span class="hljs-keyword">int</span> x =head[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> y = head[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] node:d)<br>            &#123;<br>                <span class="hljs-keyword">int</span> nx = x+node[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> ny=  y+node[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span>&amp;&amp;nx&lt;m&amp;&amp;ny&gt;=<span class="hljs-number">0</span>&amp;&amp;ny&lt;n&amp;&amp;!visited[nx][ny])<br>                &#123;<br>                    ans[nx][ny]=ans[x][y]+<span class="hljs-number">1</span>;<br>                    visited[nx][ny]=<span class="hljs-keyword">true</span>;<br>                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nx,ny&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="108-单词演变"><a href="#108-单词演变" class="headerlink" title="108 单词演变"></a>108 单词演变</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16447394271541644739426354.png" alt=""></p><h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><p>将每个字母看成可以向外扩展的，然后，但是向外扩展是有界限的，界限在我们的wordlist中，相当于给定区域，然后让你进行扩展，最短路径使用bfs</p><h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        Map&lt;String,Boolean&gt; stringVisted=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String word: wordList)<br>            stringVisted.put(word,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//如果没有包含结果，那么就是错误的。</span><br>        <span class="hljs-keyword">if</span>(!stringVisted.containsKey(endWord)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        q.add(beginWord);<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> hasFind=<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt; len;i++)<br>            &#123;<br>                String head= q.poll();<br>                <span class="hljs-keyword">if</span>(head.equals(endWord))<br>                &#123;<br>                    hasFind=<span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;head.length();k++)<br>                &#123;<br>                    <span class="hljs-comment">//对每个字符进行更改</span><br>                    <span class="hljs-comment">//拼接成为字符串</span><br>                    <span class="hljs-comment">//查看hash中是否有这个拼接起来的字符串</span><br>                    <span class="hljs-comment">//如果找到，并且没有被访问过</span><br>                    <span class="hljs-comment">//那么就加入队列</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)<br>                    &#123;<br>                        String str=head.substring(<span class="hljs-number">0</span>,k)+((<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span>+j))+head.substring(k+<span class="hljs-number">1</span>);<br>                        Boolean ans=stringVisted.get(str);<br>                        <span class="hljs-keyword">if</span>(ans!=<span class="hljs-keyword">null</span>&amp;&amp;ans==<span class="hljs-keyword">false</span>)<br>                        &#123;<br>                            q.add(str);<br>                            stringVisted.replace(str,<span class="hljs-keyword">true</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            count++;<br>            <span class="hljs-keyword">if</span>(hasFind) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasFind?count:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="109-开密码锁"><a href="#109-开密码锁" class="headerlink" title="109 开密码锁"></a>109 开密码锁</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16447395481541644739547424.png" alt=""></p><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>给定区间，四维，然后进行扩展，每次往外扩展一个格子，如果找到，需要跳出循环。</p><h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;<br>        Set&lt;Integer&gt; set =<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String s:deadends)<br>        &#123;<br>            set.add(Integer.valueOf(s));<br>        &#125;<br>        <span class="hljs-comment">//变成二维的进行理解，应该可以比较好理解，deadends看成障碍物</span><br>        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[][] dir =&#123;<br>                    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,<br>                    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,<br>                    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>                    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,<br>                    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>                    &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>                    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<br>                    &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;<br>                    &#125;;<br>        <span class="hljs-keyword">boolean</span>[][][][] visted=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        visted[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> hasFind=<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>            &#123;<br>                <span class="hljs-keyword">int</span>[] head = q.poll();<br>                <span class="hljs-keyword">int</span> num=<span class="hljs-number">1000</span>*head[<span class="hljs-number">0</span>]+<span class="hljs-number">100</span>*head[<span class="hljs-number">1</span>]+<span class="hljs-number">10</span>*head[<span class="hljs-number">2</span>]+head[<span class="hljs-number">3</span>];<br>                <span class="hljs-keyword">if</span>(num==Integer.valueOf(target))<br>                &#123;<br>                    hasFind=<span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] d:dir)<br>                &#123;<br>                    <span class="hljs-keyword">int</span> newX= (head[<span class="hljs-number">0</span>]+d[<span class="hljs-number">0</span>]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">int</span> newY= (head[<span class="hljs-number">1</span>]+d[<span class="hljs-number">1</span>]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">int</span> newZ= (head[<span class="hljs-number">2</span>]+d[<span class="hljs-number">2</span>]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>                    <span class="hljs-keyword">int</span> newU =(head[<span class="hljs-number">3</span>]+d[<span class="hljs-number">3</span>]+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>                    <br>                    <span class="hljs-keyword">if</span>(!set.contains(num)&amp;&amp;!visted[newX][newY][newZ][newU])<br>                    &#123;<br>                        visted[newX][newY][newZ][newU]=<span class="hljs-keyword">true</span>;<br>                        System.out.println(newX+<span class="hljs-string">&quot; &quot;</span>+newY+<span class="hljs-string">&quot; &quot;</span>+newZ+<span class="hljs-string">&quot; &quot;</span>+newU);<br>                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;newX,newY,newZ,newU&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            count++;<br>            <span class="hljs-keyword">if</span>(hasFind) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasFind?count-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-所有路径"><a href="#110-所有路径" class="headerlink" title="110 所有路径"></a>110 所有路径</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16447396331801644739633078.png" alt="所有路径"></p><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>深度优先搜索</p><h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    List&lt;Integer&gt; res;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="hljs-keyword">int</span>[][] graph) &#123;<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        res.add(<span class="hljs-number">0</span>);<br>        dfs(graph,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph,<span class="hljs-keyword">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==graph.length-<span class="hljs-number">1</span>)<br>        &#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(res));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next:graph[idx])<br>        &#123;<br>            res.add(next);<br>            dfs(graph,next);<br>            res.remove(res.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-计算除法"><a href="#111-计算除法" class="headerlink" title="111.计算除法"></a>111.计算除法</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16448406275461644840626687.png" alt="计算除法"></p><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>给每个变量赋值数值，然后还有相邻的，采用map嵌套map的做法。</p><h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">double</span>[] ans;<br>    <span class="hljs-keyword">double</span> ret;<br>    <span class="hljs-keyword">boolean</span> finded;<br>    Map&lt;String,Boolean&gt; visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-comment">//字符串，对应一个字符串数组</span><br>        ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queries.size()];<br>        HashMap&lt;String,HashMap&lt;String,Double&gt;&gt; maps = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> m = equations.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            String curNode= equations.get(i).get(<span class="hljs-number">0</span>);<br>            String nextNode =equations.get(i).get(<span class="hljs-number">1</span>);<br>            HashMap&lt;String,Double&gt; map = maps.get(curNode);<br>            <span class="hljs-keyword">if</span>(map==<span class="hljs-keyword">null</span>)<br>            &#123;<br>                map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>                map.put(nextNode,values[i]);<br>                maps.put(curNode,map);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map.put(nextNode,values[i]);<br>            &#125;<br>            HashMap&lt;String,Double&gt; map1 = maps.get(nextNode);<br>            <span class="hljs-keyword">if</span>(map1==<span class="hljs-keyword">null</span>)<br>            &#123;<br>                map1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>                map1.put(curNode,<span class="hljs-number">1.0</span>/values[i]);<br>                maps.put(nextNode,map1);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map1.put(curNode,<span class="hljs-number">1.0</span>/values[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(maps);</span><br>        <span class="hljs-keyword">int</span> n =queries.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            String start = queries.get(i).get(<span class="hljs-number">0</span>);<br>            String end = queries.get(i).get(<span class="hljs-number">1</span>);<br>            finded=<span class="hljs-keyword">false</span>;<br>            visited=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>            ret =<span class="hljs-number">1.0</span>;<br>            <span class="hljs-comment">// System.out.println(&quot;第&quot;+i+&quot;次&quot;);</span><br>            dfs(start,end,maps,i);<br>            <span class="hljs-keyword">if</span>(!finded) ans[i]=-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start,String end,HashMap&lt;String,HashMap&lt;String,Double&gt;&gt; maps,<span class="hljs-keyword">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(finded) <span class="hljs-keyword">return</span> ;<br>        HashMap&lt;String,Double&gt; e= maps.get(start);<br>        <span class="hljs-keyword">if</span>(e==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            visited.put(start,<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> entry:e.entrySet())<br>            &#123;<br>                String nextNode=entry.getKey();<br>                Double value=entry.getValue();<br>                <span class="hljs-comment">// System.out.println(nextNode+&quot; &quot;+end+&quot; &quot;+ret);</span><br>                <span class="hljs-keyword">if</span>(nextNode.equals(end))<br>                &#123;<br>                    ret*=value;<br>                    finded=<span class="hljs-keyword">true</span>;<br>                    ans[idx]=ret;<br>                    ret/=value;<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(visited.get(nextNode)!=<span class="hljs-keyword">null</span>&amp;&amp;visited.get(nextNode)==<span class="hljs-keyword">true</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    ret*=value;<br>                    dfs(nextNode,end,maps,idx);<br>                    ret/=value;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-最长递增路径"><a href="#112-最长递增路径" class="headerlink" title="112. 最长递增路径"></a>112. 最长递增路径</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16448407805461644840779954.png" alt="最长递增路径"></p><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>记忆化递归，避免重复的运算</p><h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[][] dir =&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">int</span> n =matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] ways = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                ret=Math.max(dfs(matrix,ways,i,j),ret);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix,<span class="hljs-keyword">int</span>[][] ways,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(ways[m][n]!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ways[m][n];<br>        ways[m][n]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] d:dir)<br>        &#123;<br>            <span class="hljs-keyword">int</span> newX = m+d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> newY = n+d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>( newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;matrix.length<br>                &amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;matrix[<span class="hljs-number">0</span>].length<br>                &amp;&amp;matrix[newX][newY]&gt;matrix[m][n])<br>            &#123;<br>                <span class="hljs-keyword">int</span> before= dfs(matrix,ways,newX,newY);<br>                ways[m][n]=Math.max(before+<span class="hljs-number">1</span>,ways[m][n]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ways[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-课程顺序"><a href="#113-课程顺序" class="headerlink" title="113. 课程顺序"></a>113. 课程顺序</h2><h3 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16448415065461644841506157.png" alt="课程顺序"></p><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>对于这个搜索题目，我们需要先找到起点，也就是我们遍历所有的组合，然后我们可以找到那些入的度为0的，这些点不是孤立的点就是起点，将这些全部加入初始队列</p><h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>        <span class="hljs-keyword">if</span>(numCourses==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        Map&lt;Integer,ArrayList&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] pair:prerequisites)<br>        &#123;<br>            dp[pair[<span class="hljs-number">0</span>]]++;<br>            <span class="hljs-keyword">if</span>(map.get(pair[<span class="hljs-number">1</span>])==<span class="hljs-keyword">null</span>)<br>            &#123;<br>                ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                tmp.add(pair[<span class="hljs-number">0</span>]);<br>                map.put(pair[<span class="hljs-number">1</span>],tmp);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                map.get(pair[<span class="hljs-number">1</span>]).add(pair[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//统计有几个不可到达的</span><br>        List&lt;Integer&gt; starts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;dp.length;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dp[j]==<span class="hljs-number">0</span>)<br>            &#123;<br>                starts.add(j);<br>            &#125;<br>        &#125;<br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses];<br>        <span class="hljs-comment">//-1代表没有先修课程，因此是先作为队列的开始</span><br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start:starts)<br>        &#123;<br>            ans.add(start);<br>            q.add(start);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> hasFind = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len =q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)<br>            &#123;<br>                Integer head = q.poll();<br>                <span class="hljs-comment">//获取可以到达的所有课程</span><br>                ArrayList&lt;Integer&gt; arr=map.get(head);<br>                <span class="hljs-keyword">if</span>(count==numCourses)<br>                &#123;<br>                    hasFind=<span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(arr==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(Integer nextCourse:arr)<br>                &#123;<br>                    dp[nextCourse]--;<br>                    <span class="hljs-keyword">if</span>(!visited[nextCourse]&amp;&amp;dp[nextCourse]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        visited[nextCourse]=<span class="hljs-keyword">true</span>;<br>                        ans.add(nextCourse);<br>                        count++;<br>                        q.add(nextCourse);<br>                    &#125;                          <br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(hasFind) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;ans.size();i++)<br>        &#123;<br>            ret[i]=ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasFind?ret:<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="114-外星文字典"><a href="#114-外星文字典" class="headerlink" title="114. 外星文字典"></a>114. 外星文字典</h2><h3 id="题目-26"><a href="#题目-26" class="headerlink" title="　题目"></a>　题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16449301139141644930113264.png" alt="外星文字典"></p><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>按照拓扑排序将字符串进行处理，排列出大小，然后利用广度搜索，进行输出。</p><h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    StringBuilder sb;<br>    <span class="hljs-keyword">boolean</span>[] visited=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">alienOrder</span><span class="hljs-params">(String[] words)</span> </span>&#123;<br>        <span class="hljs-comment">//如果我们的words一开始是只有一个，直接进行返回</span><br>        <span class="hljs-keyword">if</span>(words.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(words.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> words[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//单方向图，然后查看有没有环形成</span><br>        <span class="hljs-keyword">int</span> len = words.length;<br>        sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">//统计每个节点的入度</span><br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Character,ArrayList&lt;Character&gt;&gt; graph = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">char</span>[] cur = words[i].toCharArray();<br>            <span class="hljs-keyword">char</span>[] next = words[i+<span class="hljs-number">1</span>].toCharArray();<br>            <span class="hljs-comment">//找出着两个比较小的长度</span><br>            <span class="hljs-keyword">int</span> minLen =Math.min(cur.length,next.length);<br>            <span class="hljs-comment">//有一个提前跳出的标志</span><br>            <span class="hljs-keyword">boolean</span> jumped=<span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">//标记跳出的位置</span><br>            <span class="hljs-keyword">int</span> jumpedIdx=-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;minLen;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(cur[j]==next[j])<br>                &#123;<br>                    <span class="hljs-comment">//孤立节点，随便放进去，因为不知道大小</span><br>                    <span class="hljs-comment">//并且入度设置为0</span><br>                    <span class="hljs-comment">//如果这个节点的入度还没有被设置过，那么我们可以直接将这个节点设置为入度0</span><br>                    <span class="hljs-keyword">if</span>(map.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        map.put(cur[j],<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">//如果我们选择的这个节点有可以到达的下一个节点，那么我们直接</span><br>                    <span class="hljs-keyword">if</span>(graph.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        ArrayList&lt;Character&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        graph.put(cur[j],tmp);<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//如果下一个节点的入度是空的，那么就新增</span><br>                    <span class="hljs-keyword">if</span>(map.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        map.put(cur[j],<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(map.get(next[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        map.put(next[j],<span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        map.replace(next[j],map.get(next[j])+<span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(graph.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        ArrayList&lt;Character&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        tmp.add(next[j]);<br>                        graph.put(cur[j],tmp);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        ArrayList&lt;Character&gt; tmp = graph.get(cur[j]);<br>                        <span class="hljs-keyword">if</span>(!tmp.contains(next[j]))<br>                        &#123;<br>                            graph.get(cur[j]).add(next[j]);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            map.replace(next[j],map.get(next[j])-<span class="hljs-number">1</span>);<br>                        &#125;<br>                    &#125;<br>                    jumpedIdx=j;<br>                    jumped=<span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(jumped==<span class="hljs-keyword">false</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(cur.length&gt;next.length) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                jumpedIdx=minLen;<br>            &#125;<br>            <span class="hljs-keyword">else</span> jumpedIdx+=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//对于剩下的长度，我们也是需要进行处理的</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=jumpedIdx;j&lt;cur.length;j++)<br>                &#123;<br>                    <span class="hljs-comment">//放入cur剩下的所有元素</span><br>                    <span class="hljs-keyword">if</span>(map.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        map.put(cur[j],<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">//如果我们选择的这个节点有可以到达的下一个节点，那么我们直接</span><br>                    <span class="hljs-keyword">if</span>(graph.get(cur[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        ArrayList&lt;Character&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        graph.put(cur[j],tmp);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//放入cur的所有元素</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=jumpedIdx;j&lt;next.length;j++)<br>                &#123;<br>                    <span class="hljs-comment">//放入cur剩下的所有元素</span><br>                    <span class="hljs-keyword">if</span>(map.get(next[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        map.put(next[j],<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">//如果我们选择的这个节点有可以到达的下一个节点，那么我们直接</span><br>                    <span class="hljs-keyword">if</span>(graph.get(next[j])==<span class="hljs-keyword">null</span>)<br>                    &#123;<br>                        ArrayList&lt;Character&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        graph.put(next[j],tmp);<br>                    &#125;<br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果我们的图是空的，代表这里面的都是相等的？</span><br>        <span class="hljs-comment">// if(graph.isEmpty()) return words[0];</span><br>        List&lt;Character&gt; starts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//找到入度为0的元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> entry:map.entrySet())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(entry.getValue()==<span class="hljs-number">0</span>) starts.add(entry.getKey());<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(map+&quot;  &quot;+graph);</span><br>        <span class="hljs-comment">//入度没有为0的，没有起点，返回错误</span><br>        <span class="hljs-keyword">if</span>(starts.size()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Queue&lt;Character&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Character start:starts)<br>        &#123;<br>            <span class="hljs-comment">//对每个开始的节点进行深度搜索</span><br>            <span class="hljs-comment">// dfs(start,graph);</span><br>            <span class="hljs-comment">//只能采用广度优先搜索</span><br>            visited[start-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">true</span>;<br>            q.add(start);<br>            sb.append(start);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;size;i++)<br>            &#123;<br>                Character head = q.poll();<br>                <span class="hljs-comment">//拿出队首，然后我们找到它的下一个加入队列</span><br>                <span class="hljs-comment">//并且标记已经访问过了</span><br>                ArrayList&lt;Character&gt; arr= graph.get(head);<br>                <span class="hljs-keyword">if</span>(arr==<span class="hljs-keyword">null</span>||arr.isEmpty()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(Character next:arr)<br>                &#123;<br>                    <span class="hljs-comment">//对于后继节点，都需要进行入度的减少</span><br>                    map.replace(next,map.get(next)-<span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//如果没有访问过，并且入度为0</span><br>                    <span class="hljs-keyword">if</span>(!visited[next-<span class="hljs-string">&#x27;a&#x27;</span>]&amp;&amp;map.get(next)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.add(next);<br>                        visited[next-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">true</span>;<br>                        sb.append(next);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length()&gt;=graph.size()?sb.toString():<span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="115-重建序列"><a href="#115-重建序列" class="headerlink" title="115. 重建序列"></a>115. 重建序列</h2><h3 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16449304149141644930414537.png" alt="重建序列"></p><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>建立拓扑排序，然后限制队列只有一个长度，然后进行遍历。看结果是否复合拓扑。</p><h3 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sequenceReconstruction</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; Inorder = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Map&lt;Integer,Set&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//建立图</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> seq:seqs)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;seq.size()-<span class="hljs-number">1</span>;i++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> cur = seq.get(i);<br>                <span class="hljs-keyword">int</span> next = seq.get(i+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(graph.get(cur)!=<span class="hljs-keyword">null</span>&amp;&amp;graph.get(cur).contains(next)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(Inorder.get(cur)==<span class="hljs-keyword">null</span>) Inorder.put(cur,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span>(Inorder.get(next)==<span class="hljs-keyword">null</span>) Inorder.put(next,<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> Inorder.replace(next,Inorder.get(next)+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//开始建造图</span><br>                <span class="hljs-keyword">if</span>(graph.get(cur)==<span class="hljs-keyword">null</span>)<br>                &#123;<br>                    Set&lt;Integer&gt; set =<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>                    set.add(next);<br>                    graph.put(cur,set);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    graph.get(cur).add(next);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(seq.size()==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">//如果仅有一个元素</span><br>                <span class="hljs-keyword">int</span> cur = seq.get(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span>(Inorder.get(cur)==<span class="hljs-keyword">null</span>) Inorder.put(cur,<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//开始建图</span><br>                <span class="hljs-keyword">if</span>(graph.get(cur)==<span class="hljs-keyword">null</span>)<br>                &#123;<br>                    Set&lt;Integer&gt; set =<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>                    graph.put(cur,set);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(Inorder+&quot; &quot;+graph);</span><br>        <span class="hljs-comment">//start只能有一个</span><br>        <span class="hljs-keyword">int</span> start =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> cur:Inorder.entrySet())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur.getValue()==<span class="hljs-number">0</span>)<br>            &#123;<br>                start=cur.getKey();<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(graph.size()&gt;org.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q.add(start);<br>        <span class="hljs-keyword">int</span> c =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> len = q.size();<br>            <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            Integer head = q.poll();<br>            <span class="hljs-comment">// System.out.println(head);</span><br>            <span class="hljs-keyword">if</span>(c&gt;=org.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span>(head!=org[c++]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            Set&lt;Integer&gt; nexts = graph.get(head);<br>            <span class="hljs-keyword">if</span>(nexts==<span class="hljs-keyword">null</span>||nexts.isEmpty()) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//拿到可到达的下几个集合</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> next:nexts)<br>            &#123;<br>                <span class="hljs-comment">//入度减去1</span><br>                Inorder.replace(next,Inorder.get(next)-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(Inorder.get(next)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    q.add(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c==org.length?<span class="hljs-keyword">true</span>:<span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="116-省份数量"><a href="#116-省份数量" class="headerlink" title="116. 省份数量"></a>116. 省份数量</h2><h3 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16449306009141644930600143.png" alt="省份数量"></p><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>深度搜索，每次搜索节点数目加１．</p><h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> [] visited;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] isConnected)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = isConnected.length;<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//对每个城市进行深度搜索</span><br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])<br>            &#123;<br>                dfs(i,isConnected);<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx,<span class="hljs-keyword">int</span>[][] isConnected)</span></span><br><span class="hljs-function">    </span>&#123;<br>        visited[idx]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> m =isConnected.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(isConnected[idx][i]==<span class="hljs-number">1</span>&amp;&amp;!visited[i])<br>            &#123;<br>                dfs(i,isConnected);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="117-相似的字符串"><a href="#117-相似的字符串" class="headerlink" title="117. 相似的字符串"></a>117. 相似的字符串</h2><h3 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16450185260291645018525193.png" alt="相似的字符串"></p><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>并查集合查找，查找联通分量，如果字符串相等或者相似，就进行合并</p><h3 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; father;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">int</span> ans;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">int</span> root =x;<br>            <span class="hljs-keyword">while</span>(father[root]!=<span class="hljs-number">-1</span>)<br>            &#123;<br>                root=father[root];<br>            &#125;<br>            <span class="hljs-keyword">while</span>(x!=root)<br>            &#123;<br>                <span class="hljs-keyword">int</span> oringe_root= father[x];<br>                father[x]=root;<br>                x=oringe_root;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(father.<span class="hljs-built_in">count</span>(x)==<span class="hljs-number">0</span>)<br>            &#123;<br>                father[x]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">int</span> root_x= <span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">int</span> root_y= <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span>(root_x!=root_y)<br>            &#123;<br>                <span class="hljs-comment">//如果合并了，ans减一下;</span><br>                ans--;<br>                father[root_x]=root_y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>        &#125;<br>        <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> n)<br>        &#123;<br>            <span class="hljs-keyword">this</span>-&gt;ans=n;<br>        &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSimilarGroups</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-comment">//如果两个字符串相似的话，那我们进行合并，本题目是球求求连通分量</span><br>        <span class="hljs-keyword">int</span> m = strs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) uf.<span class="hljs-built_in">add</span>(i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =i+<span class="hljs-number">1</span>;j&lt;m;j++)<br>            &#123;<br>                <span class="hljs-comment">//字符串两两判断是否相似，相似进行合并</span><br>                <span class="hljs-keyword">if</span>(strs[i].<span class="hljs-built_in">size</span>()==strs[j].<span class="hljs-built_in">size</span>())<br>                &#123;<br>                    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;strs[i].<span class="hljs-built_in">size</span>();k++)<br>                    &#123;   <br>                        cnt+=strs[i][k]!=strs[j][k];<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">2</span>||cnt==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        uf.<span class="hljs-built_in">merge</span>(i,j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="118-多余的边"><a href="#118-多余的边" class="headerlink" title="118. 多余的边"></a>118. 多余的边</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16450187070281645018706933.png" alt="多余的边"></p><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>合并每个点，如果发现合并同一个集合的点，就是返回的答案</p><h3 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">private</span>:<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; father;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">int</span> root =x;<br>                <span class="hljs-keyword">while</span>(father[root]!=<span class="hljs-number">-1</span>)<br>                &#123;<br>                    root=father[root];<br>                &#125;<br>                <span class="hljs-keyword">while</span>(root!=x)<br>                &#123;<br>                    <span class="hljs-keyword">int</span> oringin_father=father[x];<br>                    father[x]=root;<br>                    x=oringin_father;<br>                &#125;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-comment">//不包含x的话</span><br>                <span class="hljs-keyword">if</span>(!father.<span class="hljs-built_in">count</span>(x))<br>                &#123;<br>                    father[x]=<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">int</span> root_x=<span class="hljs-built_in">find</span>(x);<br>                <span class="hljs-keyword">int</span> root_y=<span class="hljs-built_in">find</span>(y);<br>                <span class="hljs-keyword">if</span>(root_x!=root_y)<br>                &#123;<br>                    father[root_x]=root_y;<br>                &#125;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>            &#125;<br>    &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        UnionFind uf;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-comment">//将每个节点都添加进去</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;=edges.<span class="hljs-built_in">size</span>();i++) uf.<span class="hljs-built_in">add</span>(i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:edges)<br>        &#123;<br>            <span class="hljs-comment">//如果不是相连的，就进行合并</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">isConnected</span>(x[<span class="hljs-number">0</span>],x[<span class="hljs-number">1</span>]))<br>                uf.<span class="hljs-built_in">merge</span>(x[<span class="hljs-number">0</span>],x[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">0</span>]);<br>                ans.<span class="hljs-built_in">push_back</span>(x[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="119-最长连续序列"><a href="#119-最长连续序列" class="headerlink" title="119. 最长连续序列"></a>119. 最长连续序列</h2><h3 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16450188150291645018814926.png" alt="最长连续序列"></p><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>放一个无序列表，然后为了避免重复的查找，我们在查找n的连续时，需要判断是否包含n-1,如果包含了，那么就不用找了，因为找n-1的话，肯定比n来的小</p><h3 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; sets;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x:nums) sets.<span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-comment">// for(auto &amp;x:nums)</span><br>        <span class="hljs-comment">//     cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">//找相邻的</span><br>        <span class="hljs-comment">// UnionFind uf;</span><br>        <span class="hljs-comment">// for(auto &amp;num:nums) uf.add(num);</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//对于每个元素，查找是否连续的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; num:sets)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sets.<span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> curNum=num;<br>                <span class="hljs-keyword">int</span> count =<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//包含curNum+1</span><br>                <span class="hljs-keyword">while</span>(sets.<span class="hljs-built_in">count</span>(curNum+<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    curNum++;<br>                    count++;<br>                &#125;<br>                ans=<span class="hljs-built_in">max</span>(count,ans);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的搜索和插入</title>
    <link href="/2022/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8F%92%E5%85%A5/"/>
    <url>/2022/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8F%92%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val&gt;val)  <span class="hljs-keyword">return</span> searchBST(root.left,val);<br>        <span class="hljs-keyword">if</span>(root.val&lt;val) <span class="hljs-keyword">return</span> searchBST(root.right,val);<br>        <span class="hljs-keyword">if</span>(root.val==val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&lt;val) root.right=insertIntoBST(root.right,val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&gt;val) root.left=insertIntoBST(root.left,val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>解释：使用一个变量进行保存，相当于保存前一个的状态，在每次前序遍历结束后进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">boolean</span> l=dfs(root.left);<br>        <span class="hljs-keyword">if</span>(root.val&lt;=pre) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        pre=root.val;<br>        <span class="hljs-keyword">boolean</span> r=dfs(root.right);<br>        <span class="hljs-keyword">return</span> l&amp;&amp;r;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="两数之和BST"><a href="#两数之和BST" class="headerlink" title="两数之和BST"></a>两数之和BST</h2><p>题目：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16415584884071641558488396.png" alt="两数之和BST"></p><p>解释：保存在数组，然后双指针就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        dfs(root,ans);<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r =ans.size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ans.size()==<span class="hljs-number">0</span>||ans.size()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ans.get(l)+ans.get(r)==k) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans.get(l)+ans.get(r)&lt;k) l=l+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r=r-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; ans)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.left,ans);<br>        ans.add(root.val);<br>        dfs(root.right,ans);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的公共祖先"><a href="#二叉搜索树的公共祖先" class="headerlink" title="二叉搜索树的公共祖先"></a>二叉搜索树的公共祖先</h2><p>题目:<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16415586513691641558651360.png" alt="二叉搜索树的公共祖先"></p><p>解释：跟当前节点比较，就可以判断这两个节点在哪一个子树上面，记得考虑等于的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> dfs(root,Math.min(p.val,q.val),Math.max(p.val,q.val));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> min,<span class="hljs-keyword">int</span> max)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val&lt;=max&amp;&amp;root.val&gt;=min) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val&lt;max&amp;&amp;root.val&lt;min) <span class="hljs-keyword">return</span> dfs(root.right,min,max);<br>        <span class="hljs-keyword">if</span>(root.val&gt;max&amp;&amp;root.val&gt;min) <span class="hljs-keyword">return</span> dfs(root.left,min,max); <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c语言相关</title>
    <link href="/2022/01/03/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/01/03/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="POSIX相关-Potable-operate-System-Interface"><a href="#POSIX相关-Potable-operate-System-Interface" class="headerlink" title="POSIX相关(Potable operate System Interface)"></a>POSIX相关(Potable operate System Interface)</h2><ol><li><p>fork()  代表叉子，子进程的pid是0，父进程的pid为子进程的pid<br> wait() 代表子进程返回</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-comment">//子进程返回0</span><br><span class="hljs-comment">//父进程返回子进程的pid</span><br><span class="hljs-comment">//wait代表的是父进程等待子进程，结束</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> pid =fork();<br>    <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent:child=%d\n&quot;</span>,pid);<br>        pid=wait();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>,pid);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child:exiting\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dup复制文件描述符，</p></li></ol><h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><p><code>char * s= &quot;hello word&quot;</code>,这里的<code>s</code>代表的就是<code>hello world</code>)的地址，需要打印字符串的时候，直接传入这个地址就行。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java的抽象类与接口</title>
    <link href="/2021/12/29/java%E7%9B%B8%E5%85%B3/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/12/29/java%E7%9B%B8%E5%85%B3/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><p>例如，有一群具体的司机和好多辆具体的汽车，我们可以从司机中抽象出“司机”这个类，从汽车抽象出“汽车”这个类，这种抽象是“体征范畴”的，抽象的目的仅仅是帮助记忆、认识，完全和交互没有关系。而当考虑到交互——司机需要驾驶汽车，于是抽象出一个“可驾驶”这个接口。注意，一但“可驾驶”这个接口被抽象出来，就完全和司机以及汽车没有关系了，除了汽车，拖拉机、轮船、飞机都可以实现这个接口，而不一定是司机，会开车的任何人都可以通过“可驾驶”这个接口去驾驶任何实现“可驾驶”接口的东西。这样一来，“驾驶”这种交互就完全取决于这个接口了，这就是“以行为为交互准则的意思”。</p><p>拿不准的时候问问自己，这个抽象是体征抽象还是行为抽象？是为了记忆、分析、设计还是为了交互需要？想明白，再下手。</p><p>摘抄自: <a href="http://www.uml.org.cn/mxdx/201008032.asp">关于面向对象的哲学</a></p><p>注解：接口是对行为的抽象，抽象类是对类的抽象</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合数问题</title>
    <link href="/2021/12/28/leetcode/%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2021/12/28/leetcode/%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-组合总和"><a href="#1-组合总和" class="headerlink" title="1. 组合总和"></a>1. 组合总和</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16406822489311640682248923.png" alt="1.题目"></p><p>题解：直接利用决策树模型，对于每一个节点，选择或者不选择，可以得到最后结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        dfs(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> result,<span class="hljs-keyword">int</span> i,List&lt;Integer&gt; res)</span></span>&#123;<br>        <span class="hljs-comment">// System.out.println(res);</span><br>        <span class="hljs-keyword">if</span>(result==target)&#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(res);<br>            ans.add(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result&gt;target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==candidates.length) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//选择，记住，这边是i不是别的数，因为我们还有可能再选择一次这个数</span><br>        res.add(candidates[i]);<br>        dfs(candidates,target,result+candidates[i],i,res);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//不选择</span><br>        dfs(candidates,target,result,i+<span class="hljs-number">1</span>,res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-组合总数2"><a href="#2-组合总数2" class="headerlink" title="2. 组合总数2"></a>2. 组合总数2</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16406824748891640682474881.png" alt="组合总数2题目"><br>题解：这题对我来说有点难度，我现在还不知道该怎么去处理这些问题，准确点来说，是不知道怎么用决策树解决这种问题，这种问题对于决策树貌似无解，或者我暂时还没有想到。<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16406825906591640682590647.png" alt="题目详解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        ArrayList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        Arrays.sort(candidates);<br>        dfs(candidates,target,result,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,ArrayList&lt;Integer&gt; result,<span class="hljs-keyword">int</span> res,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-comment">// System.out.println(result);</span><br>        <span class="hljs-keyword">if</span>(res&gt;target) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==target)&#123;<br>            ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(result);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==candidates.length) <span class="hljs-keyword">return</span> ;<br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =i;j&lt;candidates.length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j&gt;i&amp;&amp;candidates[j]==candidates[j-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//选择</span><br>            result.add(candidates[j]);<br>            dfs(candidates,target,result,res+candidates[j],j+<span class="hljs-number">1</span>);<br>            result.remove(result.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-组合数3"><a href="#3-组合数3" class="headerlink" title="3. 组合数3"></a>3. 组合数3</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16406827093341640682709330.png" alt="组合总数3"><br>题解：这道题目有点简单，就是简单的决策树问题解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        dfs(result,<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>,k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;Integer&gt; result,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> res,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(res&gt;target) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==target)&#123;<br>            <span class="hljs-keyword">if</span>(result.size()!=k) <span class="hljs-keyword">return</span> ;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(result);<br>            ans.add(tmp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">//加上</span><br>        result.add(i);<br>        dfs(result,i+<span class="hljs-number">1</span>,target,res+i,k);<br>        result.remove(result.size()-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//不加上</span><br>        dfs(result,i+<span class="hljs-number">1</span>,target,res,k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-组合数4"><a href="#4-组合数4" class="headerlink" title="4. 组合数4"></a>4. 组合数4</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16406821246301640682124614.png" alt="组合数4题目"></p><p>题解：类似于找零钱问题，只需要找总数的话，我们可以直接利用dp进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=target;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;nums.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;=i)&#123;<br>                    dp[i]=dp[i]+dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解</title>
    <link href="/2021/12/26/leetcode/leetcode%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/12/26/leetcode/leetcode%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-例题"><a href="#1-例题" class="headerlink" title="1.例题"></a>1.例题</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405257547261640525754717.png" alt="leetcode题目1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = &#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(target-nums[i])!=<span class="hljs-keyword">null</span>)&#123;<br>                ans[<span class="hljs-number">0</span>]=map.get(target-nums[i]);<br>                ans[<span class="hljs-number">1</span>]=i;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(nums[i],i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单的写法，扔一个HashMap遍历一遍可得结果</p><h3 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2. 两个数组的交集"></a>2. 两个数组的交集</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405864196491640586419636.png" alt="题目"></p><p>题解：<br>排序，然后双指针遍历，如果数组1的小于数组2，数组1的指针+1，如果数组2的值小于数组1的值，数组2的指针+1，如果相等，存放结果的指针以及数组1和数组2的指针都要向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        <span class="hljs-comment">//放进去两个map    数字几出现几次</span><br>        Arrays.sort(nums1);<br>        Arrays.sort(nums2);<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Math.min(nums1.length,nums1.length)];<br>        <span class="hljs-keyword">while</span>(i&lt;nums1.length&amp;&amp;j&lt;nums2.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i]&lt;nums2[j])&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[i]&gt;nums2[j])&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans[k]=nums1[i];<br>                i++;<br>                j++;<br>                k++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(ans,<span class="hljs-number">0</span>,k);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-合并两个有序数组"><a href="#3-合并两个有序数组" class="headerlink" title="3.合并两个有序数组"></a>3.合并两个有序数组</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405866804341640586680420.png" alt="合并两个有序数组"></p><p>题解，同样的道理，已经拍完序了，直接双指针，这里的话，类似于求并集，但是不是并集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+n];<br>        <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i]&lt;nums2[j]) tmp[p++]=nums1[i++];<br>            <span class="hljs-keyword">else</span> tmp[p++]=nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;m)&#123;<br>            tmp[p++]=nums1[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;n)&#123;<br>            tmp[p++]=nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k =<span class="hljs-number">0</span>;k&lt;tmp.length;k++)&#123;<br>            nums1[k]=tmp[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-买股票的最佳时机"><a href="#4-买股票的最佳时机" class="headerlink" title="4.买股票的最佳时机"></a>4.买股票的最佳时机</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405869463021640586946291.png" alt="4.买股票的最佳时机"></p><p>题解： 你买股票的时候，只需要知道以前日子最低的价格就行了，这就是最大的利润</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> min =prices[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>          ans = Math.max(prices[i]-min,ans);<br>          min = Math.min(prices[i],min);<br>      &#125;  <br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-第N位数字"><a href="#5-第N位数字" class="headerlink" title="5. 第N位数字"></a>5. 第N位数字</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405955350761640595535066.png" alt="题目"></p><p>题解： 就是单纯的模拟，先判断是几位的数，然后再进行定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> num1= <span class="hljs-number">9</span>;<br>       <span class="hljs-keyword">int</span> num2 =<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">int</span> temp =<span class="hljs-number">0</span>;<br>       List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>       ans.add(<span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>           temp+=(num2*num1);<br>           ans.add(temp);<br>           num1*=<span class="hljs-number">10</span>;<br>           num2+=<span class="hljs-number">1</span>;<br>       &#125; <br>       ans.add(Integer.MAX_VALUE);<br>       <span class="hljs-comment">//拿到所有的了</span><br>       <span class="hljs-comment">//先判断在几位数的范围</span><br>       <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;ans.size();i++)&#123;<br>           <span class="hljs-keyword">if</span>(n&gt;ans.get(i-<span class="hljs-number">1</span>)&amp;&amp;n&lt;=ans.get(i))&#123;<br>               count=i;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//然后把前面无关的全部减掉</span><br>       <span class="hljs-comment">//然后把前面无关的全部减掉</span><br>        n-=ans.get(count-<span class="hljs-number">1</span>);<br>       <span class="hljs-comment">//这时候剩下的结果可以按照位数进行查找</span><br>       <span class="hljs-comment">//对n进行处理</span><br>       n=n-<span class="hljs-number">1</span>;<br><br>       <span class="hljs-keyword">int</span> number=n/count;<span class="hljs-comment">//算出是第几个数</span><br>       <span class="hljs-keyword">int</span> bit = n%count;<span class="hljs-comment">//算出是第几位</span><br>    <span class="hljs-comment">//    System.out.println(number+&quot;  &quot;+bit);</span><br><br>        <span class="hljs-keyword">int</span> base =<span class="hljs-number">1</span>;<br>       <span class="hljs-comment">//找出  count位数的最小值</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;count;i++)&#123;<br>           base*=<span class="hljs-number">10</span>;<br>       &#125;<br>       <span class="hljs-comment">//拿到我们的具体第几个数</span><br>       n = base+number;<br>       <span class="hljs-comment">//转换成字符</span><br>       <span class="hljs-keyword">return</span> String.valueOf(n).charAt(bit)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-矩阵置0"><a href="#6-矩阵置0" class="headerlink" title="6. 矩阵置0"></a>6. 矩阵置0</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16407555525311640755552513.png" alt="矩阵置0题目"></p><p>题解：这道题目看着不难，只需要用一个列数组和行数组表示当前行或者当前列有没有0，然后再遍历一遍，就可以填充了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//将这些0打标记</span><br>        <span class="hljs-keyword">int</span> m =matrix.length;<br>        <span class="hljs-keyword">int</span> n =matrix[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-keyword">boolean</span>[] rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m];<br>        <span class="hljs-keyword">boolean</span>[] columns = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    rows[i]=<span class="hljs-keyword">true</span>;<br>                    columns[j]=<span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(rows[i]||columns[j])&#123;<br>                    matrix[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-有效的数独"><a href="#7-有效的数独" class="headerlink" title="7. 有效的数独"></a>7. 有效的数独</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16407556983611640755698351.png" alt="题目"></p><p>题解： 判断每一行，每一列，每一个小方块符不符合要求，注重小方块的代码转换,利用hashSet和count可以判断这里面是不是有重复的数组，有重复的数字，那么set的大小肯定是小于count的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-comment">//验证每一行</span><br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-comment">//验证每一行</span><br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>            set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                    set.add(board[i][j]);<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(set.size()!=count) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//验证每一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>            set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>            <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[j][i]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[j][i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                    set.add(board[j][i]);<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(set.size()!=count) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//验证每一个方格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-comment">//第一个方格</span><br>                set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>                <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;<span class="hljs-number">3</span>;l++)&#123;<br>                        <span class="hljs-keyword">if</span>(board[i*<span class="hljs-number">3</span>+k][j*<span class="hljs-number">3</span>+l]&gt;=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;board[i*<span class="hljs-number">3</span>+k][j*<span class="hljs-number">3</span>+l]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                            set.add(board[i*<span class="hljs-number">3</span>+k][j*<span class="hljs-number">3</span>+l]);<br>                            count++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// System.out.println(set);</span><br>                <span class="hljs-keyword">if</span>(set.size()!=count) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索相关题目</title>
    <link href="/2021/12/26/leetcode/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <url>/2021/12/26/leetcode/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>前言：写了题，但是不写写题解，总感觉自己一天啥也没干，写写题解，也算是给自己留下点成就感吧。</p><h2 id="1-例题"><a href="#1-例题" class="headerlink" title="1. 例题"></a>1. 例题</h2><h3 id="1-搜索旋转排序数组"><a href="#1-搜索旋转排序数组" class="headerlink" title="1. 搜索旋转排序数组"></a>1. 搜索旋转排序数组</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405242951391640524295112.png" alt="leetcode题目"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = nums.length;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">int</span> mid =(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=nums[r-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//后半部分有序</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r-<span class="hljs-number">1</span>])&#123;<br>                    l=mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r=mid;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[r-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//前半部分有序</span><br>                <span class="hljs-keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;nums[mid])&#123;<br>                    r=mid;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    l=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>感想：本道题目，主要抓住有序和无序的部分进行分解，<strong>有序的部分总是有一点自己的性质</strong>，有序部分，你可以直接根据有序部分的最左边和最右边，直接判断你要的目标值是否有可能在这个有序部分里面，这也是这道题破解的关键所在。</p><p>再者，本道题采用的二分搜索法为左闭右开区间，个人现在对应这个区间的处理，还是处在迷迷糊糊的状态，想要解决，又不知道该如何解决，这是我目前的状态，对于一个算法，如果死抠细节，感觉这个细节是针对于特定题目的，没有通用性，但是我感觉，这应该是有一种较为规范的写法，但是leetcode上面的题解，大部分都是基于左闭右闭的，所以没有较好的参考性。</p><h3 id="2-寻找旋转排序数组中的最小值"><a href="#2-寻找旋转排序数组中的最小值" class="headerlink" title="2. 寻找旋转排序数组中的最小值"></a>2. 寻找旋转排序数组中的最小值</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405798430021640579842987.png" alt="leetcode寻找旋转排序数组中的最小值"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =nums.length;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[left];<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[right-<span class="hljs-number">1</span>]&gt;nums[left]) <span class="hljs-keyword">return</span> nums[left];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[right-<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=nums[right-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//后半部分有序</span><br>                right=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//前半部分有序</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先，这里的代码特别好玩，之前一直想不到怎么解决二分查找的边界问题，二分查找的边界问题，难就难在，你怎么去处理边界条件，确定这个边界条件是十分令人讨厌的，因为对于不同的二分查找，哪里有等号，然后左开右闭的区间和左闭右闭的区间，处理起来的结果是不一样的，导致我们直接写题的时候，虽然理解了思想，但是对于我们写出没有bug的二分查找算法，对于我来说，是一件没有把握的事情，甚至是一件，我改完一个样例的错误，然后我之前的样例就全部都没办法通过，越改越错。然后在昨天晚上的不经意，我发现，其实我大体上采用二分的思想，然后局部，我可以直接判断还有几个元素，如果有两个元素，我是可以直接判断出来的，对于上面这题，如果只有一个元素的话，我是可以直接返回的，所以解决二分搜索的关键所在就是：<strong>整体采用二分搜索，局部采用特殊判断</strong>，应该不能算是局部，其实是直接可以看成边界条件，边界添加不要使用通用的进行判断，因为这样子做，对于我们来说，有点难受，虽然他们确实可以合并在一起，但是对于我们直接写出代码，我想使用我下面的这种办法可以比较有效地帮你解决问题。</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[left];<br><span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums[right-<span class="hljs-number">1</span>]&gt;nums[left]) <span class="hljs-keyword">return</span> nums[left];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[right-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么对于两个元素的话，我们需要直接进行特殊处理呢？作为初学者的我，我可以想到的是，对于两个元素，如果进行分割的话，我会陷入，<code>mid</code>和<code>right-1</code>元素的比较，如果是两个元素的话，我们可以发现，<code>mid</code>和<code>right-1</code>进行比较，是我们不希望看到的，因为我们比较这两个没有意义，所以我们只剩下两个元素的时候，我们不必要再去分割，我们是可以直接进行判断从而返回的，这样不会花费额外的时间。</p><h3 id="3-寻找旋转排序数组中的最小值-II"><a href="#3-寻找旋转排序数组中的最小值-II" class="headerlink" title="3. 寻找旋转排序数组中的最小值 II"></a>3. 寻找旋转排序数组中的最小值 II</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405829188981640582918887.png" alt="寻找旋转数组中的最小值2"></p><p>刚想借助上一题的经验来试试水，嘿嘿，这是我试出来的水。。。<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405829575601640582957549.png" alt="试水结果"><br>掺不忍赌，而做出这一切的主要目的在于重复性数组带来的两个样例</p><ul><li>$[3,3,3,3,3,3,3,3,1,3]$</li><li>$[5,4,5,5,5,5]$</li></ul><p>先看原本的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =nums.length;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&gt;=nums[right-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[right-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid =(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right-<span class="hljs-number">1</span>])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right-<span class="hljs-number">1</span>])&#123;<br>                right=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==nums[right-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid-<span class="hljs-number">1</span>])&#123;<br>                    right=mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[mid-<span class="hljs-number">1</span>])&#123;<br>                    left=mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                        right=mid+<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                        left=mid+<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])&#123;<br>                            right=mid+<span class="hljs-number">1</span>;<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[left])&#123;<br>                            right=mid+<span class="hljs-number">1</span>;<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            right=mid+<span class="hljs-number">1</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和上一题的主要区别在这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>    right=mid+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>    left=mid+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])&#123;<br>        right=mid+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[left])&#123;<br>        right=mid+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        right=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>矛盾处在了最后一个else，我们没办法根据我们的左右，以及最左边和最右边进行边界的缩小，所以我们的算法失败了吗，不是，我们没有失败，因为有重复数字的话，本来就是不存在$log(n)$的解法的，所以我们这边也没有问题，只能说失败了，但是没有完全失败，这边对于相等的情况，我们只能缩小右边界一个位置，然后进行判断，最终代码结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right =nums.length;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&gt;=nums[right-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[right-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid =(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right-<span class="hljs-number">1</span>])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right-<span class="hljs-number">1</span>])&#123;<br>                right=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]==nums[right-<span class="hljs-number">1</span>])&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br></code></pre></td></tr></table></figure><p>完结撒花</p><h3 id="4-Sqrt-x"><a href="#4-Sqrt-x" class="headerlink" title="4. Sqrt(x)"></a>4. Sqrt(x)</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405897470341640589747023.png" alt="题目"></p><p>题解：直接利用二分查找对应的结果，还是利用，如果right-left等于1代表只剩下一个结果，直接进行返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right =x;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = right+(left-right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mid==x/mid)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid&lt;x/mid)&#123;<br>                left =mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid&gt;x/mid)&#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-山脉数组的峰顶索引"><a href="#5-山脉数组的峰顶索引" class="headerlink" title="5. 山脉数组的峰顶索引"></a>5. 山脉数组的峰顶索引</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16405968380331640596838022.png" alt="题目"></p><p>题解：我们仅仅靠左右边界是没有办法确定我们要往哪边缩小，但是我们可以依赖的还有mid的左右，这可以成为我们判断当前在哪个坡的依据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = arr.length;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-comment">// System.out.println(&quot;left:&quot;+left+&quot; right:&quot;+right);</span><br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> left;<br>            <span class="hljs-keyword">if</span>(right-left==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> left;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> right-<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[right-<span class="hljs-number">1</span>])&#123;<br>                left =mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&gt;=arr[right-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-comment">//代表在右边</span><br>                    right=mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[mid+<span class="hljs-number">1</span>])&#123;<br>                    left=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>二分法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Data Structures Project</title>
    <link href="/2021/12/24/mit6.851/Advanced-Data-Structures-Project/"/>
    <url>/2021/12/24/mit6.851/Advanced-Data-Structures-Project/</url>
    
    <content type="html"><![CDATA[<p>The project is the most important component of the course. It can take several forms:</p><ul><li>Bring a theoretical contribution to the field(solve a problem,formulate an interesting open problem or conjecture,etc)</li><li>Implement a data structure, and describe a set of experiments, and/or how to tune its practical efficency.</li><li>Survey a few papers on a related topic</li><li>Substanially improve the Wikipedia articles for several advanced data structures topics.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Advanced DataStuctures</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解自动配置的原理</title>
    <link href="/2021/12/22/springboot/%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2021/12/22/springboot/%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-SpringBoot的特点"><a href="#1-SpringBoot的特点" class="headerlink" title="1.SpringBoot的特点"></a>1.SpringBoot的特点</h2><h3 id="1-1-依赖管理"><a href="#1-1-依赖管理" class="headerlink" title="1.1 依赖管理"></a>1.1 依赖管理</h3><ul><li>父级目录做依赖管理</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">    依赖管理    <br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>他的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制<br></code></pre></td></tr></table></figure><ul><li>开发导入starter场景启动器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">1、见到很多 spring-boot-starter-* ： *就某种场景<br>2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入<br>3、SpringBoot所有支持的场景<br>https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter<br>4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。<br>5、所有场景启动器最底层的依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">1、引入依赖默认都可以不写版本<br>2、引入非版本仲裁的jar，要写版本号。<br></code></pre></td></tr></table></figure><ul><li>可以修改默认版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。<br>2、在当前项目里面重写配置<br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.43<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-自动配置"><a href="#1-2-自动配置" class="headerlink" title="1.2 自动配置"></a>1.2 自动配置</h3><ul><li><p>自动配置Tomcat</p><ul><li>引入Tomcat依赖</li><li>配置Tomcat</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自动配置好SpringMVC</p><ul><li>引入SpringMVC的依赖</li><li>自动配置好了SpringMVC的常用功能</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>springboot自动帮我们往IOC容器中加了许多组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//1.返回我们的IOC容器</span><br>      ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>      <span class="hljs-comment">//2.查看容器里面的组件</span><br>      String[] names = run.getBeanDefinitionNames();<br>      <span class="hljs-keyword">for</span> (String name : names) &#123;<br>          System.out.println(name);<br>      &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示，可以看到我们自己增加的组件<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401537942401640153794232.png" alt="组件名字"></p></li><li><p>自动配好Web常见功能，如字符编码问题</p><ul><li>SpringBoot帮我们配置好了所有web开发的常用场景</li></ul></li><li>默认的包结构</li><li>按需加载所有自动配置项</li><li>默认的包扫描规则<ul><li>主程序所在的包，及其下面所有的子包里面的所有组件都会被默认扫描进去</li><li>例子<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401550178331640155017823.png" alt="扫描结果"></li><li>如果真的硬要扫描，可以利用<code>@SpringBootApplication(scanBasePackages=&quot;com.nomanker&quot;)</code> 扩大包扫描的范围，结果如下图：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401552715131640155271504.png" alt="增加包的扫描结果"><br>指定了默认的包扫描规则<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401555923171640155592305.png" alt="默认包扫描规则"></li></ul></li><li>各种配置拥有默认值<ul><li>默认配置项最终都是映射到MultipartProperties</li><li>配置的文件的值最终会绑定到每个类上面，这个类会在容器中创建对象</li></ul></li><li>按需加载所有自动加载配置项目<ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li><li>自动配置类的核心所在<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401561630711640156163057.png" alt="autoconfig"><br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401564069211640156406909.png" alt="场景的配置类"></li></ul></li></ul><h2 id="2-容器功能"><a href="#2-容器功能" class="headerlink" title="2.容器功能"></a>2.容器功能</h2><h3 id="2-1-组件添加"><a href="#2-1-组件添加" class="headerlink" title="2.1 组件添加"></a>2.1 组件添加</h3><p>以前的方式：先编写好组件，然后通过beans.xml将这些组件添加到IOC容器当中<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401569544831640156954471.png" alt="添加方式"></p><ol><li><p>@Configuration<br>编写我们自己对应的组件类，需要添加<code>@Configuration</code>表明我们这是一个配置类<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401573611621640157361147.png" alt="组件类"><br>自定义组件名字<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401575020631640157502052.png" alt="自定义组件名字"><br>获取的组件都是单实例的，验证代码如下如下<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401577218821640157721875.png" alt="组件相等代码"><br>结果如下：<br><code>组件：true</code><br>配置类本身也是一个组件<br>测试代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MyConfig也是一个组件</span><br>MyConfig bean = run.getBean(MyConfig.class);<br>System.out.println(<span class="hljs-string">&quot;MyConfig组件是否存在&quot;</span>+bean);<br></code></pre></td></tr></table></figure><p>测试结果为:<br><code>MyConfig组件是否存在com.nomanker.boot.config.MyConfig$$EnhancerBySpringCGLIB$$1ad27f5a@43e065f2</code><br>由此观察到，我们的配置类也是做为一个组件存在IOC容器当中</p><p> 接下来我们查看下Configuration的注解，新增加了proxyBeanMethods的注解<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401581847921640158184785.png" alt="Configuration注解"><br> 代理bean的方法</p><p> 验证我们的猜想,修改我们的注解，<code>proxyBeanMethods</code>默认是<code>true</code>的，我们需要进行对应的修改<br> @Configuration(proxyBeanMethods = false)<br> 这样子我们获取到Configure类，并且调用对应的方法，会发现我们创建的两个类，对应的结果是不一样的，而按照我们之前的<code>true</code>，创建出来的对象则是一样的，之前创建出来的为单例模式，现在创建出来的为多例模式<br> 测试代码如下：<br> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401586664601640158666455.png" alt="对应的测试代码"><br> 测试结果为：<code>false</code></p><p> 添加了 <code>@Configuration(proxyBeanMethods = true)</code>的话，可以发现我们的<code>Configuration</code>对应的内容为<br> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401589235441640158923527.png" alt="增强型代理对象"><br> 而如果<code>@Configuration(proxyBeanMethods = false)</code>的话，我们的<code>Configuration</code>为普通的代理对象，就是正常的调用类里面的方法，所以每次产生的实例都是不同的，因为这个普通的代理类不会去IOC容器中寻找是否有该容器的信息，会直接进行实例的创建。<br> 测试结果如下：<br> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401591152311640159115221.png" alt="没有增强的对象"><br> 可以观察到，我们生成的代理对象没有被增强过</p><ul><li>Full配置和lite配置<br>Full模式(proxyBeanMethod=true)每次代理都会去容器里面找，会比较慢<br>lite模式(proxyBeanMethod=false)每次代理都是直接生成一个新的对象，很快，因为不用再去容器里面找了</li><li>解决场景<br>  Full模式来解决组件依赖</li></ul></li><li>@Bean，@Component，@Controller，@Service，@Repository(数据库层组件)<br>以前的用法</li><li>@ComponentScan，@Import<br>注重理解<code>@Import</code>的作用，导入组件到IOC容器<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401625453681640162545358.png" alt="@Import的使用"><br>执行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401626641161640162664091.png" alt="执行结果"><br>可以观察到，我们的容器中多了以类名命名的组件</li><li>@Conditional<br>按照条件进行判断是否将组件注册到容器里面<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16401629202291640162920168.png" alt="Conditional的继承图"></li></ol><h3 id="2-2-原生配置文件的引入"><a href="#2-2-原生配置文件的引入" class="headerlink" title="2.2 原生配置文件的引入"></a>2.2 原生配置文件的引入</h3><ol><li>@ImportResource</li></ol><h3 id="2-3-配置绑定"><a href="#2-3-配置绑定" class="headerlink" title="2.3 配置绑定"></a>2.3 配置绑定</h3><p>如何使用java读取到properties文件中的内容，并把它封装到JavaBean中，以供随时使用;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">getProperties</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>&#123;<br>         Properties pps = <span class="hljs-keyword">new</span> Properties();<br>         pps.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.properties&quot;</span>));<br>         Enumeration enum1 = pps.propertyNames();<span class="hljs-comment">//得到配置文件的名字</span><br>         <span class="hljs-keyword">while</span>(enum1.hasMoreElements()) &#123;<br>             String strKey = (String) enum1.nextElement();<br>             String strValue = pps.getProperty(strKey);<br>             System.out.println(strKey + <span class="hljs-string">&quot;=&quot;</span> + strValue);<br>             <span class="hljs-comment">//封装到JavaBean。</span><br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>这是以前的使用方法，挺麻烦的。</p><h4 id="1、-ConfigurationProperties"><a href="#1、-ConfigurationProperties" class="headerlink" title="1、@ConfigurationProperties"></a>1、@ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> Integer price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Integer price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&quot;</span> + price +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、-EnableConfigurationProperties-ConfigurationProperties"><a href="#2、-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="2、@EnableConfigurationProperties + @ConfigurationProperties"></a>2、@EnableConfigurationProperties + @ConfigurationProperties</h4><p>对于这种方法，我们不需要再写Component，方便我们引入第三方包，然后他自己的类没有导入容器，导致我们没办法使用的场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigurationProperties(Car.class)</span><br><span class="hljs-comment">//1、开启Car配置绑定功能</span><br><span class="hljs-comment">//2、把这个Car这个组件自动注册到容器中</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时我们可以去掉对应的<code>@Component</code>注解，因为<code>@EnableConfigurationProperties</code>会导入对应的<code>Car.class</code>，但是我们的<code>Car.class</code>还是需要对应的<code>@ConfigurationProperties</code>的组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自动配置原理入门"><a href="#自动配置原理入门" class="headerlink" title="自动配置原理入门"></a>自动配置原理入门</h2><h3 id="3-1-引导加载自动配置类"><a href="#3-1-引导加载自动配置类" class="headerlink" title="3.1 引导加载自动配置类"></a>3.1 引导加载自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-SpringConfiguration"><a href="#1-SpringConfiguration" class="headerlink" title="1.@SpringConfiguration"></a>1.@SpringConfiguration</h4><p>就是一个单纯的配置类，没有什么用处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-ComponentScan"><a href="#2-ComponentScan" class="headerlink" title="2.ComponentScan"></a>2.ComponentScan</h4><p>指定扫描哪些包</p><h4 id="3-EnableAutoConfiguration"><a href="#3-EnableAutoConfiguration" class="headerlink" title="3. EnableAutoConfiguration"></a>3. EnableAutoConfiguration</h4><p>注重关注这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>@AutoConfigurationPackage<br>自动配置包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>&#125;<br><span class="hljs-comment">//利用Registrar给容器中导入一系列组件</span><br><span class="hljs-comment">//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</span><br></code></pre></td></tr></table></figure><p> @Import代表给容器中导入一个组件，这里代表导入Registrar.class这个组件<br> Registrar.class这个类是用来做什么的</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>    Registrar() &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        AutoConfigurationPackages.register(registry, (<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImport(metadata)).getPackageName());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImport(metadata));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 对应的结果为：<br> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403293436371640329343621.png" alt="包名注册"><br> 这里的图片也解释了为什么springboot会自动扫描<code>MainApplication</code>包名下的所有组件，并且导入IOC容器。</p></li><li><p>@Import(AutoConfigurationImportSelector.class)</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403289135841640328913577.png" alt="EnableAutoConfiguration对应的第二个注解"><br>我们已经研究完成<code>@AutoConfigurationOackage</code>的注解，所以我们接下来研究<code>@Import(AutoConfigurationImportSelector.class)</code>对应的作用是什么？</p><ul><li><p>首先进来我们的<code>AutoConfigurationImportSelectort</code>我们可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">AutoConfigurationMetadata autoConfigurationMetadata,</span></span><br><span class="hljs-function"><span class="hljs-params">AnnotationMetadata annotationMetadata)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125;<br>AnnotationAttributes attributes = getAttributes(annotationMetadata);<br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,<br>attributes);<br>configurations = removeDuplicates(configurations);<br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br>configurations = filter(configurations, autoConfigurationMetadata);<br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403311464081640331146396.png" alt="getCandidateConfigurations获取到的结果"></p><p>获取到<code>configurations</code>,然后按照一定的规则排序一些选项，返回对应的<code>AutoConfigurationEntry</code>对应的实体，所以我门着重进去<code>getCandidateConfigurations(annotationMetadata,attributes);</code>查看该方法是怎么起到效果的。</p></li><li><p>紧接着进去<code>getCandidateConfigurations(annotationMetadata,attributes)</code></p><p>根据名字可以看出，这是个获取候选配置的方法</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403313924761640331392465.png" alt="spring工厂"></p><p>可以观测到，通过spring工厂制造出来这些对应的候选类，所以我们可以进去<code>loadFactoryName</code>，意思是加载对应的工厂中的名字，类似于工厂根据名字开始制作组件了，然后要把这些组件放入到IOC容器当中。<br><code>loadFactoryName</code>的代码如下：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403316678221640331667813.png" alt="loadFactoryName源代码"></p></li><li><p>进入<code>loadSpringFactories</code>可以观察到如下代码<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403317630171640331763006.png" alt="loadSpringFactories部分代码"><br>因此我们是通过读取<code>&quot;META-INF/spring.factories&quot;</code>,从而加载场景所需要的配置类。<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403320664771640332066451.png" alt="结果展示"><br>因此我们可以来到对应的jar包<code>spring-boot-autoconfigure-2.1.3.RELEASE.jar</code>可以观测到对应的<code>&quot;META-INF/spring.factories&quot;</code>，可以查看，这边的配置类一共118，符合我们的结果预期。</p></li></ul><h3 id="3-2-按需开启自动配置项"><a href="#3-2-按需开启自动配置项" class="headerlink" title="3.2. 按需开启自动配置项"></a>3.2. 按需开启自动配置项</h3><p>虽然我们118个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration<br>按照条件装配规则（@Conditional），最终会按需配置。</p><h3 id="3-3-修改默认配置"><a href="#3-3-修改默认配置" class="headerlink" title="3.3. 修改默认配置"></a>3.3. 修改默认配置</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16403330832021640333083184.png" alt="观测其中一个自动配置类"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="hljs-comment">//容器中有这个类型组件</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="hljs-comment">//容器中没有这个名字 multipartResolver 的组件</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> </span>&#123;<br><span class="hljs-comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span><br><span class="hljs-comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span><br><span class="hljs-comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span><br>  <span class="hljs-keyword">return</span> resolver;<br>&#125;<br>给容器中加入了文件上传解析器；<br></code></pre></td></tr></table></figure><p>SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-总结："><a href="#3-4-总结：" class="headerlink" title="3.4 总结："></a>3.4 总结：</h3><ul><li>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</li><li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</li><li>生效的配置类就会给容器中装配很多组件</li><li>只要容器中有这些组件，相当于这些功能就有了</li><li>定制化配置<ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值就去修改。</li></ul></li></ul><p>xxxxxAutoConfiguration —-&gt; 组件  —-&gt; xxxxProperties里面拿值  ——&gt; application.properties</p><h3 id="3-5-最佳实践"><a href="#3-5-最佳实践" class="headerlink" title="3.5 最佳实践"></a>3.5 最佳实践</h3><ul><li>引入场景依赖</li><li>查看自动配置了哪些（选做）<ul><li>自己分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true开启自动配置报告。Negative（不生效）\Positive（生效）</li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项<ul><li>自己分析。xxxxProperties绑定了配置文件的哪些。</li></ul></li><li>自定义加入或者替换组件<ul><li>@Bean、@Component。。。</li></ul></li><li>自定义器  XXXXXCustomizer；</li><li>……</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot入门</title>
    <link href="/2021/12/22/springboot/springboot%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/22/springboot/springboot%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a>SpringBoot2入门</h2><h2 id="1-系统要求"><a href="#1-系统要求" class="headerlink" title="1. 系统要求"></a>1. 系统要求</h2><ul><li>Java 8 兼容java14</li><li>Maven 3.3+</li><li>idea 2019.1.2</li></ul><h3 id="1-1-maven-设置"><a href="#1-1-maven-设置" class="headerlink" title="1.1 maven 设置"></a>1.1 maven 设置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2. HelloWorld"></a>2. HelloWorld</h2><p>需求：浏览器发送/hello请求，响应hello，Spring Boot2</p><h3 id="2-1-创建maven工程"><a href="#2-1-创建maven工程" class="headerlink" title="2.1 创建maven工程"></a>2.1 创建maven工程</h3><h3 id="2-2-引入依赖"><a href="#2-2-引入依赖" class="headerlink" title="2.2 引入依赖"></a>2.2 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-创建主程序"><a href="#2-3-创建主程序" class="headerlink" title="2.3 创建主程序"></a>2.3 创建主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主程序类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@SpringBootApplication</span>：这是一个SpringBoot应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-编写业务"><a href="#2-4-编写业务" class="headerlink" title="2.4 编写业务"></a>2.4 编写业务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Spring Boot 2!&quot;</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><p>直接运行main方法</p><h3 id="2-6-简化配置"><a href="#2-6-简化配置" class="headerlink" title="2.6 简化配置"></a>2.6 简化配置</h3><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><h3 id="2-7-简化部署"><a href="#2-7-简化部署" class="headerlink" title="2.7 简化部署"></a>2.7 简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将项目打包成为jar包，直接在目标服务器执行即可。</p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Data Structures</title>
    <link href="/2021/12/20/mit6.851/Advanced-Data-Structures/"/>
    <url>/2021/12/20/mit6.851/Advanced-Data-Structures/</url>
    
    <content type="html"><![CDATA[<h2 id="Advanced-Data-Stuctures"><a href="#Advanced-Data-Stuctures" class="headerlink" title="Advanced Data Stuctures"></a>Advanced Data Stuctures</h2><p>Data structures play a central role in modern computer science. You <strong>interact</strong> with data structures even more often than algorithms(think Google,you mail server,and even you network routers).In addition,data structures are <strong>essential</strong> building blocks in obtaining efficient algorithms.This course covers major results and current directions of research in data structures:</p><h2 id="TIME-TRAVEL"><a href="#TIME-TRAVEL" class="headerlink" title="TIME TRAVEL"></a>TIME TRAVEL</h2><p>We can remember the past efficiently (a technique called <strong>persistence</strong>), but in general it’s difficult to change the past and see the outcomes on the present (<strong>retroactivity</strong>). So alas, Back To The Future isn’t really possible.</p><ul><li>persistence is the branching universe time travel model,where if you make a change in the past,you get a new universe,you never destroy old universe.</li><li>retroactivity is more like Back to the Future ,when you go back ,make a change ,and then you can return to the present and see what happened.This is a lot hader to do.</li></ul><h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><ul><li>the general idea of persistence is to remember everything.The general goal,keep all version of DS(data Stuctures).</li><li>DS operations relative to special version</li><li>update cteates(&amp;returns) new version</li></ul><h4 id="4-levels"><a href="#4-levels" class="headerlink" title="4 levels"></a>4 levels</h4><ol><li>partial persistence:<ul><li>update only latest version</li><li>verions are linearly ordered</li></ul></li><li>full persistence<ul><li>update any version</li><li>versions form a tree</li></ul></li><li>confluent persistence<ul><li>can combine &gt;1 given version into new V</li><li>versions form a DAG(directly acyclic graph)</li></ul></li><li>functional:<ul><li>never modify node;</li><li>version of DS represented by pointer</li></ul></li></ol><h3 id="pation-persistence"><a href="#pation-persistence" class="headerlink" title="pation persistence"></a>pation persistence</h3><p>any pointer-machine DS<br>wh</p>]]></content>
    
    
    <categories>
      
      <category>Advanced DataStuctures</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何写好双指针的问题</title>
    <link href="/2021/11/23/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/23/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16376750539421637675053931.png" alt="无重复字符的最长字串"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-comment">//First,Out of the range</span><br>     <span class="hljs-keyword">int</span> L =-<span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">int</span> R =-<span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">int</span> m = s.length();<br>     <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>     <span class="hljs-keyword">int</span> count =<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">int</span> res =<span class="hljs-number">0</span>;<br>     <span class="hljs-comment">//use the map to record the str is contains the str[R]</span><br>     Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>     <span class="hljs-comment">//always see and then move</span><br>     <span class="hljs-keyword">while</span>(R+<span class="hljs-number">1</span>&lt;m)&#123;<br>         <span class="hljs-comment">//see the R+1 is less than m,so we need to move,and the do what we want.</span><br>         R++;<br>         <span class="hljs-keyword">if</span>(set.contains(str[R]))&#123;<br>             <span class="hljs-comment">//the left pointer is need to go right</span><br>             <span class="hljs-comment">//is also see and move</span><br>             <span class="hljs-keyword">while</span>(L&lt;R&amp;&amp;str[L+<span class="hljs-number">1</span>]!=str[R])&#123;<br>                 set.remove(str[L+<span class="hljs-number">1</span>]);<br>                 L++;<br>             &#125;<br>             <span class="hljs-comment">//and afer a while, we must stay in the same character with str[R],</span><br>             <span class="hljs-comment">//so we need to move 1 step</span><br>             L++;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             set.add(str[R]);<br>         &#125;<br>         <span class="hljs-comment">// System.out.println(&quot;R-L:---&quot;+(R-L));</span><br>         res=Math.max(res,R-L);<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="最接近三数之和"><a href="#最接近三数之和" class="headerlink" title="最接近三数之和"></a>最接近三数之和</h2><p>题目:<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16428349047491642834904741.png" alt="最接近三数之和"></p><p>题解: 数组排序，然后固定好一个下标，使用双指针进行搜索,不要把简单的问题想复杂了</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> minAns = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)<br>            &#123;<br>                <span class="hljs-keyword">int</span> sum = nums[i]+nums[left]+nums[right];<br>                <span class="hljs-keyword">int</span> interval=Math.abs(target-sum);<br>                <span class="hljs-keyword">if</span>(sum&lt;target)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(interval&lt;minAns)<br>                    &#123;<br>                        ans=sum;<br>                        minAns = Math.abs(target-sum);<br>                    &#125;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum==target)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(interval&lt;minAns)<br>                    &#123;<br>                        ans=sum;<br>                        minAns = Math.abs(target-sum);<br>                    &#125;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随想录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>latex example</title>
    <link href="/2021/11/20/Latex/latex-example/"/>
    <url>/2021/11/20/Latex/latex-example/</url>
    
    <content type="html"><![CDATA[<ol><li><p>rule</p> <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> 1100B<span class="hljs-keyword">\\</span>1001B<span class="hljs-keyword">\\</span><span class="hljs-keyword">\rule</span>[7pt]&#123;2cm&#125;&#123;0.1em&#125;<span class="hljs-keyword">\\</span>1000B<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>  <br></code></pre></td></tr></table></figure><p> reduce  effect like under:</p><script type="math/tex; mode=display">1100B\\1001B\\\rule[7pt]{2cm}{0.1em}\\1000B</script></li><li><p>flushleft</p> <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;flushleft&#125;...<span class="hljs-keyword">\end</span>&#123;flushleft&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Latex</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Some example about the bit operation</title>
    <link href="/2021/11/20/bit%20operation/Some-example-about-the-bit-operation/"/>
    <url>/2021/11/20/bit%20operation/Some-example-about-the-bit-operation/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Thia blog is used to storage some binary optimization example.</p></blockquote><h2 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g.1"></a>e.g.1</h2><p><code>n&amp;(n-1)</code></p><ul><li>the operation of <code>&amp;</code> with <code>n</code> and <code>n-1</code> will flip the  lowest <code>1</code> of the binary number <code>n</code> ,let us  see a example to know how this  things happen.</li><li>assert  <code>n</code> is <code>1100B</code> ,so the <code>n-1</code> is <code>1001B</code> ,and the <code>&amp;</code> operation of them <script type="math/tex; mode=display">1100B\\1001B\\\rule[7pt]{2cm}{0.1em}\\1000B</script></li><li>you can see,we delete the lowest <code>1</code> of the <code>n</code>  </li></ul><h2 id="e-g-2"><a href="#e-g-2" class="headerlink" title="e.g.2"></a>e.g.2</h2><p> don’t use <code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,but implement <code>+</code>,the result of two number is under the max of Integer</p><blockquote><p>the code write in java is under<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    add(a^b,a&amp;b&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br> use the totally example to explain why we do this:</p></blockquote><p> $\begin{align}1234\+13121231231&amp; \end{align}  $$</p>]]></content>
    
    
    <categories>
      
      <category>bit operation</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于啥也不相干写点递归这件事</title>
    <link href="/2021/11/19/%E9%80%92%E5%BD%92/%E5%85%B3%E4%BA%8E%E5%95%A5%E4%B9%9F%E4%B8%8D%E7%9B%B8%E5%B9%B2%E5%86%99%E7%82%B9%E9%80%92%E5%BD%92%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
    <url>/2021/11/19/%E9%80%92%E5%BD%92/%E5%85%B3%E4%BA%8E%E5%95%A5%E4%B9%9F%E4%B8%8D%E7%9B%B8%E5%B9%B2%E5%86%99%E7%82%B9%E9%80%92%E5%BD%92%E8%BF%99%E4%BB%B6%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="How-can-I-use-Recusion-to-understand-everything-about-the-world"><a href="#How-can-I-use-Recusion-to-understand-everything-about-the-world" class="headerlink" title="How can I use Recusion to understand  everything about the world?"></a>How can I use Recusion to understand  everything about the world?</h1><blockquote><p>Let us to recursion Everything?</p><h2 id="e-g-0"><a href="#e-g-0" class="headerlink" title="e.g.0"></a>e.g.0</h2><p>Title: Given an array ,rotate the array to the right by <code>k</code> steps,where <code>k</code> is non-negative?</p></blockquote><h2 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g.1"></a>e.g.1</h2><p>the gcd of x and y<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//the x is bigger than y</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> gcd(y,x%y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="e-g-2"><a href="#e-g-2" class="headerlink" title="e.g.2"></a>e.g.2</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16380875103701638087510358.png" alt=""></p><p>Dicesion tree</p><p>  For the example of the <code>&quot;a1b2&quot;</code> ,maybe we can choose <code>a</code> to  <code>uppercase</code> then travel to next,or we can choose <code>a</code> to <code>lowercase</code> then travel to next</p><p>  changes the state then go to the next,the code is under here!!!</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">char</span>[] res;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//记录每个字母的位置，然后进行穷举法</span><br>        <span class="hljs-keyword">char</span>[] str = s.toCharArray();<br>        res = s.toCharArray();<br>        dfs(str,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] str,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(j==str.length)&#123;<br>            String s = <span class="hljs-keyword">new</span> String(str);<br>            ans.add(s);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!Character.isLetter(str[j]))&#123;<br>            dfs(str,j+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            str[j]=Character.toUpperCase(str[j]);<br>            dfs(str,j+<span class="hljs-number">1</span>);<br>            str[j]=Character.toLowerCase(str[j]);<br>            dfs(str,j+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e-g-3"><a href="#e-g-3" class="headerlink" title="e.g.3"></a>e.g.3</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16380880550691638088055060.png" alt=""></p><p>It is also choose the number <code>i</code> of the numbers is use or not to use, </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>        dfs(<span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span><br>        <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录合法的答案</span><br>        <span class="hljs-keyword">if</span> (temp.size() == k) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(temp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//if cur ==n +1 的时候结束递归</span><br>        <span class="hljs-keyword">if</span>(cur==n+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.add(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.remove(temp.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e-g-4"><a href="#e-g-4" class="headerlink" title="e.g.4"></a>e.g.4</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16380982945261638098294514.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <br>    ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> runSteps)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(runSteps==nums.length)&#123;<br>            <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(res);<br>            ans.add(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        res.add(nums[runSteps]);<br>        dfs(nums,runSteps+<span class="hljs-number">1</span>);<br>        res.remove(res.size()-<span class="hljs-number">1</span>);<br>        dfs(nums,runSteps+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Recusion</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View闪退原因</title>
    <link href="/2021/11/15/android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%97%AA%E9%80%80%E5%8E%9F%E5%9B%A0/"/>
    <url>/2021/11/15/android/%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%97%AA%E9%80%80%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16369585169231636958516917.png" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx常用命令</title>
    <link href="/2021/11/11/nginx/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/11/nginx/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li>查看nginx版本  <code>nginx -v</code></li><li>关闭nginx <code>nginx -s stop</code></li><li>热部署nginx <code>nginx -s reload</code></li></ul><h2 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h2>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查找端口命令.md</title>
    <link href="/2021/11/11/linux%E7%9B%B8%E5%85%B3/ubuntu%E7%9B%B8%E5%85%B3-%E6%9F%A5%E6%89%BE%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4-md/"/>
    <url>/2021/11/11/linux%E7%9B%B8%E5%85%B3/ubuntu%E7%9B%B8%E5%85%B3-%E6%9F%A5%E6%89%BE%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4-md/</url>
    
    <content type="html"><![CDATA[<p>解决端口占用问题</p><ol><li>根据端口号查找进程<code>sudo lsof -i:端口号</code></li><li>杀掉进程<code>sudo kill PID号</code></li></ol><p>防火墙相关命令</p><ul><li>安装防火墙 <code>sudo apt-get install firewalld</code></li><li>查看防火墙的端口 <code>sudo firewall-cmd --list-all</code></li><li>查看防火墙的状态 <code>sudo systemctl status firewalld.service</code></li><li>启动防火墙 <code>sudo systemctl start firewalld.service</code></li><li>停用防火墙 <code>sudo systemctl stop firewalld.service</code></li><li>注意防火墙的端口重新设置之后需要重启防火墙</li><li>防火墙添加端口 <code>sudo firewall-cmd --add-port=801/tcp --permanent</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>媒体接入控制</title>
    <link href="/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AA%92%E4%BD%93%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AA%92%E4%BD%93%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>无线网络使用共享媒体技术<br>（MAC）Medium Access Control</p><h1 id="媒体接入控制的基本概念"><a href="#媒体接入控制的基本概念" class="headerlink" title="媒体接入控制的基本概念"></a>媒体接入控制的基本概念</h1><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><ol><li>频分复用<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366173909841636617390954.png" alt=""></li><li>时分复用<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366174849001636617484864.png" alt=""> </li><li>波分复用<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366175498051636617549768.png" alt=""></li><li>码分复用<br>例题<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366176549461636617654929.png" alt=""><br>应用举例<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366178193771636617819322.png" alt=""><br>例题<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366181595891636618159563.png" alt=""><br>例题2<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366183299181636618329883.png" alt=""></li></ol><blockquote><p>缺点，预先固定分配好信道，方法不灵活，对于突然性数据传输信道利用率会很低</p></blockquote><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366186107401636618610700.png" alt=""></p><blockquote><p>多址接入/碰撞检测(Carrieer Sense Multiple Access/Collision Detection)</p></blockquote><ol><li><p>多址接入</p></li><li><p>载波监听</p></li><li>碰撞检测</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer系列题解</title>
    <link href="/2021/11/11/leetcode/%E5%89%91%E6%8C%87offer/"/>
    <url>/2021/11/11/leetcode/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<ol><li><p>二叉搜索树与双向链表<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16366113949941636611394978.png" alt=""></p><p>使用中序遍历，使用一个pre保留前一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  Node head,pre;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      dfs(root);<br>      head.left = pre;<br>      pre.right = head;<br>      <span class="hljs-keyword">return</span> head;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>      dfs(cur.left);<br>      <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>) pre.right=cur;<br>      <span class="hljs-keyword">else</span> head=cur;<br>      cur.left=pre;<br>      pre= cur;<br>      dfs(cur.right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>点对点协议PPP</title>
    <link href="/2021/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/"/>
    <url>/2021/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/</url>
    
    <content type="html"><![CDATA[<h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><h3 id="用户如何连接到互联网"><a href="#用户如何连接到互联网" class="headerlink" title="用户如何连接到互联网"></a>用户如何连接到互联网</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364651022711636465102250.png" alt=""></p><p>通常使用的数据层链路层协议就是PPP协议</p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364653050681636465305024.png" alt=""></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364653539891636465353945.png" alt=""></p><ol><li><p>字节填充法</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364654514771636465451421.png" style="zoom:50%;" /></p></li><li><p>比特填充法</p><p>每 5 个连续的比特 1 ，填充一个比特 0 .</p></li></ol><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>​CRC 循环冗余 ， $X^{16}+X^{12}+X^{5}+1$</p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364657222741636465722239.png" alt="工作状态图"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>左闭右开的一些好处</title>
    <link href="/2021/11/08/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E5%A4%84/"/>
    <url>/2021/11/08/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前记：程序中总是因为区间问题出现奇怪的-bug-，因此-google-。感觉程序中的区间为啥一直都是左开右闭，以下笔记摘抄自"><a href="#前记：程序中总是因为区间问题出现奇怪的-bug-，因此-google-。感觉程序中的区间为啥一直都是左开右闭，以下笔记摘抄自" class="headerlink" title="前记：程序中总是因为区间问题出现奇怪的 bug ，因此 google 。感觉程序中的区间为啥一直都是左开右闭，以下笔记摘抄自"></a>前记：程序中总是因为区间问题出现奇怪的 bug ，因此 google 。感觉程序中的区间为啥一直都是左开右闭，以下笔记摘抄自<img src="https://www.cnblogs.com/fighlone/p/13526864.html" alt="博客链接"></h2><ol><li><p>表示索引“0”</p><p> 如果是代表 $3,4,5,6,7,8,9,10$ ,我们可以使用 $[3,10],[3,11),(2,11)$ 来进行表示，但是如果表示单个元素 $5$ ,那么我们只能采用 $[5,6)$ ,来进行相应的表示，因为 $[5,5]$ 不符合 $[left,right],left&lt;right$ 的定义。</p><p> 对于 0 的话 $(-1,1)$ ,有点让人难以接受，因此只剩下 $[0,1)$ 来进行相应的表示。</p><blockquote><p>使用<strong>左开右闭合</strong>区间，可以只用自然数表示各种连续的索引</p></blockquote></li><li><p><code>for</code> 循环 <code>for(int i =0;i&lt;N;i++)</code> 也是运用的左闭右开的规则</p><p> 这时候的 N ，可以只用用数组的长度来进行对饮，不必要再写成 <code>N=array.size()-1</code></p></li><li><p>便于分治算法的实现</p><p> 例如：对于区间 $[x,y) $ ,可以直接分割成 $[x,z) 和 [z,y)$ ,此处$x&lt;=z&lt;=y$ 而如果是全闭合区间的话，边界的处理情况处理会比较麻烦（好像可以感觉到，后续需举例论证）,例如<br> 对于区间 $[x,y]$ ,可以直接分割成 $[x,z] 和 [z+1,y]$ ,此处的$x&lt;=z&lt;=y-1$,看着别扭。</p><p> 最重要的一点，左闭右开可以保存父子区间形式的统一</p></li><li><p>便于表示空集</p><p> $[left,right)$,当 left 等于 right 的时候，就代表为空集</p></li><li><p>便于计算区间的长度</p><p> $[left,right)$ 的长度就是 $right-left$</p></li><li><p>二分查找的优势</p><p> 取中间元素的话，<code>mid=(begin+end)/2</code> ，特别的方便。</p><p> 而如果是全闭合的话 ，会增加一些不必要的，还不太懂是啥</p><p> $[begin,mid) and [mid,end)$分成对应的这两部分孔家</p></li><li><p>注意如果当前的数组为 ${1,2,3,4,5,6}$ ，假设我们位于 0 位置，那么我们往右移动 3 步的话，我们的区间使用左闭右开的话，该如何表示？  </p><p> 是 $[0,3)$ 吗?，注意，这边并不是，因为按照左闭右开的话，这边代表的是只有 3 个元素，而我们对应的其实应该有 $0,1,2,3$ ,一共四个位置的元素，因此我们需要注意到，我们的区间表示方法应该是 $[0,4) $也就是如果我们站在位置m，向右移动 k 步，我们的区间应该为 $ [m,m+k+1) $ ，而如果是进行向左移动，区间的表示应该为 $ [m-k,m+1)$</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>随想录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全排列算法</title>
    <link href="/2021/11/08/leetcode/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/08/leetcode/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p>给定$num[1,2,3,4,5,4]$,请给出对应的全排列</p><ul><li>使用递归进行处理，给出函数描述，输入是数组$num$</li><li>这边需要考虑是否还需要别的输入</li><li>假设我们不需要别的输入</li><li>那么我们转化成子问题 $f(num)$代表的是求$num$的全排列，那么我们对应的子问题也只能是$f(num)$,显然子问题还是该问题的本身</li><li>假设我们拿了数组$num$的第一个元素当成全排列的第一个元素，那么我们的子问题便是$num$数组中除去第一个元素的其他元素进行，可以表示成为$f(num-[1])$,如果是2当成全排列中的队首的话，那么我们的子问题便是$f(num-[2])$，其余的情况以此类推</li><li>对于上诉想法我们可以进行的代码实现便是使用一个 $visited[num.length()]$，判断有没有被访问过，如果被访问过了，就不会再拿该元素当成队首元素了</li><li><p>因此我们便可以完成第一版的代码，同时为了显示的方便，我们传入一个对应的res保存相应的结果</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> List&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>   <span class="hljs-keyword">void</span> <span class="hljs-title">fullPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">boolean</span>[] visited, ArrayList&lt;Integer&gt; res)</span></span>&#123;<br>    <span class="hljs-comment">//当所有元素被参观了，那么我们就返回</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> b : visited) &#123;<br>        <span class="hljs-keyword">if</span> (!b) &#123;<br>            flag = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        <span class="hljs-comment">//代表全部被参观过</span><br>        <span class="hljs-comment">//因为java的特性，我们需要对结果进行一份拷贝</span><br>        <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(res);<br>        ans.add(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//参观每一个没有被访问的元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i])&#123;<br>           <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置为参观过</span><br>        visited[i]=<span class="hljs-keyword">true</span>;<br>        res.add(nums[i]);<br>        fullPermutation(nums,visited,res);<br>        <span class="hljs-comment">//还原现场</span><br>        visited[i]=<span class="hljs-keyword">false</span>;<br>        res.remove(res.get(res.size()-<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>    <span class="hljs-keyword">var</span> res  = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    fullPermutation(nums,visited,res);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v:ans)&#123;<br>        System.out.println(v);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对应代码结果运行图如下，结果正确</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16363575110141636357511012.png" alt=""></p><ul><li>但是我们其实可以多传入一个参数，用来判断浏览过的元素个数，当元素个数等于数组的长度，我们便可以退出循环，避免每次visited函数需要进行额外的$O(n)$计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>   <span class="hljs-keyword">void</span> <span class="hljs-title">fullPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">boolean</span>[] visited, ArrayList&lt;Integer&gt; res,<span class="hljs-keyword">int</span> count)</span></span>&#123;<br>    <span class="hljs-comment">//当所有元素被参观了，那么我们就返回</span><br>    <span class="hljs-keyword">if</span>(count== nums.length)&#123;<br>        <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(res);<br>        ans.add(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//参观每一个没有被访问的元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i])&#123;<br>           <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置为参观过</span><br>        visited[i]=<span class="hljs-keyword">true</span>;<br>        res.add(nums[i]);<br>        count++;<br>        fullPermutation(nums,visited,res,count);<br>        <span class="hljs-comment">//还原现场</span><br>        count--;<br>        visited[i]=<span class="hljs-keyword">false</span>;<br>        res.remove(res.get(res.size()-<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>感觉递归很奇妙的第一天</p></blockquote></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库中联接的概念</title>
    <link href="/2021/11/08/leetcode/%E6%95%B0%E6%8D%AE%E5%BA%93Leetcode/"/>
    <url>/2021/11/08/leetcode/%E6%95%B0%E6%8D%AE%E5%BA%93Leetcode/</url>
    
    <content type="html"><![CDATA[<p>区分内连接和外连接的区别<br>left join（左联结）:返回左表中的所有记录，和右表中联结字段相等的记录<br>right join(右联结):同理<br>inner join(等值联结):只返回两表中联结字段相等的行(必须两个表中都包含有)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">+-------------+---------+<br>| 列名         | 类型     |<br>+-------------+---------+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br>+-------------+---------+<br>PersonId 是上表主键<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">+-------------+---------+<br>| 列名         | 类型    |<br>+-------------+---------+<br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br>| State       | varchar |<br>+-------------+---------+<br>AddressId 是上表主键<br></code></pre></td></tr></table></figure><p>编写SQL查询，满足条件，无论person是否有地址信息，都需要基于上面两表提供person的如下信息：<br>FirstName, LastName, City, State</p><p><a href="https://leetcode-cn.com/problems/combine-two-tables/">https://leetcode-cn.com/problems/combine-two-tables/</a></p><p>最后一行得用on而不能用where。因为如果Address中查询的所有人的地址都存在，那么这么做没有问题。但是，题目中强调了，人一定存在，但地址不一定。一旦无法匹配到，where语句就行不通了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> FirstName,LastName,City,State <br><span class="hljs-keyword">from</span> Person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address<br><span class="hljs-keyword">on</span> Person.PersonId <span class="hljs-operator">=</span> Address.PersonId;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划暂时不太明白的题目</title>
    <link href="/2021/11/08/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9A%82%E6%97%B6%E4%B8%8D%E5%A4%AA%E6%98%8E%E7%99%BD%E7%9A%84%E9%A2%98%E7%9B%AE/"/>
    <url>/2021/11/08/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9A%82%E6%97%B6%E4%B8%8D%E5%A4%AA%E6%98%8E%E7%99%BD%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><ol><li>不同的二叉搜索树</li></ol><blockquote><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p></blockquote><ol><li><p>动态规划</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>               G[i]+=G[j-<span class="hljs-number">1</span>]*G[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>递归解法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>     <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;=end;i++)&#123;<br>         <span class="hljs-keyword">int</span> leftNum = numTrees(start,i-<span class="hljs-number">1</span>);<br>         <span class="hljs-keyword">int</span> rightNum = numTrees(i+<span class="hljs-number">1</span>,end);<br>         num = num + leftNum*rightNum;<br>     &#125;<br>     <span class="hljs-keyword">return</span> num; <br> &#125; <br></code></pre></td></tr></table></figure></li><li><p>总结，该题使用递归的话，包含相同的子问题，该题的递归思想需要详细理解。</p></li></ol><ol><li>矩阵区域和<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16364994566001636499456590.png" alt=""></li></ol><p>求前缀和的二维问题，注意公式对应的推导<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixBlockSum(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> m = mat.length;<br>        <span class="hljs-keyword">int</span> n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=dp[i][j+<span class="hljs-number">1</span>]+dp[i+<span class="hljs-number">1</span>][j]-dp[i][j]+mat[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n]; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//找到上标，特别好的边界处理方法</span><br>                <span class="hljs-keyword">int</span> row1=Math.max(<span class="hljs-number">0</span>,i-k);<br>                <span class="hljs-keyword">int</span> column1=Math.max(<span class="hljs-number">0</span>,j-k);<br><br>                <span class="hljs-keyword">int</span> row2=Math.min(m,i+k+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">int</span> column2=Math.min(n,j+k+<span class="hljs-number">1</span>);<br><br>                res[i][j]=dp[row2][column2]-dp[row2][column1]-dp[row1][column2]+dp[row1][column1];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>计算 $1,2,3,4,5,6$ 从<code>[i,j]</code>的对应和,转换左闭右开<code>[i,j+1)</code></p><script type="math/tex; mode=display">dp={0,1,3,6,10,15,21}</script><ol><li><p><code>[0,1]</code>转对应区间<code>[0,2)</code>,则对应了其前缀和为<code>dp[2]-dp[0]</code></p></li><li><p><code>[i,j]</code> 转化为 <code>[i,j+1)</code>，其对应的前缀和为 <code>dp[j+1,i]</code> </p></li></ol><blockquote><p>注：该题的边界处理采用了<code>int row1=Math.max(0,i-k);</code> 这种特别好的边界处理方法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络大体知识</title>
    <link href="/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86/"/>
    <url>/2021/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>计算机网络基础知识总结</p><p>摘抄自 <a href="https://www.cnblogs.com/maybe2030/p/4781555.html">[Network] 计算机网络基础知识总结 - Poll的笔记 - 博客园 (cnblogs.com)</a></p><ol><li><h2 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360675903821636067590364.png" style="zoom: 67%;" /></p></li><li><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360676659221636067665894.png" style="zoom:67%;" /></p><ol><li><p>物理层</p><p>激活，维持，关闭通信端点之间的机械特性，典型特性，功能特性以及过程特性。其主要目的，解决0和1如何从一端到另一端。中继器（也称放大器）和集线器。</p></li><li><p>数据链路层</p><h3 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h3><p>将物理层传输过来的 0 和 1 ，传输的基本单位是帧。重要的三个重要问题，<strong>封装成帧</strong>，<strong>差错检测</strong>，<strong>可靠传输</strong>。封装成帧，将网络层给的数据包添加帧头和帧尾(FCS)，进行发送，因此基本单位也是帧。传输过程中可能产生误码，因此便需要引入差错检验， MAC 帧在帧尾部 FCS 使用校验码，可以让接收方进行数据的校验。可靠传输，如果接收到的和发送的是一样的，就代表是可靠传输。</p><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360686982301636068698205.png" alt=""></p><p>解决如何判断数据是否是发送给自己的，以及对谁进行回复。</p><p>同时发送消息，怎么解决？<strong>（以太网媒体接入控制协议）CSMA/CD</strong></p><h3 id="交换式局域网"><a href="#交换式局域网" class="headerlink" title="交换式局域网"></a>交换式局域网</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360688603071636068860292.png" style="zoom:50%;" /></p><p>如何转发帧的呢？（<strong>网桥和交换机的工作原理</strong>）</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360692894771636069289454.png" alt=""></p><p>将上层数据转化成为电信号交付给物理层，那么数据链路层如何从物理层交付的比特流中读取一个个的帧？</p><blockquote><p>帧头和帧尾的作用之一<strong>帧定界</strong></p></blockquote><h4 id="面向字节的物理链路"><a href="#面向字节的物理链路" class="headerlink" title="面向字节的物理链路"></a>面向字节的物理链路</h4><p>使用字节填充（SOH和EOT），帧中数据部分采用ESC进行转义</p><h4 id="面向字符的物理链路"><a href="#面向字符的物理链路" class="headerlink" title="面向字符的物理链路"></a>面向字符的物理链路</h4><p>头尾插入 0111 1110 进行帧定界，然后对数据中的每 5 个连续的 1 后面插入一个 0 ，接收者只需要对每连续的 5 个 1 后面删除 一个 0 就可以复原出完成的数据。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360700844131636070084395.png" style="zoom:67%;" /></p><h5 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h5><p>因为是面向比特进行的传输，所以每 5 个连续的 1 后面插入一个 0 ，因此 0111 1100 0111 1110 填充之后的结果为 0111 11<strong>0</strong>0  0011 111<strong>0</strong> 10，因此选型为A</p><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>为了提高传输的效率，数据的部分应该要比较长，但是为了差错检验的方便，又不能太长，因此规定了最大的传输数据上限大小<strong>MTU</strong>。</p><h3 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>添加校验位使得“1”，使得整个数据，包括校验位“1”的个数为 奇数或者偶数。</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360708350511636070835016.png" alt=""></p><p>如果一位出错，可以判断出来，两位的话不可以进行判断。</p><h4 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h4><p>待发送的消息为 101001 ,生成的多项式为$G(x)=x^3+x^2+1$ ,计算余数</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360733250671636073325037.png" alt=""></p><p>余数应该与生成的多项式的最高次数相同，不相同需要进行补0凑够。  001；</p><blockquote><p>检测码只能检测出帧在传输过程中出现了差错，但是不能定位错误，因此没办法纠正错误。</p></blockquote><h3 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h3><ol><li>不可靠传输服务 ：直接丢弃该帧</li><li><p>可靠传输服务： 想办法实现发送端发送什么，接收端就接收什么。</p></li><li><p>网络层的 IP 协议向上层提供无连接，不可靠传输服务</p></li><li>传输成的 TCP提供可靠服务，UDP提供不可靠服务</li></ol><h3 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h3><ol><li><p>停止等待协议</p><ul><li>确定与否认</li></ul><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360746440571636074644040.png" style="zoom:50%;" /></p><p>​     <strong>遇到的新问题</strong>： 如此似乎没有什么问题，但是如果DATA在发送到接收方的时候就已经丢失，那么发送方就会一直等待，并且接收方因为没有接收到任何数据，所以并不会给发送方提供任何信息。</p><blockquote><p> 解决办法：超时重传    </p></blockquote><ul><li><p>超时重传    </p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361695006901636169500674.png" style="zoom: 67%;" /></p><p>超时重传的时间一般设置为略大于往返时间。</p><p><strong>遇到的问题</strong>：超时重传解决了接收方接收不到数据包的问题，但是也带来了一个新的问题，如果接收方的<em>确认分组</em>没有送到发送方，那么的话，发送方就会发送相同的两个数据包。</p></li><li><p>确认丢失</p><p>确认丢失的话，会造成发送方重复发送相同的DATA，导致接收方接收错误。</p><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361697921961636169792162.png" style="zoom:50%;" /></p><blockquote><p>解决办法：给DATA进行编号，DATA 0，DATA 1这样子</p></blockquote></li><li><p>确认迟到</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361698338641636169833815.png" style="zoom:50%;" /></p><p>发送方，超时重传，然后接收方会发送两条确认，造成发送方对下一条消息的确认。</p><blockquote><p>解决办法：给ACK进行编号，ACK 0，ACK 1这样子</p></blockquote></li><li><p>信道利用率</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361700225921636170022546.png" style="zoom:150%;" /></p><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361701969411636170196921.png" alt=""></p><script type="math/tex; mode=display">U=\frac{T_D}{T_D+RTT+T_A}=\frac{\frac{x}{3kb/s}}{\frac{x}{3kb/s}+200ms\times2}=40\%</script><p>即 $x=800bit$</p></li></ul><blockquote><p>当发送速率提高，信道利用率大幅度下降，如何解决该问题，敬请期待回退N帧协议和选择重传协议,等待的时候也进行数据包的发送</p></blockquote></li><li><p>回退N帧协议</p><p>​<img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361720561571636172056071.png" alt="图片1"></p><p>​问题：</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361719782701636171978202.png" alt=""></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16361720875151636172087499.png" alt=""></p><p>解答：</p><p>​        选项C</p><p>​        4，5，6，7号帧，已发送但是未确认。滑动窗口协议</p><blockquote><p>​    通信质量不好的时候，效率比停止等待效率低</p><p>​    造成原因：一个数据分组的误码，会导致后续多个数据分组不能被接收方按序接收而丢弃，尽管他们无乱码和误码。这必然会造成发送方对这些数据分组的超时重传，显然<strong>这是对通信资源的极大浪费</strong>。</p></blockquote></li><li><p>选择重传协议</p><blockquote><p>为了进一步提高性能，可以设法只重传出现误码的数据分组。因此，就收窗口的尺寸$W_R$不应该再等于1（而应大于1），以便先接收下哪些失序到达，但是没有误码并且序号落在接收窗口内的那些数据分组，等所缺的分组收齐以后一并上交上层，这就是选择重传协议</p></blockquote></li></ol></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>应用层</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>left join和right join和join的区别</title>
    <link href="/2021/11/02/leetcode/left-join%E5%92%8Cright-join%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/11/02/leetcode/left-join%E5%92%8Cright-join%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://segmentfault.com/a/1190000017369618">https://segmentfault.com/a/1190000017369618</a></p><p>有以下两张表</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16358551589001635855158890.png" alt=""></p><ol><li>left join<br>对应的查询语句:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>kemu<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> score<br><span class="hljs-keyword">on</span> kemu.id<span class="hljs-operator">=</span>score.id<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16358552196741635855219649.png" alt=""></p><ol><li>right join<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>kemu<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> score<br><span class="hljs-keyword">on</span> kemu.id<span class="hljs-operator">=</span>score.id<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16358553940291635855394017.png" alt=""></li><li>join<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <br>kemu<br><span class="hljs-keyword">join</span> score<br><span class="hljs-keyword">on</span> kemu.id<span class="hljs-operator">=</span>score.id<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16358554158891635855415877.png" alt=""></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu命令</title>
    <link href="/2021/10/26/linux%E7%9B%B8%E5%85%B3/ubuntu%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/10/26/linux%E7%9B%B8%E5%85%B3/ubuntu%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>报错命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">error <span class="hljs-keyword">while</span> loading shared libraries: libSM.so.6: cannot open shared object file: No such file or di<br></code></pre></td></tr></table></figure></p><p>解决办法：<br>首先查看系统中的 libsm.so.6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldconfig -p|libsm.so.6<br></code></pre></td></tr></table></figure><br>输出对应:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">libSM.so.6 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libSM.so.6<br></code></pre></td></tr></table></figure><br>说明系统只存在64位的libsm.so.6，因此我们需要安装32位的lib.so.6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libsm6:i386<br></code></pre></td></tr></table></figure><p>再次使用ldconfig -p可查看到如下结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">   libSM.so.6 (libc6,x86-64) =&gt; /lib/x86_64-linux-gnu/libSM.so.6<br>libSM.so.6 (libc6) =&gt; /lib/i386-linux-gnu/libSM.so.6<br></code></pre></td></tr></table></figure></p><blockquote><p>ldconfig是一个动态连接库管理工具，可以进行动态连接库的查找</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ubuntu</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vivado报错找不到对应模块</title>
    <link href="/2021/10/26/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/bugs%E5%90%88%E9%9B%86/"/>
    <url>/2021/10/26/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/bugs%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ol><li>vivado报错找不到对应module,仔细对照模块名对照了好久，最后，得出结论，计算机错的概率太小了，优先考虑自己代码写错的问题</li></ol><blockquote><p>原本对应的模块 fetch<br>写错的模块     fecth<br>我承认，我被整蒙了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>bugs</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSH的公钥和私钥</title>
    <link href="/2021/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSH%E7%9A%84%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5/"/>
    <url>/2021/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SSH%E7%9A%84%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5/</url>
    
    <content type="html"><![CDATA[<p>如何利用公钥进行github的登录。<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16346257219931634625721983.png" alt="使用过程"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github自动部署hexo</title>
    <link href="/2021/10/18/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/"/>
    <url>/2021/10/18/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/170563000">参考链接</a></p><p>Github Actions可以帮我们在项目push到github的时候进行自动化的部署。</p><p>Hexo </p><ol><li>确保本地的Hexo可以运行的，即可以部署到github的page，具体测试命令如下，安装教程<a href="https://hexo.io/">hexo安装</a>,配置 github Page链接如下<a href="https://pages.github.com/">github Page配置链接</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo deploy<br></code></pre></td></tr></table></figure><ol><li>打开hexo的根目录，找到 _config.yml</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16345540890371634554089035.png" alt=""></p><ol><li>然后修改对应的reposiroty为github对应的ssh对应的仓库地址</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16345542079321634554207917.png" alt=""></p><ol><li>将下面方框内的ssh地址进行替换就可以了<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16345543658091634554365804.png" alt=""></li></ol><blockquote><p>为什么不可以使用https，因为github从2021年8月13号开始，取消了用的通过密码登录，只能通过ssh或者是token取得对仓库的读写权限。我们进行的部署任务是在一个私有仓库部署到另一个公有仓库，所以我们在这边采用的是ssh的，不然在自动化部署的过程中会报错</p></blockquote><ol><li>密钥生成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;Hexo Deploy Key&quot;</span> -f github-deploy-key -N <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>会在当前目录生成</li></ol><ul><li>github-deploy-key —— 私钥</li><li>github-deploy-key.pub —— 公钥</li></ul><ol><li>在存放Hexo源代码的仓库设置密钥，在存放Hexo生成网页文件的公共仓库存放公钥</li></ol><blockquote><p>注： 设置私有仓库密钥的时候需要记住密钥的名字，后面进行自动化部署时候需要用到</p></blockquote><ol><li>创建workflow<ol><li>首先在 Hexo 的仓库中创建一个新文件：.github/workflows/deploy.yml，文件名可以自己取，但是一定要放在 .github/workflows 目录中，文件的内容如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span><br>    <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.repository.owner.id</span> <span class="hljs-string">==</span> <span class="hljs-string">github.event.sender.id</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">source</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Hexo</span><br>        <span class="hljs-attr">env:</span><br>            <span class="hljs-comment"># 注意这里的HEXO_DEPLOY_KEY为对应的私钥的名称</span><br>          <span class="hljs-attr">ACTION_DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.HEXO_DEPLOY_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">~/.ssh/</span><br>          <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$ACTION_DEPLOY_KEY&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>          <span class="hljs-string">chmod</span> <span class="hljs-number">700</span> <span class="hljs-string">~/.ssh</span><br>          <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>          <span class="hljs-string">ssh-keyscan</span> <span class="hljs-string">github.com</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.ssh/known_hosts</span><br>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;john@doe.com&quot;</span><br>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;John Doe&quot;</span><br>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span><br>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式</title>
    <link href="/2021/10/17/java%E7%9B%B8%E5%85%B3/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/17/java%E7%9B%B8%E5%85%B3/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><h2 id="题记：优先使用组合而不是继承，因为继承会继承可能不需要的属性"><a href="#题记：优先使用组合而不是继承，因为继承会继承可能不需要的属性" class="headerlink" title="题记：优先使用组合而不是继承，因为继承会继承可能不需要的属性"></a>题记：优先使用组合而不是继承，因为继承会继承可能不需要的属性</h2></blockquote><p>例子引入:</p><p>  咖啡店有咖啡，可以选择加黑咖啡、加糖、加冰、加奶、加巧克力等等，根据 isa 的思想，我们需要完成一个咖啡的类，然后牛奶咖啡，加糖咖啡 …… 咖啡分别继承于咖啡。</p><p>所以我们创建如下相关类：</p><pre><code>咖啡    Coffee 加糖咖啡 sugarCoffee牛奶咖啡 milkCoffee加冰咖啡 iceCoffee加冰牛奶加糖咖啡 iceMilkSugarCoffee...</code></pre><p>如此发现，每次我们要增加新的咖啡，我们需要写的类会增长特别块。</p><p>而如果按照装饰者，我们的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> decorator;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">money</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">money</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sugar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    Product product;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sugar</span><span class="hljs-params">(Product product)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.product = product;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">money</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> product.money()+<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Milk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    Product product;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Milk</span><span class="hljs-params">(Product product)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.product = product;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">money</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> product.money()+<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorModel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Product coffee = <span class="hljs-keyword">new</span> Coffee();<br>        System.out.println(coffee.money());<br>        Product sugarCoffee = <span class="hljs-keyword">new</span> Sugar(<span class="hljs-keyword">new</span> Coffee());<br>        System.out.println(sugarCoffee.money());<br>        Product mikCoffee = <span class="hljs-keyword">new</span> Milk(<span class="hljs-keyword">new</span> Coffee());<br>        System.out.println(mikCoffee.money());<br>        Product sugarMilkCoffee = <span class="hljs-keyword">new</span> Sugar(<span class="hljs-keyword">new</span> Milk(<span class="hljs-keyword">new</span> Coffee()));<br>        System.out.println(sugarMilkCoffee.money());<br>        Product milkSugarCoffee = <span class="hljs-keyword">new</span> Milk(<span class="hljs-keyword">new</span> Sugar(<span class="hljs-keyword">new</span> Coffee()));<br>        System.out.println(milkSugarCoffee.money());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>寻找到的相关解释：装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p><p>装饰者较为详细的讲解参考链接<br><a href="https://geek-docs.com/design-pattern/decorator-pattern/decorator-pattern-index.html">https://geek-docs.com/design-pattern/decorator-pattern/decorator-pattern-index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理的LR文法</title>
    <link href="/2021/10/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9A%84LR%E6%96%87%E6%B3%95/"/>
    <url>/2021/10/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9A%84LR%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>如何正确地识别句柄</p><p>S-&gt;bBB<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16335887773381633588777327.png" alt=""></p><p>LR(0)项目</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自动装配原理</title>
    <link href="/2021/10/04/java%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2021/10/04/java%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>WebMvcAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, SERVLET_LOCATION);<br>registration.addResourceLocations(resource);<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>什么是webjars</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16333975146431633397514631.png" alt=""></p><p>默认的静态资源配置的目录<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16333979524281633397952420.png" alt=""></p><p>在springboot中有很多的  xxxxConfigu</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短语，直接短语和句柄</title>
    <link href="/2021/10/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9F%AD%E8%AF%AD%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9F%AD%E8%AF%AD%E5%92%8C%E5%8F%A5%E6%9F%84/"/>
    <url>/2021/10/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9F%AD%E8%AF%AD%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9F%AD%E8%AF%AD%E5%92%8C%E5%8F%A5%E6%9F%84/</url>
    
    <content type="html"><![CDATA[<p>照抄链接:<a href="https://www.cnblogs.com/xpwi/p/11066989.html">https://www.cnblogs.com/xpwi/p/11066989.html</a><br>短语:语法树的所有子树</p><p>直接短语：两层节点的子树</p><p>句柄：最左直接短语</p><p>例子如下:</p><script type="math/tex; mode=display">G[T]:\\    T->T*F|F\\    F->F\&P|P\\    P->(T)|i</script><p>给定的句型如下:</p><script type="math/tex; mode=display">T*P\&(T*F)</script><p>推导步骤为:</p><script type="math/tex; mode=display">T=>T*F\\    =>T*F\&P\\    =>T*P\&(T)\\    =>T*P\&(T)\\    =>T*P\&(T*F)\\</script><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16356681533981635668153377.png" alt=""></p><p>对应的5棵子树如下<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16356682356201635668235612.png" alt=""></p><p>短语：所有子树</p><blockquote><p>P,T*F,(T<em>F),P&amp;(T\</em>F),T*P&amp;(T*F)</p></blockquote><p>直接短语：只包含两层的子树</p><blockquote><p>P,T*F</p></blockquote><p>句柄：直接短语</p><blockquote><p>P</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows命令</title>
    <link href="/2021/10/03/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/Windows%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/10/03/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/Windows%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Windows中杀死占用某个端口的进程</p><ol><li><p>解除8080端口的占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ano |findstr 8080   //列出端口所占用的进程号<br></code></pre></td></tr></table></figure></li><li><p>根据进程号找相应的进程名称</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tasklist |findstr 2000<br></code></pre></td></tr></table></figure><ol><li>根据进程号删除对应的进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程<br></code></pre></td></tr></table></figure><p>windows 设置终端代理</p><ol><li>打开环境变量</li><li>新建两个系统环境变量，变量名称分别为 https_proxy 和 http_proxy</li><li>变量值分别为 <a href="http://127.0.0.1:10809和https://127.0.0.1:10809">http://127.0.0.1:10809和https://127.0.0.1:10809</a></li><li>10809对应的是v2ray对应的http端口</li><li>重新打开终端curl www.google.com 如果返回数据，代表设置成功</li></ol>]]></content>
    
    
    <categories>
      
      <category>windows命令集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot1</title>
    <link href="/2021/10/03/java%E7%9B%B8%E5%85%B3/SpringBoot1/"/>
    <url>/2021/10/03/java%E7%9B%B8%E5%85%B3/SpringBoot1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ajaxsucces不响应的一些原因</title>
    <link href="/2021/09/27/java%E7%9B%B8%E5%85%B3/ajax%E4%B8%8D%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9B%A0/"/>
    <url>/2021/09/27/java%E7%9B%B8%E5%85%B3/ajax%E4%B8%8D%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>后端设置了传回数据为json，但是ajax看到数据是json然后就不进行解析。<br>emm不知道咋回事<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16327510937731632751093768.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16327510764991632751076489.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习之路</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC404一些原因</title>
    <link href="/2021/09/27/java%E7%9B%B8%E5%85%B3/SpringMVC404%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9B%A0/"/>
    <url>/2021/09/27/java%E7%9B%B8%E5%85%B3/SpringMVC404%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>一些基本原因：</p><ol><li>依赖库没有放到web的lib库当中，导致SpringMVC的Dispatch总分配器不能加载。</li><li>这边的RequestMapping没有放在方法的前面，emm，估计是脑袋瓜晕乎乎了&lt;/br&gt;<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16327440308511632744030849.png" alt="404原因"></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC的入门配置</title>
    <link href="/2021/09/20/java%E7%9B%B8%E5%85%B3/SpringMVC%E7%9A%84%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/09/20/java%E7%9B%B8%E5%85%B3/SpringMVC%E7%9A%84%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>SpringMVC的职权分配:</p><p>Controller:</p><ol><li>取得表单数据</li><li>调用业务逻辑</li><li>转向指定的页面</li></ol><p>Model:</p><ol><li>业务逻辑</li><li>保存数据的状态</li></ol><p>View：</p><ol><li>显示页面</li></ol><h2 id="原理图如下所示"><a href="#原理图如下所示" class="headerlink" title="原理图如下所示"></a>原理图如下所示</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321475646601632147564655.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321476211641632147621156.png" alt=""></p><p>执行流程解释</p><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。<br>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a><br>如上url拆分成三部分：</p><p> <a href="http://localhost:8080">http://localhost:8080</a> 表示服务器域名</p><p> SpringMVC   表示部署在服务器上的web站点</p><p> hello    表示控制器</p></li><li><p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p></li><li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p></li><li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p></li><li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p></li><li><p>Handler让具体的Controller执行。</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p></li><li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p></li><li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li></ol><p>最终视图呈现给用户。</p><p>因此我们现在开发一个网页，首先在web.xml完成Dispatcher的定义，即接收并且拦截所有的请求，代码如下：</p><h2 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在项目的整体架构如下所示<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321480731801632148073164.png" alt=""></p><p>接下来进行配置springmvc.xml</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321484085851632148408580.png" alt=""></p><p>实际代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.nomanker.controller.HelloController&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后一步，进入Controller层的编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;HelloSpringMVC!&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mv.setViewName(“hello”)指定了对应的视图，然后再交由视图解析器进行拼接</p><p>实现Controller接口Model存放数据，View指定对应的视图。</p><h2 id="使用注解简化"><a href="#使用注解简化" class="headerlink" title="使用注解简化"></a>使用注解简化</h2><p>简化之后的web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 扫描controller下的所有控制器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.nomanker.controller&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用默认的handler --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置对应的注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><br>使用注解开发，Controller的写法就可以简化成如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;Hello,SpringMVC&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//会被视图解析器处理</span><br>    &#125;<br>    <span class="hljs-meta">@RequstMapping(&quot;/hello1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello1</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;nomanker&quot;</span>,<span class="hljs-string">&quot;柯常仁&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello1&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划简单题</title>
    <link href="/2021/09/20/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E9%A2%98/"/>
    <url>/2021/09/20/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321440811951632144081190.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> down=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> downdown=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> ans=Math.min(down+cost[i-<span class="hljs-number">1</span>],downdown+cost[i-<span class="hljs-number">2</span>]);<br>            downdown = down;<br>            down =ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> down;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  递归的思想，爬到第n层楼梯最小花费的话，则值需要考虑爬到n-1和n-2层楼梯时候的花费，并且考虑爬出n-1层的花费和爬出n-2层的花费，记得，我们的目标是n层不是n-1层，虽然我也很蒙，对于这题来说的话，我真的蒙。。。</p><ol><li>整数划分<blockquote><p>给定一个正整数 n，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p></blockquote></li></ol><p>例子:<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入2 <br>输出：1<br>解释：1*1=1<br></code></pre></td></tr></table></figure><br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入3 <br>输出：2<br>解释：2*1=2<br></code></pre></td></tr></table></figure><br>其实这边的话，我们应该进行的判断,如果没有限制至少需要两个的话，我们可以进行处理，2的最大输出是2，3的最大输出是3，那我们如何判断4的最大输出呢？其对应的就是 1 <em> 3的最大结果， 2 </em> 2 的最大结果。那么对于5呢？也就是2<em>3的最大结果，1</em>4的最大结果，这时候单独的5已经不需要进行考虑了，因为2<em>3已经超过了。为此我们考虑到10，也仅仅需要考虑1 </em> 9,2 <em> 8,3 </em> 7,…,对应的代码如下所视：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] f= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        f[<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">4</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">2</span>;j&lt;=i-<span class="hljs-number">1</span>;j++)&#123;<br>                f[i]=Math.max(f[i-j]*f[j],f[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus配置</title>
    <link href="/2021/09/20/java%E7%9B%B8%E5%85%B3/MybatisPlus%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/09/20/java%E7%9B%B8%E5%85%B3/MybatisPlus%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_31762741/article/details/120342983?utm_source=app&amp;app_version=4.12.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">csdn学习笔记</a></p><blockquote><p>Mybatis plus学习笔记</p></blockquote><h2 id="创建springboot应用"><a href="#创建springboot应用" class="headerlink" title="创建springboot应用"></a>创建springboot应用</h2><blockquote><p>添加SQL中的Mybatis Famework<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321224381261632122438119.png" alt=""></p></blockquote><h2 id="进入项目，添加mybatis-plus依赖"><a href="#进入项目，添加mybatis-plus依赖" class="headerlink" title="进入项目，添加mybatis-plus依赖"></a>进入项目，添加mybatis-plus依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mybatis-plus --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="在application-yml进行配置"><a href="#在application-yml进行配置" class="headerlink" title="在application.yml进行配置"></a>在application.yml进行配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/user</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>   会进行创建对应的数据库连接并且放入到bean中交给spring进行统一的管理</p><h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321227023991632122702396.png" alt=""></p><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321228363121632122836311.png" alt=""></p><blockquote><p>此处添加Mapper接口进行配置</p><p>也可以在springboot类启动时进行@MapperScan扫描Mapper文件夹<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321229482461632122948241.png" alt=""></p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16321230235971632123023594.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟局域网VLAN概述</title>
    <link href="/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="以太网规模扩大带来的问题"><a href="#以太网规模扩大带来的问题" class="headerlink" title="以太网规模扩大带来的问题"></a>以太网规模扩大带来的问题</h2><pre><code>1. 广播风暴（每次传递都需要全世界传递，特别慢，浪费资源） 2. 难以维护和管理（太多交换机了） 3. 潜在的安全问题（消息往全世界发送）</code></pre><blockquote><p>解决办法:路由器隔离广播域</p></blockquote><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320597727021632059772693.png" alt=""></p><p>​    引发新问题：路由器的成本高</p><h3 id="VLAN的产生"><a href="#VLAN的产生" class="headerlink" title="VLAN的产生"></a>VLAN的产生</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320599128561632059912847.png" alt=""></p><h2 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h2><h3 id="添加标志（打标签）"><a href="#添加标志（打标签）" class="headerlink" title="添加标志（打标签）"></a>添加标志（打标签）</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320599879671632059987958.png" alt=""></p><p>​    &gt; 解决办法，收标签和去标签</p><h3 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h3><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320606399231632060639917.png" alt=""></p><h2 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320608232641632060823224.png" alt=""></p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320608885821632060888573.png" style="zoom:50%;" /></p><blockquote><p>结论：互联的Trunk端口的PVID值不等的时候，可能会造成转发错误</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>以太网交换机的生成树协议STP</title>
    <link href="/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/"/>
    <url>/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基本概念</p></blockquote><h2 id="为什么要增加冗余链路？"><a href="#为什么要增加冗余链路？" class="headerlink" title="为什么要增加冗余链路？"></a>为什么要增加冗余链路？</h2><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320586790421632058679039.png" alt=""></p><blockquote><p>问题所在：如果AB和AC断开的话，这样子的话就都没办法进行通信，会造成很大的影响</p></blockquote><p>​    在BC增加一条线路，可以增加整体的可靠性</p><h2 id="广播风暴（为什么）"><a href="#广播风暴（为什么）" class="headerlink" title="广播风暴（为什么）"></a>广播风暴（为什么）</h2><p>​    消息会一直重复转发，带来的影响</p><ol><li>消耗网络资源</li><li>主机重复收到广播帧</li><li>交换机的帧交换表的mac地址一直被覆盖重写</li></ol><blockquote><p>如何解决？</p></blockquote><h2 id="STP（生成树协议）"><a href="#STP（生成树协议）" class="headerlink" title="STP（生成树协议）"></a>STP（生成树协议）</h2><p>​    将原本的环路图，找到其对应的生成树，然后对其他的接口进行阻塞</p><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320591824831632059182477.png" style="zoom:67%;" /></p><pre><code>  物理拓扑发生改变的时候，交换机会进行生成树的重新计算</code></pre>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>以太网交换机自学习和转发帧的流程</title>
    <link href="/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>以太网交换机工作在<strong>数据链路层</strong>。</li><li>以太网交换机收到帧之后，在帧交换表中查找<strong>帧的目的MAC地址对应的接口号</strong>，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，刚插上电的时候，内部的帧交换表是空的。随着网络中各个主机的通信，以太网交换机通过<strong>自学习算法</strong>自动逐渐<strong>建立起帧交换表</strong>。</li></ul><h2 id="自学习的流程"><a href="#自学习的流程" class="headerlink" title="自学习的流程"></a>自学习的流程</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320568370831632056837075.png" alt=""></p><p>怎么复习：A发送给B的过程中，这两个交换机都做了什么事情？（复述）</p><blockquote><p>假设已经知道了这些接口的MAC地址—这边该怎么理解—</p></blockquote><p>B发送给A怎么样呢？</p><p>E-&gt;A又是怎么样呢？</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320571165751632057116569.png" alt=""></p><p>这时候G发送给A应该怎么办呢？</p><p>主机记录的话有时间限制？为什么呢？</p><p>因为对应的一个接口的话，会更换网卡。</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320577656711632057765662.png" alt=""></p><p>找到了就不会再继续往下找了</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320581017561632058101745.png" alt=""></p><h2 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320582049671632058204959.png" alt=""></p><p>MAC地址是指物理地址</p><h2 id="例题3："><a href="#例题3：" class="headerlink" title="例题3："></a>例题3：</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320583124141632058312384.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>集线器和交换机的区别</title>
    <link href="/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><h2 id="早期的总线型网络"><a href="#早期的总线型网络" class="headerlink" title="早期的总线型网络"></a>早期的总线型网络</h2><h2 id="使用双绞线和集线器HUB的星星以太网"><a href="#使用双绞线和集线器HUB的星星以太网" class="headerlink" title="使用双绞线和集线器HUB的星星以太网"></a>使用双绞线和集线器HUB的星星以太网</h2><ol><li>集线器在逻辑上仍然是一个总线网</li><li>集线器只工作在物理层</li><li>少量的容错能力和网络管理能力 </li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320528500501632052850045.png" alt="两种网络"></p><h2 id="使用集线器HUB在物理层扩展以太网"><a href="#使用集线器HUB在物理层扩展以太网" class="headerlink" title="使用集线器HUB在物理层扩展以太网"></a>使用集线器HUB在物理层扩展以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320532022991632053202293.png" alt="更大的碰撞域"></p><h2 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h2><blockquote><p>前提：忽略ARP过程，假设交换机的帧交换表”已经学习好“</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320534548201632053454816.png" alt=""><br>工作原理：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320536120891632053612080.png" alt=""></p></blockquote><h2 id="扩大广播率隔离碰撞率（利用交换机和集线器-lt-逻辑上相连-gt-）"><a href="#扩大广播率隔离碰撞率（利用交换机和集线器-lt-逻辑上相连-gt-）" class="headerlink" title="扩大广播率隔离碰撞率（利用交换机和集线器&lt;逻辑上相连&gt;）"></a>扩大广播率隔离碰撞率（利用交换机和集线器&lt;逻辑上相连&gt;）</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320539176801632053917673.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IP地址</title>
    <link href="/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>ip地址分成两个部分</p><ol><li>网络编号：标识因特网上数以万计的网络</li><li>标识同一网络下不同的主机或者路由器的各个接口</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mac地址</title>
    <link href="/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/mac%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/mac%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>MAC 地址就像自己的 ID 号，而 IP 地址就像带着邮政编码的住址</p></blockquote><p>使用点对点的数据链路层不需要使用地址</p><p>广播信道传输的话，需要知道对方的地址：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1632037409538-1632037409525.png" alt=""></p><ul><li>当多个主机链接在同一个广播地址上，想要实现两个主机之前的通信，则每个主机都必须要有一个唯一的标识，即一个数据链路层地址</li></ul><p>MAC(Media Access Control)媒体接入控制的用户一般包含  有线网卡和无线网卡  </p><p>但是交换机和路由器往往有很多的网络接口，所以有很多的<strong>mac地址</strong>，所以严格上说mac地址是对网络上各个接口的唯一标识，而不是对网络上设备的唯一标识<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320375867951632037586785.png" alt=""></p><ul><li>mac地址48位，也就是6个字节</li><li>前三个字节是IEEE注册管理机构分配的</li><li>然后厂商拿到这个分配的之后，可以自行分配后面的三位</li></ul><p>mac地址的形式<br>利用16进制进行表示<br>16进制的话，每个16进制代表4位，所以，mac地址一般有12位</p><p>例子：<br> 00-0c-cf-93-8c-92<br>mac地址其实只需要保证在ip内不重复就可以了。</p><h2 id="随机mac地址："><a href="#随机mac地址：" class="headerlink" title="随机mac地址："></a>随机mac地址：</h2><pre><code>检测mac地址可以监视到每个人的行动</code></pre><h2 id="单播地址，多播地址"><a href="#单播地址，多播地址" class="headerlink" title="单播地址，多播地址"></a>单播地址，多播地址</h2><blockquote><p>当48位(FF-FF-FF-FF-FF-FF)位全部为1，则代表是一个广播地址</p></blockquote><h2 id="mac地址的发送顺序"><a href="#mac地址的发送顺序" class="headerlink" title="mac地址的发送顺序"></a>mac地址的发送顺序</h2><blockquote><p>第一字节到第六字节<br>b0位到b7位<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320378829491632037882940.png" alt=""></p></blockquote><h2 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320380466201632038046612.png" alt="如何封装成为单播帧"></p><h2 id="广播Mac地址举例"><a href="#广播Mac地址举例" class="headerlink" title="广播Mac地址举例"></a>广播Mac地址举例</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320381470581632038147049.png" alt="封装广播帧进行匹配"></p><h2 id="多播地址"><a href="#多播地址" class="headerlink" title="多播地址"></a>多播地址</h2><blockquote><p>快速判断的方法</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320382564141632038256411.png" alt=""></p><p> 多播帧的应用举例如下<br> <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320383178311632038317824.png" alt=""></p><p> 该多播帧会被主机B，C接收，不会被主机D接收</p><h2 id="什么是随机mac地址技术"><a href="#什么是随机mac地址技术" class="headerlink" title="什么是随机mac地址技术"></a>什么是随机mac地址技术</h2><h1 id="ip地址的相关内容"><a href="#ip地址的相关内容" class="headerlink" title="ip地址的相关内容"></a>ip地址的相关内容</h1><blockquote><p>ip地址的作用</p></blockquote><p> ip地址用来标识两部分信息</p><ol><li>网络编号：标识因特网上数以万计的网络</li><li>主机编号：标识同一个网络上不同的主机（或者是路由器的各个接口）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320397834081632039783399.png" alt=""></p><h2 id="从网络体系结构上看ip地址和mac地址"><a href="#从网络体系结构上看ip地址和mac地址" class="headerlink" title="从网络体系结构上看ip地址和mac地址"></a>从网络体系结构上看ip地址和mac地址</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320399859641632039985955.png" alt=""></p><h2 id="数据包转发过程中IP地址和mac地址的变化情况"><a href="#数据包转发过程中IP地址和mac地址的变化情况" class="headerlink" title="数据包转发过程中IP地址和mac地址的变化情况"></a>数据包转发过程中IP地址和mac地址的变化情况</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320401887281632040188717.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320402459051632040245896.png" alt=""></p><p>如何通过IP地址找出mac地址</p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320405679951632040567987.png" alt=""></p><p>如果未找到怎么办<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320406138771632040613872.png" alt="发送报文"></p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320406913711632040691346.png" alt=""></p><p>ARP高速缓存表当中包含静态和动态的，这个该怎么理解？</p><ol><li>动态：自动获取，生命周期分成两种</li><li>静态：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或者系统重启后仍然有效</li></ol><h2 id="一段段使用ARP协议"><a href="#一段段使用ARP协议" class="headerlink" title="一段段使用ARP协议"></a>一段段使用ARP协议</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320409814131632040981405.png" alt=""></p><h2 id="ARP攻击是什么意思"><a href="#ARP攻击是什么意思" class="headerlink" title="ARP攻击是什么意思"></a>ARP攻击是什么意思</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16320429642631632042964260.png" alt=""></p><p>即接收到pc1的请求时候不进行丢弃，然后伪装成ip2，发送mac3的，这样子会对之前arp高速缓存表中的数据进行覆盖，这样子，下次发送给ip2的消息就会发送到pc3那里去，pc3就完成了一次欺骗</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划系列题目</title>
    <link href="/2021/09/16/leetcode/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <url>/2021/09/16/leetcode/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<p>优化:滚动数组，从后往前读</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631785121431-1631785121422.png" alt=""></p><p>这边会面临一个问题：</p><ul><li>采用一维数组进行优化的时候，值会进行覆盖，所以也可以采用动态数组的方式进行优化，但是这题有一个奇妙的地方，从后往前的话就不会造成覆盖</li></ul><p>从后往前读<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,rowIndex+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;rowIndex+<span class="hljs-number">1</span>;i++&#123;<br>        ans[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>        ans[i]=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j:=i<span class="hljs-number">-1</span>;j&gt;<span class="hljs-number">0</span>;j--&#123;<br>            ans[j]=ans[j<span class="hljs-number">-1</span>]+ans[j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></p><p>滚动数组<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> cur,pre []<span class="hljs-keyword">int</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;rowIndex+<span class="hljs-number">1</span>;i++&#123;<br>        cur = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,rowIndex+<span class="hljs-number">1</span>)<br>        cur[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>        cur[i]=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;i;j++&#123;<br>            cur[j]=pre[j<span class="hljs-number">-1</span>]+pre[j]<br>        &#125;<br>        pre = cur<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http包理解</title>
    <link href="/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E5%8C%85%E7%90%86%E8%A7%A3/"/>
    <url>/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E5%8C%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。</p><p>首先调用Http.HandleFunc</p><p>按顺序做了几件事：</p><ol><li><p>调用了DefaultServeMux的HandleFunc</p></li><li><p>调用了DefaultServeMux的Handle</p></li><li><p>往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则</p></li><li><p>其次调用http.ListenAndServe(“:9090”, nil)</p></li></ol><p>按顺序做了几件事情：</p><ol><li><p>实例化Server</p></li><li><p>调用Server的ListenAndServe()</p></li><li><p>调用net.Listen(“tcp”, addr)监听端口</p></li><li><p>启动一个for循环，在循环体中Accept请求</p></li><li><p>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()</p></li><li><p>读取每个请求的内容w, err := c.readRequest()</p></li><li><p>判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux</p></li><li><p>调用handler的ServeHttp</p></li><li><p>在这个例子中，下面就进入到DefaultServeMux.ServeHttp</p></li><li><p>根据request选择handler，并且进入到这个handler的ServeHTTP</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mux.handler(r).ServeHTTP(w, r)<br></code></pre></td></tr></table></figure></li><li>选择handler：</li></ol><p>A. 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）</p><p>B. 如果有路由满足，调用这个路由handler的ServeHTTP</p><p>C. 如果没有路由满足，调用NotFoundHandler的ServeHTTP</p>]]></content>
    
    
    <categories>
      
      <category>go语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>存储器扩展</title>
    <link href="/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/"/>
    <url>/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><blockquote><p>数据线从8位扩展成16位（人话：原本只能存储8位数据，现在可以存储的数据为16位）</p></blockquote><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>archlinux配置中文输入法</title>
    <link href="/2021/09/12/linux%E7%9B%B8%E5%85%B3/archlinux%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    <url>/2021/09/12/linux%E7%9B%B8%E5%85%B3/archlinux%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Sy<br></code></pre></td></tr></table></figure><p>配置中文输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S fcitx fcitx-im<br>sudo pacman -S fcitx-configtools   <span class="hljs-comment">#图形配置工具</span><br>sudo pacman -S sunpinyin    <span class="hljs-comment">#输入法</span><br></code></pre></td></tr></table></figure><p>注解：</p><p>​    特定用户，还可以在~/.bashrc、~/.xinitrc或~/.xprofile中设置自己    的用户环境。不同之处在于：<br>​        .bashrc: 每次终端登录时读取并运用里面的设置。<br>​        .xinitrc: 每次startx启动X界面时读取并运用里面的设置<br>​        .xprofile: 每次使用gdm等图形登录时读取并运用里面的设置</p><p>编辑这个图形界面启动时加载的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim ~/.xprofile<br></code></pre></td></tr></table></figure><p>添加内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GTK_IM_MODULE=fcitx<br><span class="hljs-built_in">export</span> QT_IM_MODULE=fcitx<br><span class="hljs-built_in">export</span> XMODIFIERS=<span class="hljs-string">&quot;@im=fcitx</span><br></code></pre></td></tr></table></figure><p> 最后，重新登录，找到fcitx，修改配置，添加Pinyin输入法，Ctrl+Space或者自己自定义修改快捷键</p>]]></content>
    
    
    <categories>
      
      <category>archlinux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>38译码器</title>
    <link href="/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/38%E8%AF%91%E7%A0%81%E5%99%A8/"/>
    <url>/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/38%E8%AF%91%E7%A0%81%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="三八译码器"><a href="#三八译码器" class="headerlink" title="三八译码器"></a>三八译码器</h1><div class="table-container"><table><thead><tr><th>A2</th><th>A1</th><th>A0</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td></tr><tr><td>0</td><td>1</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>0</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td>0</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td>1</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>0</td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><script type="math/tex; mode=display">\begin{aligned}    O_0=\overline{A2}\ \overline{A1}\ \overline{A0} \\    O_1=\overline{A2}\ \overline{A1}\ A0 \\    O_2=\overline{A2}\ A1\ \overline{A0} \\    O_3=\overline{A2}\ A1 A0 \\    O_4=A2 \overline{A1}\ \overline{A0} \\    O_5=A2 \overline{A1}\ A0 \\    O_6=A2 A1 \overline{A0} \\    O_7=A2A1A0\end{aligned}</script><p>个人理解：</p><blockquote><p>输入0，第0号位的灯亮</p><p>输入1，第1号的灯亮</p><p>三位恰好是8个数</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>存储器</title>
    <link href="/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2021/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="静态RAM电路的基本电路"><a href="#静态RAM电路的基本电路" class="headerlink" title="静态RAM电路的基本电路"></a>静态RAM电路的基本电路</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360308025971636030802573.png" style="zoom: 50%;" /></p><p>​    $ T_1…T_4 $代表的是<em>触发器</em></p><p>​    $T_5,T_6$代表的是<em>行选择器</em></p><p>​    $T_7,T_8$代表的是<em>列选择器</em></p><p>​    只有当$T_5-T_8$<em>全部闭合</em>的时候，读的信号才能送入到四个触发器储存起来，同时<em>写选择</em>需要经过<em>取反</em>，是为了满足A’和A是<em>相反</em>的。</p><hr><h2 id="芯片举例"><a href="#芯片举例" class="headerlink" title="芯片举例"></a>芯片举例</h2><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360316956701636031695645.png" style="zoom:50%;" /></p><p>​    地址线为$ A_0-A_9$即地址线有10根，可以寻址的范围为$0-2^{10}$,数据线为$O_1-O_4$即存储的大小为4位，也就是说该芯片的<em>存储容量</em>为 $2^{10}\cdot4$  位，即$1K \cdot 4$位。</p><h2 id="Intel-2114RAM矩阵-64-64-读"><a href="#Intel-2114RAM矩阵-64-64-读" class="headerlink" title="Intel 2114RAM矩阵(64*64)读"></a>Intel 2114RAM矩阵(64*64)读</h2><p>​    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360321600061636032159951.png" style="zoom:50%;" /></p><blockquote><p>任务：看懂这个图，明白行选择0和列选择0代表的是什么意思</p></blockquote><p>​    分成四组，也就是代表了读出数据的4位。</p><p>​    64 等于 $2^6$ ,即 64x64 等于 $2^{12}$  位，然后分配成 4 组，即$2^{12}\div2^2=2^{10}$ ,也就是 10 根地址线。</p><blockquote><p>每个格子代表一位，qaq，我真的看不懂。。。。。</p></blockquote><p>​    行选择为 0 ，第 0 行全部被连通行信号，列选择为 0 ，代表的是 4 组中的每小组的第 0 列均导通列信号，</p><p>​    因此，当行选择 0 ，列选择 0 的话，就会从第0行的 $0,16,32,48$ 进行读出或者存入 </p><blockquote><p>思考，如果是给定的行为 1 ，列为 1 的话，读取的是哪个</p></blockquote><p>​    解: 行为 1 ，第 1 行全部打开，然后从每一组的 1 列读取信号，所以读取的应该是 第 1 行的 $1,17,33,49$   这四位。</p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><ol><li><p>动态 RAM 基本单元电路</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360392421221636039242084.png" style="zoom:33%;" /></p><p>​    读出的时候，子线上为高电平，如果$C_s$有电荷，那么经过 T 便会在数据线上产生高电流；如果$C_s$没有电荷，那么经过 T ，数据线不电流，代表读出 0 。（破坏性读出，必须再生）</p><p>​    写入的时候，同理可得。</p></li><li><p>三管动态 RAM 芯片(读)</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16360398199831636039819947.png" style="zoom: 33%;" /></p><blockquote><p>读取第 0 行，第 0 列的数据，如何进行处理？</p></blockquote><p>首先行给出 0 ，列给出 0 ，然后 0 行的读选择线打开，然后列选择线给出第0 列，选择交叉点进行读操作</p></li></ol><h2 id="CPU和存储器的连接"><a href="#CPU和存储器的连接" class="headerlink" title="CPU和存储器的连接"></a>CPU和存储器的连接</h2><blockquote><p>cpu的地址线多余存储器，如何解决该问题？</p></blockquote><ol><li><p>多个存储器连接在一起</p><ol><li>位扩展</li></ol></li></ol><ol><li>字扩展</li></ol><ol><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>archlunix安装中遇到的问题</title>
    <link href="/2021/09/12/linux%E7%9B%B8%E5%85%B3/archlunix%E5%AE%89%E8%A3%85%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/12/linux%E7%9B%B8%E5%85%B3/archlunix%E5%AE%89%E8%A3%85%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>archlinux 安装的一些坑</p><ol><li><p>安装tim和qq的时候记得注释掉pacman.d里面的multul库，这里面因为archlinuxcn这边安装软件的很多依赖在这里面</p></li><li><p>网络管理器(NetworkManager)未运行，添加小部件到右下角</p><p>​    直接运行重启网络管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart NetworkManager<br></code></pre></td></tr></table></figure></li><li><p>在archlinux这边，正常步骤</p><ul><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip link<br></code></pre></td></tr></table></figure></li><li><p>进行端口扫描，找到wlan的端口，我这边是wlp0s20f3</p></li></ul></li></ol><pre><code>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip link <span class="hljs-built_in">set</span> wlp0s20f3 up<br></code></pre></td></tr></table></figure>  - 开启这个端口，如果遇到错误提示rfkill的话   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rfkill list<br></code></pre></td></tr></table></figure>  - 查看整个，发现存在yes，利用如下指令进行关闭  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rfkill unblock all<br></code></pre></td></tr></table></figure>  - 完成后，继续ip link set wlp0s20f3 up</code></pre><ol><li><p>然后使用iwlist wlp0s20f3 scan进行扫描，记住这边似乎需要用到root权限，不然扫描不出结果</p></li><li><p>iwlist wlp20f3 scan|grep ESSID 进行管道流筛选</p></li><li><p>wpa_passphrase wifi名称 wifi密码  &gt; internet.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#例子  wifi名称   wife1</span><br><span class="hljs-comment">#wifi 密码   123456</span><br>wpa_passphrase wifi1 123456 internet.conf<br></code></pre></td></tr></table></figure></li><li><p>wpa_supplicant -c internet.conf -i wlp0s20f3 &amp;</p></li><li><p>&amp;代表在后台运行</p></li></ol><ol><li>最快捷的方法，手机共享热点，开启dhcpcd可以直接进行连接</li><li>电脑不要进行强制断电，关于archlinux的grep引导会消失了，这点就很难受。</li></ol>]]></content>
    
    
    <categories>
      
      <category>archlinux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git一些常用命令集合</title>
    <link href="/2021/09/12/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/git%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <url>/2021/09/12/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/git%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>git配置用户名，邮箱和查看配置列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name nomanker<br>git config --global user.email 770787086@qq.com<br>git config --list<br></code></pre></td></tr></table></figure><p>git配置ssh密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;770787086@qq.com&quot;</span><br>cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>git避免多次输入密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global credential.helper store<br></code></pre></td></tr></table></figure><p>git配置终端代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;http://127.0.0.1:8889&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;https://127.0.0.1:8889&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git命令</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DFA的确定化和最小化是怎么进行的？</title>
    <link href="/2021/09/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/DFA%E7%9A%84%E7%A1%AE%E5%AE%9A%E5%8C%96%E5%92%8C%E6%9C%80%E5%B0%8F%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
    <url>/2021/09/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/DFA%E7%9A%84%E7%A1%AE%E5%AE%9A%E5%8C%96%E5%92%8C%E6%9C%80%E5%B0%8F%E5%8C%96%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本博客按照知乎所做的笔记"><a href="#本博客按照知乎所做的笔记" class="headerlink" title="本博客按照知乎所做的笔记"></a>本博客按照知乎<img src="https://zhuanlan.zhihu.com/p/31166841" alt="知乎链接">所做的笔记</h2><h2 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631373060681-1631373060673.png" alt=""></p><blockquote><p>N代表非终结符号</p></blockquote><ol><li><p>N{q0}</p><p>A{q1,q2,q3}</p></li><li><p>采用a进行分割，q1,q2,q3接收a，仍在A集合内,无效</p><p>采用b进行分割，q1,q2,q3接收b，仍在A集合内，无效</p><p>采用c进行分割，q1,q2,q3接收c，仍在A集合内，无效&lt;/br&gt;</p><p>因此q1,q2,q3是等价的<br>动作表:</p></li></ol><div class="table-container"><table><thead><tr><th>状态\动作</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q2</td><td>q3</td></tr><tr><td>q2</td><td></td><td>q2</td><td>q3</td></tr><tr><td>q3</td><td></td><td>q2</td><td>q3</td></tr></tbody></table></div><p>q1,q2,q3等价，进行替换之后为</p><div class="table-container"><table><thead><tr><th>状态\动作</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q1</td><td>q1</td></tr><tr><td>q1</td><td></td><td>q1</td><td>q1</td></tr><tr><td>q1</td><td></td><td>q1</td><td>q1</td></tr></tbody></table></div><p>近一步化简</p><div class="table-container"><table><thead><tr><th>状态\动作</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q1</td><td>q1</td></tr></tbody></table></div><p>即最后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631373662215-1631373662213.png" alt=""></p><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2:"></a>例题2:</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631373732052-1631373732048.png" alt=""></p><p>终结符号集合N{q3,q5}</p><p>非终结符号集合A{q0,q1,q2，q4}</p><div class="table-container"><table><thead><tr><th>状态\动作</th><th>f</th><th>e</th><th>i</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q2</td><td>q4</td></tr><tr><td>q2</td><td></td><td>q3</td><td></td></tr><tr><td>q3</td><td></td><td></td><td></td></tr><tr><td>q4</td><td></td><td>q5</td><td></td></tr><tr><td>q5</td><td></td><td></td></tr></tbody></table></div><p>显而易见  q3和q5为等价状态</p><ul><li>f，i没办法对A产生分割</li><li>采用e产生分割</li></ul><p>N{q3,q5}</p><p>A{q0,q1}</p><p>B{q2,q4}</p><p>如状态表所表示：</p><ul><li>动作e和i均可以对A集合中的q0和q1进行分割</li></ul><p>N{q3,q5}</p><p>A{q0}</p><p>B{q1}</p><p>C{q2,q4}</p><ul><li>q2和q4因为q3和q5的等价所以也等价，步骤完成，进行状态表的替换</li><li>即q3替换q5，q2替换q4</li></ul><p>简化之后的状态表如下：</p><div class="table-container"><table><thead><tr><th>状态\动作</th><th>f</th><th>e</th><th>i</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q2</td><td>q4</td></tr><tr><td>q2</td><td></td><td>q3</td><td></td></tr><tr><td>q3</td><td></td><td></td><td></td></tr><tr><td>q4</td><td></td><td>q3</td></tr></tbody></table></div><p>进一步简化</p><div class="table-container"><table><thead><tr><th>状态\动作</th><th>f</th><th>e</th><th>i</th></tr></thead><tbody><tr><td>q0</td><td>q1</td><td></td><td></td></tr><tr><td>q1</td><td></td><td>q2</td><td>q2</td></tr><tr><td>q2</td><td></td><td>q3</td><td></td></tr><tr><td>q3</td><td></td><td></td></tr></tbody></table></div><p>最终结果图</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631374872965-1631374872964.png" alt=""></p><p>算法原理和实现：</p><blockquote><p>我现在只会写题，哭了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一位八位数码管是怎么实现的</title>
    <link href="/2021/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <url>/2021/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%AB%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三态门</title>
    <link href="/2021/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E6%80%81%E9%97%A8/"/>
    <url>/2021/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E6%80%81%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 text-align:center color:red>三态门</h1><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631341892208-1631341892205.png" alt=""><br>|开关|In|O|<br>|—|—|—|<br>|0|0|未接通|<br>|0|1|未接通|<br>|1|0|0|<br>|1|1|1|</p><blockquote><p>即开关断开的时候，三态门处于断开状态</p></blockquote><h2 id="寄存器传值"><a href="#寄存器传值" class="headerlink" title="寄存器传值"></a>寄存器传值</h2><blockquote><p>涉及总线问题<br>—暂时放着还没明白—</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内核级别线程</title>
    <link href="/2021/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%A7%E5%88%AB%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%A7%E5%88%AB%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>为什么要引入内核级别线程？<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16355933702981635593370272.png" alt=""><br>因为对于多处理器的话，如果每个CPU对应自己的一个Cache和MMU，那么对于一个进程里面的多个线程，我们没办法将这些线程分配到多个cpu去进行执行，因为对于这些CPU来说，它们只能看到进程，看不到线程在干啥。</p><p>而如果是对于第二种情况，多个cpu共享一个Cache和MMU，那么就符合多线程的定义，多个线程共同使用一个Cache和MMU，如此的话，每个线程就可以分配到一个cpu进行，那么的话，对于一个进程可以利用到多个cpu进行执行，就可以加快这一个进程的执行 速度。</p><p>一套栈具体指向<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16355942163501635594216296.png" alt=""></p><p>开启内核中的切换  switch_to</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16355943035161635594303485.png" alt=""></p><p>PC的值是ip，是线程T的ip，CS是线程T所在的ip，底下<code>？？？？</code>是包含iret的汇编代码</p><blockquote><p>内核态其实就只执行一小段的代码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>链路层是面对各个网络节点之间的通信。</p></blockquote><p>网络节点是什么东西？</p><blockquote><p>网络节点是指运行链路层协议的任何设备</p></blockquote><h2 id="链路层是如何实现的"><a href="#链路层是如何实现的" class="headerlink" title="链路层是如何实现的"></a>链路层是如何实现的</h2><blockquote><p>链路层是<strong>软件</strong>和<strong>硬件</strong>的结合体，链路层的主体部分是在<strong>网络适配器</strong>，又叫<strong>网络接口</strong>卡上实现的，而位于网络适配器的核心是<strong>链路层控制器</strong>，该控制器是实现了众多链路层服务的专用芯<br>片，因此链路层的许多功能是硬件实现的，但仍有部分链路层是由运行与主机CPU 上的软件<br>中实现的，它们实现了高层链路层功能，如：组装链路层寻址信息和激活控制器硬件。</p></blockquote><h2 id="封装成帧理解："><a href="#封装成帧理解：" class="headerlink" title="封装成帧理解："></a>封装成帧理解：</h2><ol><li>将网络层下来的数据封装成帧</li><li>所能包装的数据部分有长度上限  MTU（Maximun Transfer Unit）</li><li>帧有个开始符号SOH（01）和结束符号EOT（04)，帧定界<br>如下：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631273604291-1631273604290.png" alt=""><br>接收端如果只查看到了SOH但是没有接收到EOT的话，该帧就会被抛弃</li></ol><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p>对上传传输的数据没有任何的限制</p></blockquote><p>问题所在：<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631273839910-1631273839907.png" alt=""></p><blockquote><p>遇到EOT会提前结束帧，造成传输数据的错误</p><p>解决办法：<br>加入转义字符ESC（1B）<br>如果读到ESC那么后面的EOT就不会当成控制符号<br>如果连续读到两个ESC，那么就删除前面一个<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631274446763-1631274446761.png" alt=""></p><ol><li>面向字节的物理链路层使用字节填充的方法实现透明传输</li><li>面向bit的物理链路层采用bit填充的方法实现透明传输</li></ol></blockquote><p>例题：<br>HDLC协议对0111110001111110组帧之后对应的bit串为</p><p>高级数据链路控制协议HDLC采用帧头和帧尾中的标志字段作为帧定界符，其值为<strong>01111110</strong>，所以在帧数据后面，封装成帧的时候，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631683062329-1631683062327.png" alt=""></p><p>到了目的地拿出帧的时候，每读到5个1，下一个0就不读</p><h2 id="差错检查"><a href="#差错检查" class="headerlink" title="差错检查"></a>差错检查</h2><blockquote><p>传输过程中传输产生错误怎么办？</p></blockquote><p>循环冗余检验<br>例子：对数据进行类似求和之后获得一个值，跟在数据段后面，接收端接收到数据便可以对接收到的数据进行求和，看值是否一致，从而可以判断传输的数据是否完整。</p><p>模2除法:</p><blockquote><p>按照模2 除法运算法则，那么余数首位是1就商1，是0就商0</p></blockquote><p>例子1：<br>    <img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631279503286-1631279503274.png" alt=""></p><p>例子2 被校验的数据M（x）=1000，该数据的循环冗余校验和应该为多少？</p><p>答：其选择生成多项式为</p><script type="math/tex; mode=display">G（x）=x^3+x+1</script><p>生成式子为4位二进制，则CRC的规则应该取（4-1）=3位，所以预加3位可以得到</p><script type="math/tex; mode=display">1000B*2^3=1000 000B</script><p>1000 000B(被除数)对1011（除数）做模2除法,得到余数101B</p><h2 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h2><ol><li>如果向上层提供的是不可靠的服务，那么该帧直接丢弃即可（音频，视频）</li><li>如果提供的是可靠服务，那么该帧还需要重传（代码）<ul><li>发一个通知帧，然后重发</li><li>此传输过程并不简单</li></ul></li><li><p>一般情况下，有线链路的误码率比较低，为了减小开销，不要求数据链路层向上提供有效服务，即使出现了误码，可靠传输的问题由其上层解决</p></li><li><p>无线电路容易受到干扰，因此<strong>数据链路层</strong>必须向上层提供 <strong>可靠的传输服务</strong></p></li></ol><blockquote><p>比特差错只是传输错误当中的一种<br>传输错误还包括分组丢失，失序，重复，这些错误一般出现在数据链路层的上层</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown中的latex语法</title>
    <link href="/2021/09/10/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/markdown%E4%B8%AD%E7%9A%84latex%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/10/%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3/markdown%E4%B8%AD%E7%9A%84latex%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>分数的表示方法</p><script type="math/tex; mode=display">\frac{1MB}{1Mbps}=\frac{1*2^{20}*8bit}{1*10^{3}bit/s}=8.388608s</script>]]></content>
    
    
    <categories>
      
      <category>latex</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络性能指标</title>
    <link href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ol><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延</li><li>时延带宽积</li><li>往返时间</li><li>利用率</li><li>丢包率</li></ol><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631237058200-1631237058190.png" alt=""></p><blockquote><p>一些单位的差异<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631237208252-1631237208247.png" alt=""></p></blockquote><p>例题1：有一个待发送的数据块，大小为100MB，网卡发送的速率为100Mps，则网卡发送完该数据块需要多长的时间</p><p>答：</p><script type="math/tex; mode=display">\frac{100MB}{100Mbps}=\frac{1MB}{1Mbps}=\frac{1*2^{20}*8bit}{1*10^{3}bit/s}=8.388608s</script><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238360662-1631238360642.png" alt=""></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238420079-1631238420068.png" alt=""></p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238615898-1631238615892.png" alt=""></p><p>例题<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238732725-1631238732716.png" alt=""></p><blockquote><p>具体问题具体分析</p></blockquote><h2 id="时延带宽积-时延-带宽"><a href="#时延带宽积-时延-带宽" class="headerlink" title="时延带宽积=时延*带宽"></a>时延带宽积=时延*带宽</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238880968-1631238880962.png" alt=""></p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631238979349-1631238979342.png" alt=""></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631239069856-1631239069843.png" alt=""></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><blockquote><p>丢失的分组占总的分组</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631239184690-1631239184681.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络的定义和分类</title>
    <link href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><blockquote><p>一些<strong>互连</strong>，<strong>自治</strong>，的计算机<strong>集合</strong><br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631236354492-1631236354479.png" alt=""></p></blockquote><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631236605019-1631236605008.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三种交换方式</title>
    <link href="/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="电路交换-Circuit-Switching"><a href="#电路交换-Circuit-Switching" class="headerlink" title="电路交换 Circuit Switching"></a>电路交换 Circuit Switching</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631235220668-1631235220664.png" alt="问题所在"></p><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631235267888-1631235267887.png" alt="解决办法"></p><p>三个步骤：</p><ol><li>建立连接</li><li>通话（一直占用通信资源）</li><li>释放连接<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631235362962-1631235362957.png" alt=""></li></ol><blockquote><p>对应的联想关键词<br><strong>占线忙</strong>  <strong>传输效率低</strong></p><p>计算机可以使用电路交换进行计算机数据的传输，效率低</p></blockquote><h2 id="分组交换-Packet-Switching"><a href="#分组交换-Packet-Switching" class="headerlink" title="分组交换 Packet Switching"></a>分组交换 Packet Switching</h2><blockquote><p>首部，目的地的地址</p><p>原数据进行分组，添加首部<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631235590180-1631235590173.png" alt=""></p><p>经过不同的路径到达目的地</p><p>分组到达的顺序与原本数据不同   （<strong>如何解决</strong>）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631235780343-1631235780340.png" alt=""></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><blockquote><p>数据没有限制大小，路由器需要有很大的缓存空间</p></blockquote><h2 id="三种方式的对比"><a href="#三种方式的对比" class="headerlink" title="三种方式的对比"></a>三种方式的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631236162560-1631236162553.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络概述</title>
    <link href="/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/1631201053788-1631201053780.png" alt=""></p><ol><li>网络是由若干个<strong>节点</strong>和连接这些节点的<strong>Link</strong>组成</li><li>多个网络通过<strong>路由器</strong>连接起来，构成更大的网络</li></ol><blockquote><p>关键单词：网络的定义，不同网络之间怎么进行连接</p></blockquote><p>internet（互联网或者互连网）</p><p>Internet(因特网)</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分治算法</title>
    <link href="/2021/09/07/leetcode/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/07/leetcode/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h2><p>例子   <script type="math/tex">5=1+1+1+1+1；</script></p><pre><code>  $$5=2+1+1+1;$$  $$5=3+1+1;$$  $$5=3+2$$  $$5=4+1$$</code></pre><p>q(m,n)代表可以将</p><script type="math/tex; mode=display">q(9,4)=q(9,3)+q(5,4)</script><p>即组合的最大数为4可以组合成9的话，那么可以组合成的方法考虑，用组合数中最大数为3来进行组成，这是已经求解出来的，然后再加上去如果最大数是4，那么我们找到，哪些东西可以组合成5也就是q(5,4)</p><p>通过递归完成二分搜索<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">biSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(A[mid]==x) <span class="hljs-keyword">return</span> mid;<br>  <span class="hljs-keyword">if</span>(A[mid]&lt;x)&#123;<br>    <span class="hljs-comment">//查找后一半</span><br>    <span class="hljs-built_in">biSearch</span>(mid+<span class="hljs-number">1</span>,r,x);<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A[mid]&gt;x)&#123;<br>    <span class="hljs-built_in">biSearch</span>(l,mid<span class="hljs-number">-1</span>,x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对应的查找如下</p><script type="math/tex; mode=display">A[0]...A[m-1]A[m] A[m+1]...A[n-1]</script><p>时间复杂度计算</p><script type="math/tex; mode=display">T(n)= aT(n/b)+f(n)      = T(n/2)+O(1)</script><p>其中<script type="math/tex">a=1,b=2,n^d=1</script>,即<script type="math/tex">a=b^n</script>成立</p><script type="math/tex; mode=display">  =>T(n)= O(n^dlogn)=O(n^0logn)=log(n)</script><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p>int : -32768-32767 范围的整数</p><script type="math/tex; mode=display">XY= AC*2^n+(AD+BC)*2^n/2 +BD</script><script type="math/tex; mode=display">T(n)=4T(n/2)+O(n)</script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/09/07/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/09/07/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划要解决的事情通常是完成一个具体的目标，而这个目标通常是最优解，并且：</p><ol><li>阶段直接可以进行转移，这叫做动态</li><li>达到一个<strong>可行解（目标阶段）</strong>需要不断地转移，那么如何才能达到<strong>最优解</strong>？这叫规划</li></ol><p>每个阶段抽象为状态（用圆圈来表示），状态之间可能会发生转化（用箭头表示）。可以画出类似如下的图：</p><h1 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/20210907104509.png" alt="动态规划图片"></p><h3 id="通过函数来描述问题，并通过函数的调用关系来描述问题间的关系就是记忆化递归的核心内容。"><a href="#通过函数来描述问题，并通过函数的调用关系来描述问题间的关系就是记忆化递归的核心内容。" class="headerlink" title="通过函数来描述问题，并通过函数的调用关系来描述问题间的关系就是记忆化递归的核心内容。"></a>通过函数来描述问题，并通过函数的调用关系来描述问题间的关系就是记忆化递归的核心内容。</h3><p>每一个动态规划问题，实际上都可以抽象为一个数学上的函数。这个函数的自变量集合就是题目的所有取值，值域就是题目要求的答案的所有可能。我们的目标其实就是填充这个函数的内容，使得给定自变量 x，能够唯一映射到一个值 y。（当然自变量可能有多个，对应递归函数参数可能有多个）</p><h3 id="根据定义域填充值域"><a href="#根据定义域填充值域" class="headerlink" title="根据定义域填充值域"></a>根据定义域填充值域</h3><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/20210907105108.png" alt=""></p><p>我们定义一个递归函数 f(n)，用 f(n) 来描述问题。就和使用普通动态规划 f[n] 描述问题是一样的，这里的 f 是 dp 数组。</p><p>例子切入</p><blockquote><p>一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？</p></blockquote><p>由于第 n 级台阶一定是从 n - 1 级台阶或者 n - 2 级台阶来的，因此到第 n 级台阶的数目就是 到第 n - 1 级台阶的数目加上到第 n - 1 级台阶的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> climbStairs(n - <span class="hljs-number">1</span>) + climbStairs(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/20210907105418.png" alt="重叠子问题"></p><p>记忆化递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">memo = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(memo.contains(n)) <span class="hljs-keyword">return</span> memo[n];<br>  <span class="hljs-keyword">int</span> ans = climbStairs(n - <span class="hljs-number">1</span>) + climbStairs(n-<span class="hljs-number">2</span>)<br>  memo[n] = ans<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br>climbStairs(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><blockquote><p>举个例子：如果考试中的分数定义为 f，那么这个问题就可以被分解为语文，数学，英语等子问题。显然子问题最优的时候，总分这个大的问题的解也是最优的。</p></blockquote><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><blockquote><p>数学考得高不能影响英语（现实其实可能影响，比如时间一定，投入英语多，其他科目就少了）。</p></blockquote><h2 id="动态规划三要素"><a href="#动态规划三要素" class="headerlink" title="动态规划三要素"></a>动态规划三要素</h2><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>定义好状态可以画出递归树</p><blockquote><p>好在状态的定义都有特点的套路。 比如一个字符串的状态，通常是 dp[i] 表示字符串 s 以 i 结尾的 ….。 比如两个字符串的状态，通常是 dp[i][j] 表示字符串 s1 以 i 结尾，s2 以 j 结尾的 ….。</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p>最佳买卖股票时机，含冷冻期</p><blockquote><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p></blockquote><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p>示例: </p><p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p></li><li>递归思路</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span></span>&#123;<br>      Freeze,<br>      Buy,<br>      Sell<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>      dfs(prices,State.Buy,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices,State state,<span class="hljs-keyword">int</span> count,<span class="hljs-keyword">int</span> day)</span></span>&#123;<br>      <span class="hljs-keyword">if</span> (day==prices.length-<span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-keyword">if</span>(state==State.Sell)&#123;<br>              ans = Math.max(ans,count+prices[day]);<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              ans = Math.max(ans,count);<br>          &#125;<br><br>          <span class="hljs-keyword">return</span> ;<br>      &#125;<br>      <span class="hljs-keyword">int</span> nextDay = day+<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (state==State.Freeze)&#123;<br>          <span class="hljs-comment">//冻结了，下一天可以买</span><br>          dfs(prices,State.Buy,count,nextDay);<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state==State.Sell) &#123;<br>          <span class="hljs-comment">//表示卖，下一天进行冻结</span><br>          dfs(prices,State.Freeze,count+prices[day],nextDay);<br>          <span class="hljs-comment">//表示不卖，继续下一天</span><br>          dfs(prices,State.Sell,count,nextDay);<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//表示不买，下一天可以继续买</span><br>          dfs(prices,State.Buy,count,nextDay);<br>          <span class="hljs-comment">//表示买，下一天可以卖</span><br>          dfs(prices,State.Sell,count-prices[day],nextDay);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol><li>动态规划思路，划分状态，持有和不持有<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices ==<span class="hljs-keyword">null</span> || prices.length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[][] dp=  <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">//1代表持有股票，0代表不持有股票，2代表过渡期</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt; prices.length;i++)&#123;<br>        <span class="hljs-comment">//第i天有股票，第i-1天有股票，第i-1天没有股票</span><br>        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//第i天没有股票，第i-1天没有股票，第i-1天是过渡期</span><br>        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">//第i天是过渡期，第i-1天是过渡期</span><br>        dp[i][<span class="hljs-number">2</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>例题 198  </p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p></blockquote><p>题目解读，不能偷相邻的</p><p>  我到第i家的时候，如果我偷了这家的，那么我的收益就是偷了第i-2家的收益，加上我这家的收益。</p><p>  如果我不偷这家的话，那么我的收益就是偷了第i-1家的最大收益。</p><p>  我可以拿到的最大收益就是这两家中间比较大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i&lt;f.length;i++)&#123;<br>            f[i]=Math.max(nums[i-<span class="hljs-number">1</span>]+f[i-<span class="hljs-number">2</span>],f[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[nums.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>53.最大子序和</p><p>给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p><p>例子：<script type="math/tex">nums=[-2,-1,3,4,-1,2,1,-5,4]</script></p><div class="table-container"><table><thead><tr><th>nums</th><th>-2</th><th>-1</th><th>3</th><th>4</th><th>-1</th><th>2</th><th>1</th><th>-5</th><th>4</th></tr></thead><tbody><tr><td>f</td><td>-2</td><td>-1</td><td>3</td><td>7</td><td>6</td><td>8</td><td>9</td><td>4</td><td>8</td></tr></tbody></table></div><p>f[i]代表的是前i个以nums[i]能够到达的最大和（这边存在疑问？f应该不是这样指的这个函数）</p><p>然后从前面的拿出一个最大值便可以了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mx = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> ans =mx; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            mx = Math.max(nums[i],mx+nums[i]);<br>            ans = Math.max(mx,ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>152.乘积最大子数组</p><p>给你一个整数数组nums，请你找出数组中乘积最大的连续子数组，并且返回改子数组对应的乘积</p><script type="math/tex; mode=display">nums=[2,3,-2,4]</script><div class="table-container"><table><thead><tr><th>nums</th><th>2</th><th>3</th><th>-2</th><th>4</th></tr></thead><tbody><tr><td>maxf</td><td>2</td><td>6</td><td>-2</td><td>4</td></tr><tr><td>minf</td><td>2</td><td>3</td><td>-12</td><td>-48</td></tr></tbody></table></div><p>maxf[i]代表的是，以<strong>nums[i]</strong>为结尾的最大的连续子数组的最大乘积，该状态需要考虑最小的和最大的，因为负负可以为正数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> mx= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> mn= nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> ans =nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> temp_mx=mx;<br>            mx= Math.max(mx*nums[i],Math.max(mn*nums[i],nums[i]));<br>            mn= Math.min(temp_mx*nums[i],Math.min(mn*nums[i],nums[i]));<br>            ans = Math.max(mx,ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>删除并获得点数<br><img src="https://cdn.jsdelivr.net/gh/nomanker/images@master/data/16345555295341634555529528.png" alt=""></li></ol><p>解题思路：<br>    假如有 3,3,3,4,4,5,5,6,6,6这些值，那么我们可以发现，我们拿了3，4就会被全部删除，<br>    因此3是可以全部拿走的，因此本道题，我们进行排序，然后将题目整合成 9，8，10，18，<br>    也就是和打家劫舍题目一样，不能拿相邻的，但是我们还是可能出现3，5，6，7这种例子，那么的话，3和5是不相邻的，所以3，5是可以同时删除的，因此我们需要一个4，具体原理如下表：</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>3</td><td>0</td><td>5</td><td>6</td><td>7</td></tr></tbody></table></div><p>接下来便可以按照打家劫舍进行动态规划的求解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : nums) &#123;<br>            maxVal = Math.max(maxVal, val);<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxVal + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : nums) &#123;<br>            sum[val] += val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rob(sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = nums.length;<br>        <span class="hljs-keyword">int</span> first = nums[<span class="hljs-number">0</span>], second = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">int</span> temp = second;<br>            second = Math.max(first + nums[i], second);<br>            first = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典，判断<code>s</code>是否可以由空格拆分为一个或多个在字典中出现的单词，拆分是可以重复使用字典中的单词。</p><p>示例一:<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>]<br>返回<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></p><p><code>dp[i]</code>代表前i个元素可以被<code>wordDict</code>拆分<br>，这边的疑惑点在于<code>dp[0]</code>代表什么含义，前0个元素,可以被拆分，在左闭右开的区间里面，$[0,0)$代表的是前0个元素，代表的是空集，空集可以被拆分，而如果是$[0,1)$，代表的是前一个元素可以被拆分,对应<code>s[0]</code>,因此<code>dp[0]=true</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(wordDict);<br>        <span class="hljs-comment">//dp[i]代表可以第i个位置可以被拆分</span><br>        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;=s.length();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j]&amp;&amp;set.contains(s.substring(j,i)))&#123;<br>                    dp[i]=<span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode树专题-简单</title>
    <link href="/2021/09/05/leetcode/Leetcode%E6%A0%91%E4%B8%93%E9%A2%98-%E7%AE%80%E5%8D%95/"/>
    <url>/2021/09/05/leetcode/Leetcode%E6%A0%91%E4%B8%93%E9%A2%98-%E7%AE%80%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>​<a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/QQ%E6%88%AA%E5%9B%BE20210905161328.png" alt=""></p><blockquote><p>分别将两棵树的叶子节点存放到对应的数组，然后对数组进行比较</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; ans1=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; ans2=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        dfs1(root1);<br>        dfs2(root2);<br>        <span class="hljs-keyword">if</span>(ans1==<span class="hljs-keyword">null</span>&amp;&amp;ans2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(ans1==<span class="hljs-keyword">null</span>||ans2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(ans1.size()!=ans2.size()) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;ans1.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(ans1.get(i)!=ans2.get(i))&#123;<br>                <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>) ans1.add(root.val);<br>        dfs1(root.left);<br>        dfs1(root.right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>) ans2.add(root.val);<br>        dfs2(root.left);<br>        dfs2(root.right);<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/QQ%E6%88%AA%E5%9B%BE20210905161730.png" alt=""></p><blockquote><p>按照BFS遍历每一层，然后将每一层的节点同一时间放入数组存放，然后进行保存即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; theAns;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        ArrayDeque&lt;TreeNode&gt; deque =<span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        deque.add(root);<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            theAns = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> size = deque.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                TreeNode tmp = deque.peek();<br>                theAns.add(tmp.val);<br>                <span class="hljs-keyword">if</span>(tmp.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    deque.add(tmp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    deque.add(tmp.right);<br>                &#125;<br>                deque.pop();<br>            &#125;<br>            ans.add(theAns);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><img src="https://raw.githubusercontent.com/nomanker/images/master/data/3.png" alt=""></p><blockquote><p>这也是一道简单题，利用二叉搜索树的性质可以避免没有必要的查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val==val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val&gt;val) <span class="hljs-keyword">return</span> searchBST(root.left,val);<br>        <span class="hljs-keyword">if</span>(root.val&lt;val) <span class="hljs-keyword">return</span> searchBST(root.right,val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
